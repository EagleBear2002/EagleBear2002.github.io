<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eaglebear2002.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"always","padding":18,"offset":12,"onmobile":true,"scroll_to_top_on_sidebar_toggle":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文主要内容来自 SpriCoder的博客，更换了更清晰的图片并对原文的疏漏做了补充和修正。 文件的概念 文件是由新消息按一定结构组成，可持久化保存的抽象机制，由于它必定存储在某种设备上，故也可以认为文件是设备的一种抽象。 文件由文件名标识，用户通过文件名就可以对文件进行访问。 文件（document）与计算机文件（file）的区别">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机与操作系统-05-文件管理">
<meta property="og:url" content="https://eaglebear2002.github.io/41267/index.html">
<meta property="og:site_name" content="EagleBear2002 的博客">
<meta property="og:description" content="本文主要内容来自 SpriCoder的博客，更换了更清晰的图片并对原文的疏漏做了补充和修正。 文件的概念 文件是由新消息按一定结构组成，可持久化保存的抽象机制，由于它必定存储在某种设备上，故也可以认为文件是设备的一种抽象。 文件由文件名标识，用户通过文件名就可以对文件进行访问。 文件（document）与计算机文件（file）的区别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/1.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/2.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/3.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/4.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/26.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/17.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/18.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/19.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/13.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/14.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/20.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/6.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/21.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/7.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/21.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/16.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/11.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/22.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/23.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/24.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/27.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/9.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/10.png">
<meta property="og:image" content="https://eaglebear2002.github.io/41267/25.png">
<meta property="article:published_time" content="2022-12-14T10:55:00.000Z">
<meta property="article:modified_time" content="2025-10-02T04:11:35.806Z">
<meta property="article:author" content="EagleBear2002">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eaglebear2002.github.io/41267/1.png">

<link rel="canonical" href="https://eaglebear2002.github.io/41267/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机与操作系统-05-文件管理 | EagleBear2002 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<script>
  hljs.initLineNumbersOnLoad();
</script>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EagleBear2002 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里必须根绝一切犹豫，这里任何怯懦都无济于事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">61</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">481</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eaglebear2002" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eaglebear2002.github.io/41267/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="EagleBear2002">
      <meta itemprop="description" content="暮雪朝霜，毋改英雄意气">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EagleBear2002 的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机与操作系统-05-文件管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-14 18:55:00" itemprop="dateCreated datePublished" datetime="2022-12-14T18:55:00+08:00">2022-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-02 12:11:35" itemprop="dateModified" datetime="2025-10-02T12:11:35+08:00">2025-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">南京大学软件学院本科课程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/2022Fall-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">2022Fall-计算机与操作系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要内容来自 <a target="_blank" rel="noopener" href="https://spricoder.github.io/">SpriCoder的博客</a>，更换了更清晰的图片并对原文的疏漏做了补充和修正。</p>
<h2 id="文件的概念">文件的概念</h2>
<p><strong>文件</strong>是由新消息按一定结构组成，可持久化保存的抽象机制，由于它必定存储在某种设备上，故也可以认为文件是设备的一种抽象。</p>
<p><strong>文件</strong>由文件名标识，用户通过文件名就可以对文件进行访问。</p>
<p><strong>文件</strong>（document）与<strong>计算机文件</strong>（file）的区别</p>
<h3 id="文件的命名">文件的命名</h3>
<p>文件名是字母、数字或其他符号组成的字母数字串，其格式和长度因系统而异。</p>
<p>文件命名一般包括<strong>文件名和扩展名</strong>。</p>
<p>前者用于识别文件，后者用于标识文件特性，两者之间用<code>.</code>隔开。</p>
<p>每个 OS 都有约定的扩展名，Windows 中：</p>
<ol>
<li><code>.COM</code> 表示可执行的二进制代码文件</li>
<li><code>.EXE</code> 表示可执行的浮动二进制代码文件</li>
<li><code>.LIB</code> 表示库程序文件</li>
<li><code>.BAT</code> 表示批命令文件</li>
<li><code>.OBJ</code> 表示编译或汇编生成的目标文件</li>
</ol>
<p>UNIX 的约定文件名，请大家自己阅读。</p>
<h3 id="文件的分类">文件的分类</h3>
<ol>
<li>按<strong>用途</strong>可分成：系统文件、库文件、用户文件</li>
<li>按<strong>保护级别</strong>可分成：只读文件、读写文件、不保护文件</li>
<li>按<strong>信息时限</strong>可分成：临时文件、永久文件、档案文件</li>
<li>按<strong>设备类型</strong>可分成：磁盘文件、磁带文件、光盘文件、软盘文件</li>
<li>还可以按文件的<strong>逻辑结构或物理结构</strong>分类</li>
<li>Linux 系统支持文件：普通文件、目录文件、特殊文件（外部设备文件，可分为块设备文件和字符设备文件）</li>
</ol>
<h3 id="引入文件的优点">引入文件的优点 *</h3>
<ol>
<li><strong>用户使用方便</strong>，使用者无需记住信息存放在辅助存储器（外存）中的物理位置，也无需考虑如何将信息存放到存储介质上，只要知道文件名，给出有关操作系统要求便可存取信息，实现了“按名存取”</li>
<li><strong>文件安全可靠</strong>，由于用户通过文件系统才能实现对文件的访问，而文件系统能提供各种<strong>安全、保密和保护</strong>措施，故可防止对文件信息的有意或无意的破坏或窃用</li>
<li><strong>系统能有效地利用存储空间（文件可备份）</strong>，优化安排不同属主的文件的位置，如果文件使用过程中出现设备故障，系统组织重执或恢复，对因硬件失效而可能造成的信息破坏可组织转储以加强可靠性。</li>
<li><strong>文件可共享</strong>，文件系统还能提供文件的共享功能，如不同的用户可以使用同名或异名的同一文件，提高了文件和文件空间的利用率</li>
<li>总之，把数据组织成文件形式加以管理和控制是计算机数据管理的重大进展</li>
</ol>
<h2 id="文件系统及其功能">文件系统及其功能</h2>
<h3 id="文件系统的概念">文件系统的概念</h3>
<p>文件系统是操作系统中负责存取和管理信息的模块，它用统一的方式管理用户和系统信息的存储、检索、更新、共享和保护，并为用户提供一整套方便有效的文件使用和操作方法。</p>
<p>通常把文件与管理信息资源的管理程序的集合，是操作系统中负责存取和管理信息资源的模块，采用统一方法管理用户信息和系统信息的存储、检索、更新、共享和保护，并为用户提供一整套行之有效的文件使用及操作系统。</p>
<h3 id="文件系统中的文件">文件系统中的文件</h3>
<p>文件这一术语不但反映了用户概念中的<strong>逻辑结构</strong>，而且和存放它的辅助存储器（也称文件存储器）的<strong>存储结构</strong>紧密相关。</p>
<p>所以，同一个文件必须从<strong>逻辑文件</strong>和<strong>物理文件</strong>两个侧面来观察它。</p>
<ol>
<li>对于用户，需要并遵守<strong>文件系统的规则</strong>来定义文件信息的逻辑结构，由文件系统提供<strong>按名存取</strong>方式来实现对文件信息的存储和检索。</li>
<li>对于系统，必须采用<strong>特定数据结构和有效算法</strong>实现文件的<strong>逻辑结构到存储结构</strong>的映射，实现对文件存储空间和文件信息的管理，提供多种存取方法。</li>
</ol>
<h3 id="文件系统的功能">文件系统的功能</h3>
<p>文件系统面向用户的功能是：</p>
<ol>
<li>文件的按名存取</li>
<li>文件的共享、保护和加密</li>
<li>文件的操作和使用（文件的查找和定位）</li>
</ol>
<p>为了实现这些功能，OS 必须考虑：</p>
<ol>
<li>文件目录的建立和维护</li>
<li>存储空间的分配和回收</li>
<li>数据的保密和保护</li>
<li>监督用户存取和修改文件的权限</li>
<li>实现在不同存储介质上信息的表示方式、编址方法、存储次序，以及信息检索等问题</li>
<li>实现从逻辑文件到物理文件的转换</li>
<li>提供文件的存取方法和文件存储结构</li>
<li>提供给一组易用的文件操作和命令</li>
<li>提供与设备管理交互的统一接口</li>
</ol>
<h3 id="文件系统的组成">文件系统的组成</h3>
<img src="/41267/1.png" style="zoom: 33%;">
<h2 id="文件组织与存储">文件组织与存储</h2>
<h3 id="卷和块">卷和块</h3>
<p>文件存储介质有磁带、光盘和磁盘。</p>
<p><strong>卷</strong>是存储介质的物理单位，对应于一盘磁带、一块软盘、一个光盘片、一个硬盘分区。</p>
<p><strong>块</strong>是存储介质上连续信息所组成的一个区域，也叫做<strong>物理记录</strong>。</p>
<ol>
<li>块是主存储器和辅助存储器进行信息交换的<strong>物理单位</strong>，每次总是交换一块或整数块信息</li>
<li>决定块的大小要考虑<strong>用户使用方式、数据传输效率和存储设备类型</strong>等多种因素</li>
<li>不同类型的存储介质，块的长短常常各不相同；对同一类型的存储介质，块的大小一般相同，但也可以不同</li>
</ol>
<p>外围设备由于启停机械动作或识别不同块的要求，两个相邻块之间必须留有间隙，间隙是块之间不记录用户代码信息的区域</p>
<h3 id="顺序存取存储设备的信息安排">顺序存取存储设备的信息安排</h3>
<ol>
<li>顺序存取设备是严格依赖信息的物理位置次序进行定位和读写的存储设备</li>
<li><strong>磁带机</strong>是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和便于保存等优点，广泛用作存档</li>
<li>磁带的一个<strong>突出特点</strong>是<strong>块长的变化范围较大</strong>，块可以很小，也可以很大，原则上没有限制</li>
<li><strong>光盘</strong>也是一种顺序存取存储设备，光盘上的<strong>磁道不是同心圆，而是螺旋形的，本质的线性的。</strong></li>
</ol>
<h3 id="直接存取存储设备的信息安排">直接存取存储设备的信息安排</h3>
<ol>
<li>磁盘是一种直接存取存储设备，又叫<strong>随机存取存储设备</strong>；</li>
<li><strong>移臂与旋转</strong>两维组织，存取速度高；</li>
<li>它的每个物理记录有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置。</li>
</ol>
<h2 id="文件的逻辑结构">文件的逻辑结构</h2>
<p>独立于<strong>物理环境</strong>的，用户概念中的<strong>抽象信息组织方式</strong>是<strong>文件的逻辑结构</strong>。</p>
<p>用户能观察到的，并加以处理的数据集合构成<strong>逻辑文件</strong>。</p>
<p>文件的逻辑结构分为两种形式：</p>
<ol>
<li>一种是流式文件</li>
<li>一种是记录式文件</li>
</ol>
<h3 id="流式文件">流式文件</h3>
<p><strong>流式文件</strong>是<strong>无结构</strong>文件，指文件内的数据不再组成记录，只是由一串依次的<strong>字节</strong>组成的<strong>信息流序列</strong>，称为<strong>字节流文件</strong>。</p>
<p>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界，使用读写指针访问。</p>
<p>大多数现代操作系统比如 Linux 系统只提供流式文件。</p>
<h3 id="记录式文件">记录式文件</h3>
<p>记录式文件是一种<strong>有结构</strong>的文件，它是若干<strong>逻辑记录信息</strong>所组成的记录流文件</p>
<p>逻辑记录是文件中按<strong>信息</strong>在<strong>逻辑</strong>上的<strong>独立含义</strong>所划分的信息单位</p>
<p>如：每个职工的工资信息是一个<strong>逻辑记录</strong>；整个单位职工的工资信息便组成了该单位工资信息的<strong>记录式文件</strong></p>
<p>逻辑记录是文件内<strong>独立的最小信息单位</strong>，文件记录位置代替字节位置。</p>
<p>记录是文件常用的记录组织和使用方法：</p>
<ol>
<li>记录式顺序文件：文件的记录顺序生成并被顺序访问。</li>
<li>记录式索引文件：文件使用索引表，表项包含记录键和索引指针，记录键由应用程序确定，而索引文件便指向相应记录。</li>
</ol>
<img src="/41267/2.png" style="zoom:33%;">
<h3 id="记录式文件与数据库">记录式文件与数据库</h3>
<ol>
<li>数据库管理系统也支持逻辑记录</li>
<li>但数据库有别于记录式文件，数据库中的记录之间可以通过数据冗余构成某种联系</li>
<li>数据库管理系统支持基于联系的数据查询，文件系统则不行</li>
</ol>
<h2 id="记录的成组与分解">记录的成组与分解</h2>
<h3 id="成组与分解的提出">成组与分解的提出</h3>
<p>逻辑记录是按信息在逻辑上的<strong>独立含义</strong>由用户所划分的<strong>单位</strong>。</p>
<p>块是系统划分的存储介质上连续信息所组成的区域。</p>
<ol>
<li>一条逻辑记录被存放到文件存储器的存储介质上时可能占用一个或多块，或者一个物理块包含多条逻辑记录。</li>
<li>扇区也叫做物理块，或者物理记录</li>
</ol>
<p>组：若干逻辑记录的组合。</p>
<p>块因子：每块中逻辑记录的个数。比如物理块 800K，卡片 80K，此时的块因子数就是 10。</p>
<p>对于流式文件，一个物理记录可以存放很多个连续字节。</p>
<h3 id="成组与分解操作">成组与分解操作</h3>
<ol>
<li>系统设置独立于用户数据区的<strong>输入/输出缓冲区</strong></li>
<li><strong>记录的成组操作</strong>：在<strong>输出缓冲区</strong>内进行，凑满一块后才将缓冲区内的信息写到存储介质上</li>
<li><strong>记录的分解操作</strong>：当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作</li>
</ol>
<img src="/41267/3.png" style="zoom:33%;">
<h3 id="成组与分解的特征">成组与分解的特征</h3>
<p>优点：记录成组与分解不仅<strong>节省存储空间</strong>，还能<strong>减少输入输出操作次数</strong>，提高系统效率。</p>
<p>记录成组与分解处理带来的新特征：</p>
<ol>
<li><strong>提前读</strong>：用户读请求，导致包含该逻辑记录的<strong>物理块</strong>读入输入缓冲区；这一操作可能读入了多个逻辑记录，可以更快的访问附近的记录。</li>
<li><strong>推迟写</strong>：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出。f 副作用：因为优先写到输出缓冲区，等到缓冲区满，才会写到磁盘，可能会造成<strong>数据不一致</strong>（写到缓冲区，但是因为<strong>停电</strong>等原因没有办法同步到磁盘）</li>
</ol>
<h3 id="记录格式">记录格式</h3>
<ol>
<li>逻辑记录的长度：一条逻辑记录中所有数据项长度的总和。</li>
<li>记录格式：记录内数据的排列方式。</li>
<li>记录式文件中，记录长度取决于应用程序的需要，记录格式有
<ol>
<li>定长记录</li>
<li>变长记录</li>
<li>跨块记录</li>
</ol>
</li>
</ol>
<h4 id="定长记录">定长记录</h4>
<ol>
<li>记录式文件中所有的逻辑记录具有相同长度，同时所有数据项的相对位置也是固定的。</li>
<li>处理方便，易于控制：成组除了最后一块，块内逻辑记录个数相同。</li>
</ol>
<h4 id="变长记录">变长记录</h4>
<ol>
<li>记录式文件中所有的逻辑记录长度不相等，但每条逻辑记录长度处理前能预先确定。逻辑记录中的第一个字段指明单个变长逻辑记录的字节数，第二个字段存放记录信息。</li>
<li>导致变长记录的情况
<ol>
<li>包含一个或多个可变长度的数据项。</li>
<li>包括可变数量的定长数据项。</li>
</ol>
</li>
<li>处理复杂，但是节省存储空间。</li>
</ol>
<h4 id="跨块记录">跨块记录</h4>
<ol>
<li>逻辑记录长度大于块大小，不需要记录块长度，文件系统自动分割和装配跨块逻辑记录的信息段。</li>
<li>分割存储，读出装配、</li>
<li>适用于在不同物理特性的设备类型之间传输时。</li>
</ol>
<h4 id="记录键">记录键</h4>
<ol>
<li>记录键：用于标识<strong>某条逻辑记录</strong>的数据项，叫关键字，简称键。</li>
<li>在同一个文件中，能够唯一表示某条逻辑记录的记录键称为主键。</li>
<li>主键是最重要的，但是并不一定唯一。</li>
</ol>
<h2 id="文件的物理结构">文件的物理结构</h2>
<p>文件的物理结构和组织是指<strong>逻辑文件在物理存储空间中的存放方法和组织关系</strong>。</p>
<ol>
<li>此时文件看做物理文件，即相关物理块的集合；</li>
<li>文件的存储结构涉及<strong>块的划分、记录的排列、索引的组织、信息的搜索</strong>等许多问题。</li>
</ol>
<p><strong>文件存储结构的优劣</strong>直接影响文件系统的性能。</p>
<h3 id="构造文件物理结构">构造文件物理结构</h3>
<p>计算法：</p>
<ol>
<li>设计映射算法，通常有线性计算法、杂凑法等，通过对记录键进行计算转换成对应的物理地址，从而找到所需记录。</li>
<li>直接寻址文件、计算寻址文件和顺序文件均属于此类。</li>
<li>存取效率高，不必增加存储空间存放附加控制信息。</li>
</ol>
<p>指针法：</p>
<ol>
<li>设置专门指针，指明相应记录的物理地址或表达各记录之间的关联。</li>
<li>索引文件、索引顺序文件、连接文件均属于此类。</li>
<li>可以将文件信息的逻辑次序与在存储介质上的物理块排列次序完全分开，便于随机存储，便于更新，但是消耗存储空间。</li>
</ol>
<h3 id="顺序文件">顺序文件</h3>
<p>将一个文件中<strong>逻辑上连续</strong>的信息存放到<strong>存储介质的依次相邻的块</strong>中便形成顺序结构，这类文件叫<strong>顺序文件</strong>，又称<strong>连续文件</strong></p>
<p>FCB 保存第一个物理块地址和总块数。</p>
<p>磁带文件、光盘文件是典型例子，批处理文件，系统文件用得最多</p>
<p>顺序文件的特点：</p>
<ol>
<li>优点：顺序存取记录时速度快</li>
<li>缺点：建立文件前需要预先知道文件长度，修改、插入和添加文件记录困难，变长记录处理困难，空闲块的浪费。</li>
</ol>
<h3 id="连接文件">连接文件</h3>
<img src="/41267/4.png" style="zoom:33%;">
<p>连接文件，又称串联文件，输入井、输出井都是此类文件。使用连接字（指针）来表示文件中各条记录之间的关系。</p>
<p>第一块文件信息的物理地址由文件目录给出， 而每一块的连接字指出了文件的下一个物理块位置；连接字内容为 0 时，表示文件至本块结束。</p>
<p>连接文件的特点：</p>
<ol>
<li>优点：易于对文件记录做<strong>增、删、改</strong>，易于动态增长记录；不必预先确知文件长度；存储空间利用率高；</li>
<li>缺点：存放指针需<strong>额外的存储空间</strong>；由于存取须通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而，仅适用于顺序存取。</li>
</ol>
<h3 id="直接文件">直接文件</h3>
<p><strong>直接文件、散列文件或哈希文件</strong>：在直接存取存储设备上，利用哈希法将记录的关键字与其地址之间建立某种对应关系，以便实现快速存取的文件</p>
<p>在 Linux 系统中，常用哈希法实现 cache。</p>
<p>计算寻址结构可能出现“冲突”，即不同的关键字可能变换出<strong>相同的地址</strong>来，解决办法是溢出处理技术，包含有<strong>链表法、循环探查法、二次散列法、溢出区法</strong>等。</p>
<p>访问过程：</p>
<ol>
<li>构造哈希函数：得到哈希后块号 A</li>
<li>建立目录文件，将记录放置到对应的块 A 中</li>
<li>查找文件：根据文件名，计算出 A，然后加载物理块，在物理块中遍历找到对应文件。</li>
<li>溢出处理：结合溢出处理技术。</li>
</ol>
<h3 id="索引文件">索引文件</h3>
<p>索引文件为每个文件建立了一张<strong>索引表</strong>，每个表目包含一个记录的键（或逻辑记录号）及其存储地址。索引表记录方式有多种：</p>
<ol>
<li>记录组成文件的磁盘块号，适用于流式文件。</li>
<li>所以表项包含记录键及其磁盘块号，适用于记录式文件。</li>
</ol>
<p><strong>索引文件</strong>：利用索引表来搜索记录的文件。</p>
<p><strong>索引表</strong>可存放在 FCB 文件中，记录可以散列存储。</p>
<p>适用于数据记录保存在磁盘上的文件。</p>
<img src="/41267/26.png" style="zoom:33%;">
<h4 id="索引文件的访问方式">索引文件的访问方式</h4>
<p>索引文件在文件存储器上分两个区：<strong>索引区和数据区</strong></p>
<p>访问索引文件需两步操作</p>
<ol>
<li>第一步查找索引表</li>
<li>第二步获得记录物理地址</li>
</ol>
<p>需要两次访问辅助存储器，若文件索引已预先调入主存储器，那么，就可减少一次内外存信息交换。</p>
<h4 id="索引文件的特点">索引文件的特点</h4>
<p><strong>索引结构</strong>可以被认为是<strong>连接结构的一种扩展</strong>，除了具备连接文件的优点外，还克服了它只能作顺序存取的缺点，具有直接读写任意一个记录的能力，便于文件的增、删、改。</p>
<p><strong>索引顺序文件</strong>是<strong>顺序文件</strong>的一种扩展。</p>
<p>索引文件的<strong>缺点</strong>是：增加了索引表的<strong>空间开销和查找时间</strong>。</p>
<h4 id="索引表的组织（重要）">索引表的组织（重要）</h4>
<ol>
<li>一级索引：存放的是物理地址</li>
<li>两级索引：若干索引本身也是一种记录。</li>
<li>多级索引：以三级索引为例，一个地址指引 $128^3$ 个地址，但是全部使用三级索引也不行，性能会比较差，所以我们往往选择使用混编的方式。</li>
<li>动态扩容：放不下就扩容</li>
</ol>
<img src="/41267/17.png" style="zoom: 50%;">
<ol start="5">
<li>inode 规定了 15 个索引项，每项 4KB
<ol>
<li>直接索引：前 12 项存放文件信息的磁盘块号</li>
<li>一次间接索引：第 13 项指向一个物理块</li>
<li>二次间接索引：第 14 项指向一个物理块</li>
<li>三次间接索引：第 15 项指向一个物理块</li>
<li>ext2 中，每个物理块存放 1024B，所以上面右图最多存放$12KB + 256KB + 256^2KB+256^3KB$</li>
</ol>
</li>
<li>长度不超过 12 个磁盘块的占 80%，只有超过 12 个磁盘块才使用简介索引。</li>
<li>多级索引例子（重要）：注意是从 0-128 一共 129 项</li>
</ol>
<table>
<thead>
<tr>
<th><img src="/41267/18.png" alt></th>
<th><img src="/41267/19.png" alt></th>
</tr>
</thead>
</table>
<h2 id="文件的目录结构">文件的目录结构</h2>
<p>文件系统往往采用分层结构实现，大概分为文件管理、目录管理和磁盘管理三层。</p>
<ol>
<li>文件管理实现文件逻辑结构，为用户提供各种文件系统调用及文件访问权限的设置工作。</li>
<li>目录管理负责查找文件描述符，进而找到需要访问的文件，并进行访问权限检查等工作，还需要完成目录的添加、删除、重排等操作</li>
<li>磁盘管理除管理文件空间外，还将文件的逻辑地址转换为磁盘的物理地址，即由逻辑块号找到柱面号、磁头号与扇区号，设备与内存之间的数据传输操作由文件系统调用设备管理实现。</li>
</ol>
<p>文件的目录结构中往往是具有双向索引结构的，如下图</p>
<img src="/41267/13.png" style="zoom:33%;">
<h3 id="文件控制块（File-Control-Block，FCB）">文件控制块（File Control Block，FCB） *</h3>
<ol>
<li>文件控制块是操作系统为每个文件建立的唯一数据结构，包含了全部的文件属性。</li>
<li>目的是为方便操作系统对文件的管理、控制和存取。</li>
<li>文件由 FCB 和文件体组成，创建文件时，系统要同时创建 FCB。</li>
</ol>
<h3 id="文件目录">文件目录</h3>
<p>文件目录是实现文件的<strong>按名存取</strong>的关键数据结构，目录结构一般是层次性的、非线性的，多维坐标可以通过一定方式降成一维坐标。</p>
<p>文件目录需要永久保存，因此也组织成文件存放在磁盘上，称<strong>目录文件</strong></p>
<ol>
<li>需要时调入内存；</li>
<li>目录文件永不为空，至少包含当前目录 <code>.</code> 和父目录 <code>..</code></li>
</ol>
<p>为了加快文件查找速度，通常将<strong>FCB 汇集和组织</strong>在一起形成文件目录，文件目录包含许多目录项，目录项分为两种，分别描述子目录和描述文件。</p>
<p>文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录<strong>便于查找、防止冲突</strong></p>
<h3 id="Linux-系统的文件目录建立方法">Linux 系统的文件目录建立方法 *</h3>
<p>Unix 系统中，文件的索引结构存放在 inode 节点中。</p>
<ol>
<li>FCB 中的<strong>文件名和其他管理信息</strong>分开，其他信息单独组成一个<strong>数据结构</strong>，成为索引节点 inode，此节点的位置由 inode 号标识。</li>
</ol>
<img src="/41267/14.png" style="zoom:33%;">
<ol start="2">
<li>这样目录项就仅剩下了文件名和 inode 号，称为<strong>基本目录项</strong>，一个磁盘块就可以放置更多的基本目录项</li>
<li>inode 被集中存放在磁盘的 inode 区，和目录去是分割开的，按名存储是根据目录块进行的。
<ol>
<li>inode 允许一个文件可以被多次访问。</li>
<li>inode 不应该过多，类比图书馆卡片。</li>
</ol>
</li>
<li>能够减少索引文件所需访问的磁盘物理块数。</li>
<li>VFS 的 inode 的部分内容</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> &#123;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i_ino;                   <span class="hljs-comment">/* inode 号 */</span><br>   <span class="hljs-type">atomic_t</span> i_counl;                      <span class="hljs-comment">/* inode 引用数 */</span><br>   <span class="hljs-type">kdev_t</span> i_dev;                          <span class="hljs-comment">/* inode 所在设备*/</span><br>   <span class="hljs-type">loff_t</span> i_size;                         <span class="hljs-comment">/* inode 所在设备*/</span><br>   <span class="hljs-type">nlink_t</span> i_nlink;                       <span class="hljs-comment">/* inode 所在设备*/</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i_blksize;               <span class="hljs-comment">/* inode 所在设备*/</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i_block;                 <span class="hljs-comment">/* inode 所在设备*/</span><br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode_operations</span> * i_op;        <span class="hljs-comment">/* inode 所在设备*/</span><br>   ...<br>   <span class="hljs-keyword">union</span> &#123;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">minix_inode_info</span> minix_i;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ext2_inode_infb</span> ext2_i;<br>      ...<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="6">
<li>由于磁盘 inode 记录文件的属性和相关信息，会被频繁访问，我们在内存区开辟内存索引节点表，又称活动 inode 表，含 100 个表项，每个表项称为一个活动 inode
<ol>
<li>磁盘 inode 反应文件静态特性。</li>
<li>活动 inode 反应文件动态特性。</li>
</ol>
</li>
<li>嵌入在 inode 中的<strong>索引地址表</strong>不可以太大，不然对于一个大文件而言，就会比较大，根据下面公式我们可以发现 inode 区相同情况下放置的 inode 号就会变少，导致可能陷入磁盘还有物理空间，但是没有 inode 号可以使用的尴尬境地。
<ol>
<li>文件较小使用直接地址（直接索引）</li>
<li>文件较大使用间接索引</li>
</ol>
</li>
</ol>
<p>$$
total_{inode} = \frac{inode 区容量}{inode 尺寸（尽量小）}
$$</p>
<h3 id="层次目录结构">层次目录结构 *</h3>
<img src="/41267/20.png" style="zoom:33%;">
<h3 id="一级目录结构">一级目录结构</h3>
<p>一级目录结构：在操作系统中构造<strong>一张</strong>线性表，与每个文件的相关属性占用一个目录项，构成了一级目录结构。</p>
<p>缺点：由于用户与文件众多，容易重名，不利记忆；文件共享。</p>
<h3 id="二级目录结构">二级目录结构</h3>
<p>第一级为主文件目录，它用于管理<strong>所有用户文件目录</strong>，它的目录项登记了系统接受的用户的名字及该用户文件目录的地址。</p>
<p>第二级为用户的文件目录，它为该用户的每个文件保存一个登记栏，其内容与一级目录的目录项相同。</p>
<p>每一用户只允许查看自己的文件目录。</p>
<img src="/41267/6.png" style="zoom:33%;">
<p>特点：</p>
<ol>
<li>采用二级目录管理文件时，因为任何文件的存取都通过<strong>主文件目录</strong>，于是可以检查访问文件者的<strong>存取权限</strong>，避免一个用户未经授权就存取另一个用户的文件，使用户文件的<strong>私有性</strong>得到保证，实现了对文件的保密和保护</li>
<li>特别是不同用户具有同名文件时，由于各自有不同的用户文件目录而不会导致混乱</li>
<li>对于同一个用户而言，同样存在文件多、容易重名问题</li>
</ol>
<h3 id="树形目录结构">树形目录结构</h3>
<p>每一级目录可以登记下一级目录，也可以登记文件，从而，形成了<strong>层次文件目录结构</strong></p>
<p>层次目录结构通常采用<strong>树形目录结构</strong>，它是一棵倒向的有根树，树根是根目录；</p>
<ol>
<li>从根向下，每一个树分叉（树枝）是一个子目录</li>
<li>树叶是文件</li>
</ol>
<h4 id="不同类型的树形目录结构">不同类型的树形目录结构 *</h4>
<ol>
<li><strong>纯树型目录结构</strong>：每个文件都只有一个父目录，缺点：文件的共享不是对称的，其他授权用户必须通过属主目录才能访问文件。</li>
<li><strong>有向无环图</strong>则允许文件有多个父目录，破坏了树特性，但是不同用户可以用对称的方式实现文件共享，即可能属于不同用户的多个目录使用不同的文件名访问和共享同一个文件，维护复杂，需要维护文件的引用计数（用于文件删除）</li>
</ol>
<h4 id="不同操作系统的目录结构的实现">不同操作系统的目录结构的实现 *</h4>
<p>Linux 支持多父目录：</p>
<ol>
<li>主父目录是文件拥有者，文件存放在该目录下。</li>
<li>次父目录通过 link 方式来链接和引用。</li>
<li>下图中便示例这种文件共享的情形，文件 <code>/home/fei1</code> 为 <code>myfile.c</code> 的主父目录（图中实线表示），<code>/home/fei2</code> 和 <code>/home/fei3/fei4</code> 均为文件 <code>myfile.c</code> 的次父目录（图中虚线表示）。</li>
</ol>
<img src="/41267/21.png" style="zoom:33%;">
<p>Windows 实现被称作“快捷方式”的多父目录连结，快捷方式是一些指向不同文件夹（子目录）和菜单之间任意复制和移动的文件及文件夹的指针，删除快捷方式就是删除指针。</p>
<h4 id="树形目录结构的特点">树形目录结构的特点</h4>
<ol>
<li>较好地反映现实世界中具有<strong>层次关系</strong>的数据集合和较确切地反映系统内部文件的组织结构；</li>
<li>不同文件可以重名，只要它们不位于<strong>同一末端的子目录</strong>中；</li>
<li>易于规定不同层次或子树中文件的不同存取权限，便于文件的保护、保密和共享。</li>
</ol>
<h4 id="树形目录结构中的文件定位">树形目录结构中的文件定位</h4>
<ol>
<li>在树形目录结构中，一个文件的<strong>全名</strong>包括从根目录开始到文件为止，通路上遇到的所有子目录路径，又称为<strong>路径名</strong>；</li>
<li>各子目录名之间用正斜线<code>/</code>（反斜线<code>\</code>）隔开</li>
<li>一个硬盘分区可以组织成一颗子树
<ol>
<li>每棵子树可以对应于一个逻辑盘符（Win）：最多有 26 个逻辑盘符</li>
<li>也可以把众多子树嫁接成一颗大树（UNIX）</li>
</ol>
</li>
</ol>
<img src="/41267/7.png" style="zoom: 50%;">
<h2 id="文件目录的管理">文件目录的管理</h2>
<ol>
<li>输入包含路径的文件名（依据层次式的目录和结构解析）</li>
<li>在指定的时候目录块提取改文件的目录项</li>
</ol>
<h3 id="文件查找">文件查找</h3>
<img src="/41267/21.png" style="zoom:50%;">
<p>每个目录在创建时都自动含有两个特殊目录项：</p>
<ol>
<li><code>.</code>：目录自身的 inode 的入口</li>
<li><code>..</code>：父目录的 inode 的入口</li>
</ol>
<p>绝对路径与相对路径：</p>
<ol>
<li>绝对路径是从根目录开始往下进行推导。</li>
<li>相对路径是从当前目录开始往下进行推导。</li>
</ol>
<p>假设应用进程要打开文件 <code>/home/feil/myfile.c</code>，文件系统开始搜索</p>
<ol>
<li>首先，遇到根目录 <code>/</code>，它通常被存放在磁盘的固定盘块中，根据活动 inode 表中根目录的活动 inode，把它作为当前工作索引节点并将其第一个物理块读入内存缓冲区</li>
<li>接着读入路径的第一个分量字符串 <code>home</code>；文件系统对根目录的内容进行搜索，若找不到，则依次读入第二、第三个物理块，...，进行比较，直至找到 <code>home</code> 的 inode 号</li>
<li>检查活动 inode 表
<ol>
<li>若找不到 <code>home</code> 的 inode，为其分配一个活动 inode，由于每个 inode 位于磁盘上已分配好的固定位置，可从磁盘 <code>home</code> 的 inoe 中装人其内容；</li>
<li>否则，直接查找 <code>home</code> 的活动 inode，通过属性查明 <code>home</code> 为子目录，经核对符合访问权限，把它作为当前工作索引节点，读人路径的第二个分量字符串 <code>feil</code>，子目录 <code>home</code> 对应的 inode 为 685，从目录文件第一个物理块中可找到子目录 <code>feil</code> 的 inode 为 270</li>
</ol>
</li>
<li>类似地读入子目录 <code>feil</code> 目录文件的物理块便能找到 <code>myfile.c</code> 的 inode 号为 302；文件系统为此文件在活动 inode 表中分配一个活动 inode ， 从 <code>myfile.c</code> 的磁盘 inode 中装入内容。中间任何一步出错都会返回错误码，由于路径名分析完毕，这时修改活动 inode 的有关内容，打开文件目录的查找操作到此结束。</li>
</ol>
<p>现代操作系统都配置了更改工作目录的命令。</p>
<h3 id="目录项查找">目录项查找</h3>
<ol>
<li>顺序查找法：一次扫描</li>
<li>二分查找法：目录表项是按键顺序编排</li>
<li>杂凑法：把每个文件名经过变换函数变为唯一的目录表项。</li>
</ol>
<h3 id="文件目录处理">文件目录处理</h3>
<p>树型目录结构存在的一个问题是：当一个文件经过许多目录节点时，使用很不方便；系统在沿路径查找目录时，往往要多次访问文件存储器，使访问速度大大减慢；</p>
<p>若把所有文件的目录都复制到主存，访问速度是加快了，但又增加了主存的开销；</p>
<p>一种有效办法是把常用和正在使用的那些文件目录复制进主存，这样，既不增加太多的主存开销，又可明显减少目录查找时间。</p>
<h3 id="活动文件表">活动文件表</h3>
<p>系统可以为每个用户进程建立一张活动文件表，当用户使用一个文件之前，先通过“打开”操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系。</p>
<p>当不再使用该文件时，使用“关闭”，切断用户进程和这个文件的联系；同时，若该目录已被修改过，则应更新辅存中对应的文件目录</p>
<h2 id="文件系统功能及实现">文件系统功能及实现</h2>
<ol>
<li>文件系统向应用程序提供了一组系统调用，包括建立、打开、关闭、撤销、读/写和控制，通过这些系统调用，用户能够获得文件系统的各种服务。</li>
<li>系统会为每一个用户进程建立一张<strong>打开文件表</strong>
<ol>
<li>用户使用文件之前先通过<strong>打开</strong>操作，将文件 FCB 拷贝到指定内存位置</li>
<li>当不在使用时，通过<strong>关闭</strong>操作切断和文件的联系，释放文件的 FCB。</li>
</ol>
</li>
<li>接下来以 Linux 系统为例，介绍其文件系统调用的种类、功能和实现。内核将磁盘作为主要文件存储器，磁盘按扇区编号，扇区序列分成三个部分。</li>
<li>文件系统内部结构如下图所示：不是三级坐标，是经过转化后的结构</li>
</ol>
<img src="/41267/16.png" style="zoom:33%;">
<h3 id="扇区序列划分">扇区序列划分</h3>
<h4 id="引导块：0-号块">引导块：0 号块</h4>
<h4 id="超级块：1-号块">超级块：1 号块</h4>
<ol>
<li>存放<strong>文件系统结构和管理信息</strong>，如记录 inode 表所占盘块数、文件数据所占盘块数、主存中登记的空闲盘块数、主存中登记的空闲块物理块号、主存中登记的空闲 inode 数、主存中登记的空闲 inode 编号，及其他文件管理控制信息，</li>
<li>可见<strong>超级块</strong>既有<strong>盘位示图</strong>的功能，又记录<strong>整个文件卷的控制数据</strong>。</li>
<li>每当一个块设备作为文件卷
<ol>
<li>被安装时，该设备的超级块就要复制到<strong>主存系统区</strong>中备用</li>
<li>拆卸文件卷时，修改过的超级块需复制回磁盘的超级块中。</li>
</ol>
</li>
</ol>
<h4 id="磁盘-inode（索引节点）区：2-k-1-块">磁盘 inode（索引节点）区：2-(k+1) 块</h4>
<ol>
<li>一共 k 个块，k 不确定，在磁盘分区的时候确定</li>
<li>存放 inode 表，每个文件都有<strong>各种属性</strong>，它们被记录在称为索引节点 inode 的结构中；所有 inode 都有<strong>相同大小</strong>，且 inode 表是 inode 结构的列表，文件系统中的每个文件在该表中都有一个 inode。</li>
<li>又分<strong>磁盘 inode 表和主存活动 inode 表</strong>，后者解决频繁访问磁盘 inode 表的效率问题。</li>
</ol>
<h4 id="磁盘信息（数据）区：-k-2-及以后">磁盘信息（数据）区：(k+2) 及以后</h4>
<p>目录块和数据块（目录文件和数据文件的区别）：</p>
<ol>
<li>文件的内容保存在这个区域，磁盘上所有物理块的大小是一样的</li>
<li>如果文件包含超过一块的数据，则文件内容会存放在<strong>多个盘块</strong>中。</li>
</ol>
<h3 id="文件系统磁盘结构">文件系统磁盘结构</h3>
<ol>
<li><strong>用户打开文件表</strong>：进程的 PCB 结构中保留一个 files_struct，称为<strong>用户打开文件表或文件描述符表</strong>
<ol>
<li>表项的序号为文件描述符 fd</li>
<li>该登记项内<strong>登记系统打开文件表的一个入口指针 fp</strong></li>
<li>通过此系统打开文件表项<strong>连接到打开文件的活动 inode</strong>。</li>
</ol>
</li>
<li><strong>系统打开文件表</strong>：是为解决<strong>多用户进程共享文件、父子进程共享文件</strong>而设置的系统数据结构 file_struct
<ol>
<li>一个文件可能被多个进程同时打开或打开多次，导致位移量不同。</li>
<li>每次打开就是一个 file，多次打开就是多个 file。</li>
<li>一个 inode 可以连接 0 个或多个 file，多个 file 对应一个 inode。</li>
<li>内核内存区开辟最多存放 256 项的系统打开表区。</li>
</ol>
</li>
<li><strong>主存活动 inode 表</strong>：为解决频繁访问磁盘索引节点 inode 表的效率问题，系统开辟的主存区，正在使用的文件的 inode 被调入主存活动索引节点 inode 中，以加快文件访问速度。</li>
</ol>
<img src="/41267/11.png" style="zoom:33%;">
<h3 id="文件相关操作">文件相关操作</h3>
<h4 id="文件的使用">文件的使用</h4>
<ol>
<li>用户通过两类接口与文件系统联系</li>
<li>第一类是与文件有关的操作命令，例如，UNIX 中的 cat，cd，cp，find，mv，rm，mkdir，rmdir 等等</li>
<li>第二类是提供给用户程序使用的文件类系统调用，基本文件类系统调用有：建立、打开、读/写、定位、关闭、撤销</li>
</ol>
<h4 id="创建文件">创建文件</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fd;           <span class="hljs-comment">// 创建成功后系统返回的文件描述符</span><br><span class="hljs-type">int</span> mode;         <span class="hljs-comment">// mode 是文件所具有的权限</span><br><span class="hljs-type">char</span> *filenamep;  <span class="hljs-comment">// 指向要创建的文件路径名的字符串指针</span><br>fd = <span class="hljs-built_in">create</span>(filenamep, mode);<br></code></pre></td></tr></table></figure>
<ol>
<li>创建成功后，存取权限存放在 inode 的 i_mode 中。</li>
<li>fd 是创建成功后系统返回的<strong>文件描述符</strong>，即用户打开文件表中相应文件表项的序号。</li>
<li><code>create()</code> 创建的同时也<strong>打开</strong>了文件。</li>
<li>创建过程：<code>create(&quot;path&quot;, 0775)</code>
<ol>
<li>为新文件 newfile 分配磁盘 inode 和活动 inode，并把 inode 编号与文件分量名 newfile 组成新目录项，记到目录中，这个过程中执行目录检索程序。</li>
<li>在新文件所对应的活动 inode 中置初值，如置存取权限 <code>i_mode=0775</code>，连接计数 i_nlink=1 等。</li>
<li>分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>，为后者置初值，包括特征位为写，读写位移 <code>f_offset</code> 清 0。</li>
<li>把各表项及文件对应的活动 inode 用指针连接起来</li>
<li>把文件描述字 fd 返回给调用者。</li>
</ol>
</li>
</ol>
<h4 id="文件的删除">文件的删除</h4>
<ol>
<li>删除把指定文件从所在的<strong>目录文件</strong>中除去。</li>
<li>如果没有连接用户（i_link 为 1），还要<strong>把文件占用的存储空间释放</strong>。删除系统调用形式为：<code>unlink(filenamep)</code>。</li>
<li>在执行删除时，必须要求用户对该文件具有&quot;<strong>写</strong>&quot;操作权。</li>
</ol>
<h4 id="文件的打开">文件的打开</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fd, mode;<br><span class="hljs-type">char</span> * filenamep;<br>fd = <span class="hljs-built_in">open</span>(filenamep, mode);<br></code></pre></td></tr></table></figure>
<ol>
<li>文件使用前需要打开，以建立进程与文件之间的联系，而文件描述符唯一标识了这种连接，其任务是<strong>把文件的磁盘 inode 复制到内存活动 inode</strong>中去，同时建立一个独立的读写文件数据结构，即系统打开文件表的一个表项。</li>
<li>打开过程：
<ol>
<li>检索目录
<ol>
<li>如果没有则会出错</li>
<li>检索到指定文件后，把它的磁盘 inode 复制到活动 inode 表中。</li>
<li>如果 inode 号<strong>已经</strong>在活动表项中则直接执行下一步。</li>
</ol>
</li>
<li>根据参数 mode 核对权限（与创建时的 mode）
<ol>
<li>如果非法，则这次打开失败。</li>
<li>当“打开”合法时，为文件分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>，并为后者赋初值。通过指针建立这些表项与活动 inode 间的联系。把文件描述字，即用户打开文件表中相应文件表项的序号返回给调用者。</li>
</ol>
</li>
</ol>
</li>
<li>输入是含路径的文件名 $\rightarrow$ 依据层次式目录结构解释与检索 $\rightarrow$ 匹配文件名并读取目录项 $\rightarrow$ 提取 inode 号 $\rightarrow$ 按号定位，在 inode 区读取 inode 数据结构（主存活动 inode）</li>
<li>系统实现上必须有 inode 号，但是对文件名而言是透明的。</li>
</ol>
<h4 id="文件的关闭">文件的关闭</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fd;<br><span class="hljs-built_in">close</span>(fd);<br></code></pre></td></tr></table></figure>
<ol>
<li>关闭文件时需要释放掉 inode 来保证空间。</li>
<li>关闭过程
<ol>
<li>根据 fd 找到用户打开文件表项，再找到系统打开文件表项。释放<strong>用户打开文件表项</strong>。</li>
<li>把对应<strong>系统打开文件表项</strong>中的 f_count 减 1，如果非 0，说明还有进程共享这一表项，不用释放直接返回；否则释放表项。</li>
<li>把活动索引节点中的 i_count 减 1，若不为 0，表明还有用户进程正在使用该文件，不用释放而直接返回，否则在把该活动索引节点中的内容复制回文件卷上的相应索引节点中后，<strong>释放</strong>该活动索引节点。</li>
</ol>
</li>
<li>f_count 和 i_count 分别反映进程动态地共享一个文件的两种方式
<ol>
<li>f_count 反映<strong>不同进程</strong>通过<strong>同一个</strong>系统打开文件表项共享一个文件的情况；</li>
<li>i_count 反映<strong>不同进程</strong>通过<strong>不同</strong>系统打开文件表项共享一个文件的情况。</li>
</ol>
</li>
<li>通过两种方式，进程之间既可用相同的位移指针 f_offset，也可用不同位移指针 f_offset 共享同一个文件。</li>
</ol>
<h4 id="读文件">读文件</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> nr;     <span class="hljs-comment">// 系统调用后实际读入的字节数</span><br><span class="hljs-type">int</span> fd;     <span class="hljs-comment">// 文件描述符</span><br><span class="hljs-type">int</span> count;  <span class="hljs-comment">// 要求传送的字符</span><br><span class="hljs-type">char</span> buf[]; <span class="hljs-comment">// 应该输入的用户数据区的首地址</span><br>nr = <span class="hljs-built_in">read</span>(fd, buf, count);<br></code></pre></td></tr></table></figure>
<ol>
<li>读指将文件的内容读入用户数据区，读入数据的逻辑地址由 offset 决定</li>
<li>读文件过程
<ol>
<li>系统根据 f_flag 中的信息，检查读操作合法性</li>
<li>如果合法，再根据当前位移量 f_offset 值，要求读出的字节数，及活动索引节点中 i_addr 指出的文件物理块存放地址，把相应的物理块读到缓冲区中，然后再送到 buf 指向的用户主存区中。</li>
</ol>
</li>
</ol>
<img src="/41267/22.png" style="zoom:33%;">
<h4 id="写文件">写文件</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> nw;     <span class="hljs-comment">// 系统调用后实际写入的字节数</span><br><span class="hljs-type">int</span> fd;     <span class="hljs-comment">// 文件描述符</span><br><span class="hljs-type">int</span> count;  <span class="hljs-comment">// 要求传送的字符</span><br><span class="hljs-type">char</span> buf[]; <span class="hljs-comment">// 数据传送的源地址</span><br>nw = <span class="hljs-built_in">write</span>(fd, buf, count);<br></code></pre></td></tr></table></figure>
<p>写是将用户数据区的数据写入文件中，写入数据的逻辑地址由 offset 决定</p>
<h4 id="文件的随机存取">文件的随机存取</h4>
<ol>
<li>在文件初次“打开”时，文件的位移量 f_offset 清空为 0，以后的文件读写操作总是根据 offset 的当前值，顺序地读写文件。为了支持文件的随机访问，提供系统调用 lseek，它允许用户在<strong>读、写文件</strong>前，事先改变 f_offset 的指向系统调用的形式为：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> offset;      <span class="hljs-comment">// 当前的 offset</span><br><span class="hljs-type">int</span> whence;       <span class="hljs-comment">//</span><br><span class="hljs-type">int</span> fd;           <span class="hljs-comment">// 指向一个以读或写方式打开的文档</span><br><span class="hljs-built_in">lseek</span>(fd, offset, whence);<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>文件描述字 fd 必须指向一个用读或写方式打开的文件
<ol>
<li>当 whence 是 0 时，则 f_offset 被置为 offset，</li>
<li>当 whence 是 1 时，则 f_offset 被置为文件当前位置加上 offset。</li>
</ol>
</li>
</ol>
<h2 id="文件的安全与保护">文件的安全与保护</h2>
<p>文件是计算机系统的重要资源，因此，要求文件系统具有<strong>保障文件安全</strong>的手段，提供文件保密的措施，有效地实现文件的共享。</p>
<ol>
<li><strong>文件共享</strong>是指不同用户共同使用某些文件；</li>
<li><strong>文件保护</strong>是指防止文件被破坏；</li>
<li><strong>文件保密</strong>则是指防止文件及其内容被其他用户窃取。</li>
</ol>
<h3 id="文件共享">文件共享</h3>
<p>文件共享是计算机用户完成<strong>共同任务</strong>所必需的</p>
<p>文件共享带来许多好处，如：</p>
<ol>
<li>减少用户大量重复性劳动；</li>
<li>免除系统复制文件的工作；</li>
<li>节省文件占用的存储空间；</li>
<li>减少程序设计输入输出文件的次数。</li>
</ol>
<h3 id="文件共享的并发控制">文件共享的并发控制</h3>
<p>在允许文件共享的系统中，操作系统应提供手段实现对<strong>共享文件的同步控制</strong>。</p>
<p>多个进程可能<strong>同时</strong>存取一个文件，如果它们同时进行读操作，操作系统应对文件进行公用控制。</p>
<p>如果有进程进行<strong>写操作</strong>，例如，有两个进程，进程 A 要求修改文件，同时进程 B 要求读出同一文件中的数据，则操作系统必须提供<strong>同步控制</strong>机制，以保证文件数据的完整性。</p>
<h3 id="文件的保密措施">文件的保密措施</h3>
<p>文件保密是指<strong>文件及其内容不能被未经文件主授权的其他用户</strong>窃取。</p>
<p>文件的保密措施有以下几种：</p>
<ol>
<li>隐蔽文件目录</li>
<li>设置口令</li>
<li>使用密码：避免高级技能用户直接访问磁盘数据</li>
</ol>
<h2 id="文件的保护">文件的保护</h2>
<p><strong>文件保护</strong>是指防止文件被破坏。</p>
<p>操作系统必须提供文件保护机制，有效实现文件的完整性。</p>
<p>常用的文件保护办法：</p>
<ol>
<li>文件副本</li>
<li>文件存取矩阵与文件存取表</li>
<li>文件属性</li>
</ol>
<h3 id="文件的副本">文件的副本</h3>
<p>文件系统必须要有防止硬软件故障，保存信息完整性的能力。</p>
<p>文件副本是主要实现机制：</p>
<ol>
<li>动态多副本技术</li>
<li>转储、备份与恢复</li>
</ol>
<h3 id="动态多副本">动态多副本</h3>
<p>第一种办法是在<strong>多个介质上维持同一内容的文件</strong>，并且在更新内容时<strong>同时</strong>进行；</p>
<p>这种方法需要增加设备费用和系统负载一般适用于容量较小且较为重要的文件，例如不需更新的系统文件及专用文件，当文件发生故障时只要切换到备用设备就可。</p>
<h3 id="文件转储">文件转储</h3>
<p>文件转储：定时把文件<strong>复制转储到其它介</strong>质上，当某介质上出现故障时，复原转储文件。</p>
<p>转储又可分成两种方式：</p>
<ol>
<li>一是在一定时间间隔或一个单位处理结束时，系统<strong>自动</strong>复写更新过的文件和数据；</li>
<li>二是<strong>每天或每周</strong>把文件信息全部复写一遍，需要时再通过装入转储文件来恢复系统，诸如 BACKUP、RESTORE 等命令。</li>
</ol>
<h3 id="文件的存取控制矩阵">文件的存取控制矩阵</h3>
<ol>
<li>系统为每个用户设置访问每个文件对象的存取属性</li>
<li>系统的全部用户对全部文件的存取属性就组成的一个二维矩阵，称为存取控制矩阵</li>
</ol>
<p>$$
\begin{bmatrix}
a_{11} &amp; a_{12} &amp; ... &amp; a_{1n} \
a_{21} &amp; a_{22} &amp; ... &amp; a_{2n} \
. &amp; . &amp; ... &amp; . \
a_{n1} &amp; a_{n2} &amp; ... &amp; a_{nn} \
\end{bmatrix}
$$</p>
<h3 id="存取控制表">存取控制表</h3>
<ol>
<li>由于操作系统拥有很多用户和众多文件，存取控制矩阵是一个<strong>稀疏矩阵</strong>，可以将其简化为一张<strong>存取控制表</strong></li>
<li>每行包括：<strong>用户、文件、存取属性</strong></li>
<li>存取控制表仅登记那些对文件拥有存取属性的部分</li>
</ol>
<h3 id="基于存取控制矩阵-表的文件保护">基于存取控制矩阵/表的文件保护</h3>
<ol>
<li>存取属性：可以有访问、读、写、执行、创建、删除、授权等等</li>
<li>系统通过查阅（矩阵/表）核对用户对文件的存取权限</li>
<li>文件属主使用 GRANT、REVOKE 等命令进行授权，甚至把授权权转授给他信任的用户</li>
<li>系统管理用户（超级用户）等同于文件属主权限，并获得对系统文件的授访问权权限</li>
</ol>
<h3 id="文件属性">文件属性</h3>
<p>文件属性是指操作系统为文件配置的控制和管理信息，目的是为了方便和用户对文件的管理、保护和使用。</p>
<h4 id="文件属性的内容">文件属性的内容</h4>
<ol>
<li>文件基本属性：文件名和扩展名、文件属主 ID，文件所属组 ID 等</li>
<li>文件类型属性：普通文件等</li>
<li>文件保护属性：规定谁可以访问，以何种方式访问，常见的文件访问方式有读、写、执行、更新、删除等，有的系统还为文件设置口令保护。</li>
<li>文件管理属性：如创建时间、最后访问时间、最后修改时间等。</li>
<li>文件控制属性：
<ol>
<li>文件逻辑结构信息，如记录键、记录类型、记录个数、记录长度、成组因子数等。</li>
<li>文件物理结构信息，如文件所在设备名、物理设备类型、记录存放的盘块号或文件信息首块盘块号。</li>
</ol>
</li>
<li>存取控制表的一种简化方法是用户分类，再针对<strong>每类</strong>用户规定文件属性。</li>
</ol>
<h4 id="文件属性的例">文件属性的例</h4>
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
<th>执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件主</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>伙伴</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>其他用户</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol>
<li>chmod 命令可以改变文件属性</li>
<li>chown 命令用于变更文件属主</li>
<li>chgrp 命令用于变更用户伙伴</li>
</ol>
<h2 id="文件存取方法">文件存取方法</h2>
<ol>
<li>文件存取方法是操作系统为用户程序提供的使用文件的技术和手段（读写文件存储器上的物理记录的方法）</li>
<li>文件存取方法在某种程度上依赖于<strong>文件的物理结构</strong></li>
<li>文件系统应该尽可能提供多种存储方法，比如索引文件可以模拟顺序存取、一定程度上的直接存取</li>
</ol>
<h3 id="顺序存取">顺序存取</h3>
<ol>
<li>按<strong>记录顺序</strong>进行读/写操作的存取方法称<strong>顺序存取</strong></li>
<li>过程：
<ol>
<li>读操作根据<strong>读指针</strong>读出当前记录，同时推进读指针，指向下一次要读出的记录</li>
<li>写操作则设置<strong>写指针</strong>，把一个记录写到文件未端， 同时推进写指针</li>
</ol>
</li>
<li>允许对读指针进行前跳或后退 n（整数）个记录的操作（允许对固定长度记录的顺序文件采用随机访问）</li>
<li>顺序访问主要用于磁带文件，也适用于磁盘上的顺序文件。</li>
</ol>
<h3 id="直接存取（随机存取）">直接存取（随机存取）</h3>
<ol>
<li>可以非顺序地从文件中的任何位置存取文件内容。</li>
<li>很多应用场合要求快速地以<strong>任意次序</strong>直接<strong>读写</strong>某个记录，例如，航空订票系统，用航班号作标识，把特定航班的所有信息存放在物理块中，用户预订某航班时，直接计算出该航班的存位置</li>
<li>常用于磁盘文件。</li>
</ol>
<h3 id="索引存取">索引存取</h3>
<ol>
<li>基于<strong>索引文件</strong>的索引存取方法</li>
<li>文件的记录不按位置而是按其记录名和记录键来编址，所以用户提供记录名或记录键之后，先按名查找，在查找需要的记录。
<ol>
<li>采用记录键时，往往按照一种次序如字母序进行顺序存放</li>
<li>除可采用按键存取外，也可以采用顺序存取或直接存取的方法</li>
</ol>
</li>
<li>实际的系统中，大都采用多级索引，以<strong>加速记录</strong>查找过程</li>
</ol>
<h2 id="文件的使用-2">文件的使用</h2>
<ul>
<li>用户通过两类接口与文件系统联系</li>
<li>第一类是与文件有关的操作命令，例如，UNIX 中的 cat，cd，cp，find，mv，rm，mkdir，rmdir 等等</li>
<li>第二类是提供给用户程序使用的文件类系统调用，基本文件类系统调用有：建立、打开、读/写、定位、关闭、撤销</li>
</ul>
<h3 id="建立文件">建立文件</h3>
<p>“建立文件”用于创建一个文件。</p>
<p>所需参数：文件名、设备类（号）、文件属性及存取控制信息。</p>
<p>处理流程：在相应设备上建立一个文件目录项，为文件分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，并返回一个文件句柄。</p>
<h3 id="撤销文件">撤销文件</h3>
<p>“撤销文件”用于删除一个文件。</p>
<p>所需参数：文件名和设备类（号）。</p>
<p>处理流程：若文件没有关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删去相应目录项；释放文件占用的文件存储空间。</p>
<h3 id="打开文件">打开文件</h3>
<p>“打开文件”用于建立起文件和用户进程之间的使用联系。</p>
<p>所需参数：文件名、设备类（号）、打开方式。</p>
<p>处理流程：在主存活动文件表中申请一个项，返回一个文件句柄；跟据文件名查找目录文件，把目录信息复制到活动文件表相应栏；按存取控制说明检查访问的合法性；若打开的是共享文件，则应有相应处理。</p>
<h3 id="关闭文件">关闭文件</h3>
<p>“关闭文件”用于结束一个文件的读写。</p>
<p>所需参数：文件句柄。</p>
<p>处理流程：将活动文件表中该文件的“当前使用用户数”减 1；若此值为 0，则收回此活动文件表；完成“推迟写”；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，以使文件目录保持最新状态。</p>
<h3 id="读-写文件">读/写文件</h3>
<p>“读/写文件”用于读写文件。</p>
<p>所需参数：文件句柄、用户数据区地址、读写的记录或字节个数。</p>
<p>处理流程：按文件句柄从活动文件表中找到该文件的目录项信息；根据目录项指出的该文件的逻辑和物理组织方式，把相关逻辑记录转换成物理块。</p>
<h3 id="定位文件">定位文件</h3>
<p>“定位文件”用于调整所打开文件的读写指针位置。</p>
<p>所需参数：文件句柄，定位指针。</p>
<h2 id="文件共享-2">文件共享</h2>
<ol>
<li>文件共享指不同进程共同使用同一个文件，文件共享为不同进程完成共同任务所需。</li>
<li>节省大量外存空间，减少因文件复制而增加的 I/O 操作次数。</li>
</ol>
<h3 id="静态共享">静态共享</h3>
<ol>
<li>允许一个文件同时属于多个目录，但是实际上文件仅有一处物理存储。</li>
<li>文件链接：从多个目录可到达文件的链接。</li>
<li>无论进程是否运行，文件链接关系都存在，所以称为静态共享。</li>
<li>链接的文件的存在形式：
<ol>
<li>同一父目录下的不同文件名出现</li>
<li>不同父目录下的相同或不同文件名出现</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* oldnamep;<span class="hljs-comment">// 指向已存在文件名的字符串的指针</span><br><span class="hljs-type">char</span>* newnamep;<span class="hljs-comment">// 指向文件别名的字符串的指针</span><br><span class="hljs-built_in">link</span>(oldnamep, newnamep);<br></code></pre></td></tr></table></figure>
<ol>
<li>执行步骤
<ol>
<li>检索目录找到 oldnamep 所指向文件的索引节点 inode 编号。</li>
<li>再次检索目录找到 newnamep 所指文件的父目录文件，并把已存在文</li>
<li>的索引节点 inode 编号与别名构成一个<strong>目录项</strong>，记入到该目录中去。</li>
<li>把已存在文件索引节点 inode 的连接计数 i_nlink 加 1。</li>
</ol>
</li>
<li>链接实际上是共享已存在文件的索引节点 inode，完成链接的系统调用
<ol>
<li>link(&quot;/home/fei1/myfile.c&quot;,&quot;/home/fei2/myfile.c&quot;)</li>
<li>link(&quot;/home/fei1/myfile.c&quot;,&quot;/home/fei3/fei4/testfile.c&quot;)；</li>
</ol>
</li>
<li>执行后，三个路径名指的是同一个文件：
<ol>
<li>/home/fei1/myfile.c</li>
<li>/home/fei2/myfile.c</li>
<li>/home/fei3/fei4/testfile.c</li>
</ol>
</li>
<li>文件解除链接调用形式为：<code>unlink(namep)</code>，解除链接与文件删除执行的是<strong>同一系统调用代码</strong>。
<ol>
<li>删除文件是从文件主角度讲的</li>
<li>解除文件连接是从共享文件的其他用户角度讲的</li>
</ol>
</li>
<li>都要删去目录项，把 i_nlink 减 1，不过，只有当 i_nlink 减为 0 时，才真正删除文件。</li>
</ol>
<h3 id="动态共享">动态共享</h3>
<ol>
<li>文件动态共享是系统中<strong>不同的用户进程或同一用户的不同进程</strong>并发访问同一文件。</li>
<li>这种共享关系只有当<strong>用户进程存在</strong>时才可能出现，一旦用户的进程消亡，其共享关系也就自动消失。</li>
<li>文件的每次读写由一个读/写位移指针指出要读写的位置。现在的问题是：应让多个进程共用同一个<strong>读/写位移</strong>，还是各个进程具有各自的读写位移呢？</li>
</ol>
<h4 id="使用同一位移指针的文件共享">使用同一位移指针的文件共享</h4>
<ol>
<li>同一用户父、子进程协同完成任务，使用同一读/写位移，同步地对文件进行操作。</li>
<li>该位移指针宜放在相应文件的活动 inode 中。当用系统调用 fork()立子进程时，父进程的 PCB 结构被复制到子进程的 PCB 结构中，使两个进程的打开文件表指向同一活动的索引节点，达到共享同一位移指针的目的。</li>
</ol>
<img src="/41267/23.png" style="zoom: 50%;">
<ol start="3">
<li>注意 f_count = 2 表示共享</li>
</ol>
<h4 id="使用不同位移指针的文件共享">使用不同位移指针的文件共享</h4>
<ol>
<li>多用户进程共享文件，每个希望独立地读、写文件，这时不能只设置一个读写位移指针，须为每个用户进程分别设置一个<strong>读、写位移指针</strong>。</li>
<li>位移指针应放在每个进程<strong>用户打开文件表</strong>的表目中。</li>
<li>这样，当一个进程读、写文件，并修改位移指针时，另一个进程的位移指针不会随之改变，从而，使两个进程能独立地访问同一文件，会新建系统打开文件表（包含 f_offset）</li>
</ol>
<img src="/41267/24.png" style="zoom: 50%;">
<h4 id="两种方式存在的问题">两种方式存在的问题</h4>
<ol>
<li>问题：读写位移指针的位置设置和数目是不同的。</li>
<li>解决：系统建立系统打开文件表，包含读写位移指针 f_offset、文件访问计数 f_count、读写标志 f_flags、指向活动索引节点的指针 f_inode</li>
</ol>
<h4 id="两种方式的实现">两种方式的实现</h4>
<ol>
<li>使用同一位移指针的文件共享：先打开文件，再 fork()</li>
<li>使用不同位移指针的文件共享：先 fork()，再打开文件</li>
</ol>
<h3 id="符号链接共享">符号链接共享</h3>
<ol>
<li>操作系统可支持多个物理磁盘或多个逻辑磁盘（分区），那么，文件系统是建立一棵目录树还是多棵目录树呢?
<ol>
<li>将<strong>盘符或卷标</strong>分配给磁盘或分区，并将其名字作为文件路径名的一部分，比如 Windows</li>
<li><strong>每个分区有自己的文件目录树</strong>，当有多个文件系统时，可通过安装的办法整合成一棵更大的文件目录树，如 UNIX/Linux</li>
</ol>
</li>
<li>问题：系统中每个文件对应一个 inode，编号是<strong>唯一</strong>的，但<strong>两个不同的磁盘或分区</strong>都含有<strong>相同 inode</strong>号对应的文件，也就是说，整合的目录树中，inode 号并不唯一地标识一个文件，</li>
<li>办法：拒绝创建跨越文件系统的硬链接。</li>
</ol>
<h4 id="硬链接">硬链接</h4>
<p>将文件名和自身 inode 链接起来，只能用于单文件系统，可以文件共享，但是不能目录共享。</p>
<h4 id="软连接（符号链接）">软连接（符号链接）</h4>
<ol>
<li>符号链接又称软链接，是一种只有文件名，不指向 inode 的文件，通过名称引用文件。</li>
<li>符号链接共享文件的实现思想：用户 A 目录中形式为 afile $\rightarrow$bfile，实现 A 的目录与 B 的文件的链接。其中只包含被链接文件 bfile 的路径名而不是它的 inode 号，而<strong>文件的拥有者才具有指向 inode 的指针</strong>。</li>
<li>当用户 A 要访问被符号链接的用户 B 的文件 bfile，且要读“符号链接”类文件时，被操作系统截获，它将依据符号链接中的路径名去读文件，于是就能实现用户 A 使用文件名 afile 对用户 B 的文件 bfile 的共享。
<ol>
<li>优点：能用于链接计算机系统中<strong>不同文件系统</strong>中的文件，可链接计算机网络中不同机器上的文件，此时，仅需提供文件所在机器地址和该机器中文件的路径名。</li>
<li>缺点：<strong>搜索文件路径开销大，需要额外的空间查找存储路径</strong>。</li>
</ol>
</li>
</ol>
<h2 id="辅存空间管理">辅存空间管理</h2>
<p>磁盘等大容量辅存空间被 OS 及许多用户共享，用户进程运行期间常常要建立和删除文件，OS 应能自动管理和控制辅存空间。</p>
<p>随着用户文件不断建立和撤销，文件存储空间会出现许多“碎片”。</p>
<p>OS 解决“碎片”的办法是整理“碎片”；在整理过程中，往往对文件重新组织，让其存放在连续存储区中。</p>
<h3 id="辅存空间的分配方式">辅存空间的分配方式</h3>
<p>连续分配：文件存放在<strong>辅存空间连续存储区</strong>中。在建立文件时，用户必须给出文件大小，然后，查找到能满足的连续存储区供使用。优点是顺序访问时速度快，管理较为简单，但为了获得足够大的连续存储区，需定时进行“碎片”整理</p>
<p>非连续分配：</p>
<ol>
<li>一种方法是以**块（扇区）**为单位，扇区不一定要连续，同一文件的扇区按文件记录的逻辑次序用链指针连接或位示图指示；</li>
<li>另一种方法是以<strong>簇</strong>为单位，簇是由<strong>若干个连续扇区</strong>组成的分配单位；实质上是连续分配和非连续分配的结合。各个簇可以用链指针、索引表，位示图来管理。</li>
<li>优点是辅存空间管理效率高，便于文件动态增长和收缩。</li>
</ol>
<h3 id="空闲块的管理：位示图">空闲块的管理：位示图</h3>
<p>磁盘空间通常使用<strong>固定大小</strong>的块，<strong>可方便地用位示图管理，用若干字节构成一张位示图</strong>，其中每一字位对应一个物理块，字位的次序与块的相对次序一致，字位为‘1’表示相应块已占用，字位为‘0’表示该块空闲。</p>
<p>微型机操作系统 VM/SP、Windows 和 Macintosh 等操作系统均使用这种技术管理文件存储空间。</p>
<p>主要优点是：</p>
<ol>
<li>每个盘块仅需 1 个附加位，如盘块长 1KB，位示图开销仅占 0.012%</li>
<li>可把位示图全部或大部分保存在主存，再配合现代机器都具有的位操作指令，实现高速物理块分配和去配。</li>
</ol>
<h3 id="空闲块的管理：空闲区表">空闲块的管理：空闲区表 *</h3>
<ol>
<li>该方法常用于<strong>连续文件</strong>，将空闲存储块的位置及其连续空闲的块数构成一张表。</li>
<li>分配时，系统<strong>依次扫描</strong>空闲区表，寻找<strong>合适的空闲块</strong>并修改登记项；</li>
<li>删除文件释放空闲区时，把空闲区位置及连续的空闲区长度<strong>填入空闲区表</strong>，出现邻接的空闲区时，还需执行<strong>合并操作</strong>并修改登记项。</li>
<li>空闲区表的搜索算法有<strong>首次适应、邻近适应、最佳适应和最坏适应算法</strong>等。</li>
</ol>
<h3 id="空闲块的管理：空闲块成组连接法">空闲块的管理：空闲块成组连接法 *</h3>
<ol>
<li>把所有空闲块连接在一起，系统保持<strong>指针指向第一个空闲块</strong>，每一空闲块中包含指向<strong>下一空闲块的指针</strong>。</li>
<li>申请一块时，从链头取一块并修改系统指针；</li>
<li>删除时释放占用块，使其成为空闲块并将它挂到空闲链上。</li>
<li>这种方法<strong>效率低</strong>，每申请一块都要读出空闲块并取得指针，申请多块时要<strong>多次读盘</strong>，但便于文件<strong>动态增长和收缩</strong>。</li>
</ol>
<h3 id="空闲块的管理：空闲块列表">空闲块的管理：空闲块列表 *</h3>
<p>把所有空闲块物理地址放到一个空闲块列表文件中，由于它非常庞大，不可能全部保存在内存中，有两种有效技术可以把该列表的<strong>一小部分</strong>保存在内存中：</p>
<ol>
<li>列表用一个下推栈实现，栈中靠前数千个元素保留在内存专用区中。当分配一个新空闲块时，从栈顶弹出；当一个物理块被解除分配时，它被压入内存专用区的栈尾中。只有当下推栈中在内存的部分满或者空时，才需要在内存和磁盘之间进行传送。因此，该技术在大多数时候都提供了零时间的访问。</li>
<li>列表用一个 FIFO 队列实现，队列头和队列尾的几千项放在内存专用区中。分配空闲块时从队列头取出首项，取消分配时可以把它添加在内存专用区队列尾。只有当内存中的队列头部空或者内存中的队列尾部满时，才需要在磁盘和内存之间进行传送。</li>
</ol>
<p>如上两个策略，可以用后台线程来完成排序。</p>
<h3 id="空闲块的管理：空闲块成组连接法-2">空闲块的管理：空闲块成组连接法</h3>
<img src="/41267/27.png" style="zoom:50%;">
<ol>
<li>图 6-13 给出 Linux 系统所采用的空闲块成组链接法。磁盘物理块长为 1024B。为了方便讨论，假定文件卷启用时共有可用空闲块 338 块，目前空闲块分成 4 组，39 块空闲块已在内存专用块中，剩余每 100 块划分成一组，每组中第一块（图中盘块号为 50、68 和 188）登记下一组空闲盘块号和空闲块总数。需要注意，在最后一组中，第 1 项是 0，作为结束标志，表明系统空闲盘块链已经结束。</li>
<li>操作系统启动时，将磁盘专用块复制到内存系统工作区中，访问内存专用块就可完成申请或释放空闲盘块的操作。</li>
<li>分配空闲磁盘块时，总是先把专用块中的空闲块计数减 1，以它为指针找到专用块的相应表项，其内容就是要分配的空闲磁盘块号。</li>
<li>当空闲块计数减 1 后等于 0 时，专用块中仅剩 1 个磁盘块号，此时要取出表项中的磁盘块号（设为 i），再把此盘块中所保存的下一组空闲磁盘块链接信息经缓冲区复制到内存专用块中，然后把当前磁盘块分配出去。</li>
<li>释放存储块时，将磁盘块号记录在由专用块所指示的表项中，然后空闲块计数加 1。若发现此表已满（达 100 项），则应把整个表的内容经缓冲区复制到下面要释放的磁盘块中，然后将释放块的块号写入专用块中的第一个位置，置空闲块计数为 1。</li>
<li>搜索到磁盘块中的第 1 项是 0 时，系统应向操作员发出警告，表明空闲块已经用完。</li>
<li>需要注意，开始时空闲块是按序排列的，操作系统经过一段时间运行，文件系统中的空闲块号未必能保持连续，但只要符合分组及组间连接的原则，空闲块可按任意次序排列。事实上，经过若干次分配和释放操作后，空闲块物理块号必定不再按序排列。</li>
</ol>
<img src="/41267/9.png" style="zoom:33%;">
<h2 id="文件系统的实现层次">文件系统的实现层次</h2>
<table>
<thead>
<tr>
<th><img src="/41267/10.png" alt></th>
<th><img src="/41267/25.png" alt></th>
</tr>
</thead>
</table>
<h2 id="补充：内存映射文件">补充：内存映射文件 *</h2>
<ol>
<li>内存映射文件的原理如下：把进程需要访问的文件映射到其虚地址空间中，于是便可通过读写这段虚地址进行文件访问，而磁盘访问转变成内存访问。也就是说，把磁盘中的文件视为进程的虚地址的一部分， 故也称映射文件 I / O 。内存映射文件是按照文件名来访问的，多个进程可同时把同一个文件映射到各自的虚地址空间中，且虚地址不必相同。随着进程的运行，被引用的映射文件由存储管理程序装人内存，多个进程读写虚存的映射文件区就可以共享文件信息。其优点是方便易用，节省空间，便于共享，利于通信。</li>
<li>详见 P326</li>
</ol>
<h2 id="补充：文件系统的性能与可靠性">补充：文件系统的性能与可靠性 *</h2>
<p>详见 P330</p>
<h3 id="文件系统性能问题措施">文件系统性能问题措施</h3>
<ol>
<li>盘块高速缓存：局部性原理；写回优化</li>
<li>数据预先读入：仅适用于顺序访问</li>
<li>信息优化分布：磁盘上的信息优化分布</li>
<li>磁盘驱动调度：不同驱动调度算法</li>
<li>内存映射文件：将内存访问转换为内存访问，将想要访问的文件映射到进程的虚存空间，特别适用于文件共享场景。</li>
</ol>
<h3 id="提高文件可靠性措施">提高文件可靠性措施</h3>
<ol>
<li>磁盘坏块管理：软硬件解决方案</li>
<li>备份数据：完全、增量和更新备份</li>
</ol>
<h3 id="文件系统一致性检查">文件系统一致性检查</h3>
<ol>
<li>磁盘块一致性检查：磁盘块要么占用要么空闲</li>
<li>文件一致性检查：关注 inode，出现无法释放等问题</li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat-award.jpg" alt="EagleBear2002 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="EagleBear2002 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/6323/" rel="prev" title="计算机与操作系统-04-设备管理">
      <i class="fa fa-chevron-left"></i> 计算机与操作系统-04-设备管理
    </a></div>
      <div class="post-nav-item">
    <a href="/46824/" rel="next" title="Lab3-类型检查和重命名">
      Lab3-类型检查和重命名 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">文件的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%91%BD%E5%90%8D"><span class="nav-number">1.1.</span> <span class="nav-text">文件的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">文件的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">引入文件的优点 *</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD"><span class="nav-number">2.</span> <span class="nav-text">文件系统及其功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">文件系统的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">文件系统中的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">2.3.</span> <span class="nav-text">文件系统的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">2.4.</span> <span class="nav-text">文件系统的组成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="nav-number">3.</span> <span class="nav-text">文件组织与存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B7%E5%92%8C%E5%9D%97"><span class="nav-number">3.1.</span> <span class="nav-text">卷和块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AE%89%E6%8E%92"><span class="nav-number">3.2.</span> <span class="nav-text">顺序存取存储设备的信息安排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AE%89%E6%8E%92"><span class="nav-number">3.3.</span> <span class="nav-text">直接存取存储设备的信息安排</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">文件的逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">流式文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">记录式文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%BC%8F%E6%96%87%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.3.</span> <span class="nav-text">记录式文件与数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">记录的成组与分解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3%E7%9A%84%E6%8F%90%E5%87%BA"><span class="nav-number">5.1.</span> <span class="nav-text">成组与分解的提出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.</span> <span class="nav-text">成组与分解操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">5.3.</span> <span class="nav-text">成组与分解的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">记录格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E8%AE%B0%E5%BD%95"><span class="nav-number">5.4.1.</span> <span class="nav-text">定长记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E8%AE%B0%E5%BD%95"><span class="nav-number">5.4.2.</span> <span class="nav-text">变长记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%A8%E5%9D%97%E8%AE%B0%E5%BD%95"><span class="nav-number">5.4.3.</span> <span class="nav-text">跨块记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%94%AE"><span class="nav-number">5.4.4.</span> <span class="nav-text">记录键</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">文件的物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">构造文件物理结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="nav-number">6.2.</span> <span class="nav-text">顺序文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.</span> <span class="nav-text">连接文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="nav-number">6.4.</span> <span class="nav-text">直接文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="nav-number">6.5.</span> <span class="nav-text">索引文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">6.5.1.</span> <span class="nav-text">索引文件的访问方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">6.5.2.</span> <span class="nav-text">索引文件的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%9A%84%E7%BB%84%E7%BB%87%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">6.5.3.</span> <span class="nav-text">索引表的组织（重要）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">文件的目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88File-Control-Block%EF%BC%8CFCB%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">文件控制块（File Control Block，FCB） *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="nav-number">7.2.</span> <span class="nav-text">文件目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%BB%BA%E7%AB%8B%E6%96%B9%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">Linux 系统的文件目录建立方法 *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.4.</span> <span class="nav-text">层次目录结构 *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.5.</span> <span class="nav-text">一级目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.6.</span> <span class="nav-text">二级目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.7.</span> <span class="nav-text">树形目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.7.1.</span> <span class="nav-text">不同类型的树形目录结构 *</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.7.2.</span> <span class="nav-text">不同操作系统的目录结构的实现 *</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">7.7.3.</span> <span class="nav-text">树形目录结构的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="nav-number">7.7.4.</span> <span class="nav-text">树形目录结构中的文件定位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">文件目录的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE"><span class="nav-number">8.1.</span> <span class="nav-text">文件查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E6%9F%A5%E6%89%BE"><span class="nav-number">8.2.</span> <span class="nav-text">目录项查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">8.3.</span> <span class="nav-text">文件目录处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E8%A1%A8"><span class="nav-number">8.4.</span> <span class="nav-text">活动文件表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.</span> <span class="nav-text">文件系统功能及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%87%E5%8C%BA%E5%BA%8F%E5%88%97%E5%88%92%E5%88%86"><span class="nav-number">9.1.</span> <span class="nav-text">扇区序列划分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97%EF%BC%9A0-%E5%8F%B7%E5%9D%97"><span class="nav-number">9.1.1.</span> <span class="nav-text">引导块：0 号块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97%EF%BC%9A1-%E5%8F%B7%E5%9D%97"><span class="nav-number">9.1.2.</span> <span class="nav-text">超级块：1 号块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98-inode%EF%BC%88%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%EF%BC%89%E5%8C%BA%EF%BC%9A2-k-1-%E5%9D%97"><span class="nav-number">9.1.3.</span> <span class="nav-text">磁盘 inode（索引节点）区：2-(k+1) 块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E4%BF%A1%E6%81%AF%EF%BC%88%E6%95%B0%E6%8D%AE%EF%BC%89%E5%8C%BA%EF%BC%9A-k-2-%E5%8F%8A%E4%BB%A5%E5%90%8E"><span class="nav-number">9.1.4.</span> <span class="nav-text">磁盘信息（数据）区：(k+2) 及以后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="nav-number">9.2.</span> <span class="nav-text">文件系统磁盘结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">9.3.</span> <span class="nav-text">文件相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">9.3.1.</span> <span class="nav-text">文件的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="nav-number">9.3.2.</span> <span class="nav-text">创建文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">9.3.3.</span> <span class="nav-text">文件的删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80"><span class="nav-number">9.3.4.</span> <span class="nav-text">文件的打开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">9.3.5.</span> <span class="nav-text">文件的关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">9.3.6.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">9.3.7.</span> <span class="nav-text">写文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96"><span class="nav-number">9.3.8.</span> <span class="nav-text">文件的随机存取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%89%E5%85%A8%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="nav-number">10.</span> <span class="nav-text">文件的安全与保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-number">10.1.</span> <span class="nav-text">文件共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">10.2.</span> <span class="nav-text">文件共享的并发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AF%86%E6%8E%AA%E6%96%BD"><span class="nav-number">10.3.</span> <span class="nav-text">文件的保密措施</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="nav-number">11.</span> <span class="nav-text">文件的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%89%AF%E6%9C%AC"><span class="nav-number">11.1.</span> <span class="nav-text">文件的副本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E5%89%AF%E6%9C%AC"><span class="nav-number">11.2.</span> <span class="nav-text">动态多副本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BD%AC%E5%82%A8"><span class="nav-number">11.3.</span> <span class="nav-text">文件转储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%98%B5"><span class="nav-number">11.4.</span> <span class="nav-text">文件的存取控制矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E8%A1%A8"><span class="nav-number">11.5.</span> <span class="nav-text">存取控制表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%98%B5-%E8%A1%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-number">11.6.</span> <span class="nav-text">基于存取控制矩阵&#x2F;表的文件保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">11.7.</span> <span class="nav-text">文件属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">11.7.1.</span> <span class="nav-text">文件属性的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BE%8B"><span class="nav-number">11.7.2.</span> <span class="nav-text">文件属性的例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-number">12.</span> <span class="nav-text">文件存取方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%8F%96"><span class="nav-number">12.1.</span> <span class="nav-text">顺序存取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%8F%96%EF%BC%88%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%EF%BC%89"><span class="nav-number">12.2.</span> <span class="nav-text">直接存取（随机存取）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%8F%96"><span class="nav-number">12.3.</span> <span class="nav-text">索引存取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8-2"><span class="nav-number">13.</span> <span class="nav-text">文件的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E6%96%87%E4%BB%B6"><span class="nav-number">13.1.</span> <span class="nav-text">建立文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E6%96%87%E4%BB%B6"><span class="nav-number">13.2.</span> <span class="nav-text">撤销文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-number">13.3.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="nav-number">13.4.</span> <span class="nav-text">关闭文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB-%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">13.5.</span> <span class="nav-text">读&#x2F;写文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6"><span class="nav-number">13.6.</span> <span class="nav-text">定位文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB-2"><span class="nav-number">14.</span> <span class="nav-text">文件共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%85%B1%E4%BA%AB"><span class="nav-number">14.1.</span> <span class="nav-text">静态共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB"><span class="nav-number">14.2.</span> <span class="nav-text">动态共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%BD%8D%E7%A7%BB%E6%8C%87%E9%92%88%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-number">14.2.1.</span> <span class="nav-text">使用同一位移指针的文件共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E4%BD%8D%E7%A7%BB%E6%8C%87%E9%92%88%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-number">14.2.2.</span> <span class="nav-text">使用不同位移指针的文件共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">14.2.3.</span> <span class="nav-text">两种方式存在的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.2.4.</span> <span class="nav-text">两种方式的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB"><span class="nav-number">14.3.</span> <span class="nav-text">符号链接共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="nav-number">14.3.1.</span> <span class="nav-text">硬链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5%EF%BC%88%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="nav-number">14.3.2.</span> <span class="nav-text">软连接（符号链接）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">15.</span> <span class="nav-text">辅存空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">15.1.</span> <span class="nav-text">辅存空间的分配方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BD%8D%E7%A4%BA%E5%9B%BE"><span class="nav-number">15.2.</span> <span class="nav-text">空闲块的管理：位示图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E7%A9%BA%E9%97%B2%E5%8C%BA%E8%A1%A8"><span class="nav-number">15.3.</span> <span class="nav-text">空闲块的管理：空闲区表 *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E7%A9%BA%E9%97%B2%E5%9D%97%E6%88%90%E7%BB%84%E8%BF%9E%E6%8E%A5%E6%B3%95"><span class="nav-number">15.4.</span> <span class="nav-text">空闲块的管理：空闲块成组连接法 *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E7%A9%BA%E9%97%B2%E5%9D%97%E5%88%97%E8%A1%A8"><span class="nav-number">15.5.</span> <span class="nav-text">空闲块的管理：空闲块列表 *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86%EF%BC%9A%E7%A9%BA%E9%97%B2%E5%9D%97%E6%88%90%E7%BB%84%E8%BF%9E%E6%8E%A5%E6%B3%95-2"><span class="nav-number">15.6.</span> <span class="nav-text">空闲块的管理：空闲块成组连接法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%B1%82%E6%AC%A1"><span class="nav-number">16.</span> <span class="nav-text">文件系统的实现层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-number">17.</span> <span class="nav-text">补充：内存映射文件 *</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">18.</span> <span class="nav-text">补充：文件系统的性能与可靠性 *</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%AA%E6%96%BD"><span class="nav-number">18.1.</span> <span class="nav-text">文件系统性能问题措施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E6%96%87%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%AA%E6%96%BD"><span class="nav-number">18.2.</span> <span class="nav-text">提高文件可靠性措施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="nav-number">18.3.</span> <span class="nav-text">文件系统一致性检查</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EagleBear2002"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">EagleBear2002</p>
  <div class="site-description" itemprop="description">暮雪朝霜，毋改英雄意气</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">481</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EagleBear2002" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EagleBear2002" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:eaglebear2002@foxmail.com" title="E-Mail → mailto:eaglebear2002@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://czxingchen.github.io/" title="https:&#x2F;&#x2F;czxingchen.github.io&#x2F;" rel="noopener" target="_blank">PL 顶会研究者-XiaoZhi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/the-sword-of-king/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;the-sword-of-king&#x2F;" rel="noopener" target="_blank">模式识别专家-崖山剑</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://en.ydjsir.com.cn/" title="https:&#x2F;&#x2F;en.ydjsir.com.cn&#x2F;" rel="noopener" target="_blank">愿逐月华流照君-YDJSIR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/m0_51691879?spm=1000.2115.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51691879?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank">软院科协掌门人-wbl_z</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://itxia.club/" title="https:&#x2F;&#x2F;itxia.club&#x2F;" rel="noopener" target="_blank">侠之大者为国为民-IT 侠</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://chestnutsilver.github.io/TJIS-My-Helloworld/" title="https:&#x2F;&#x2F;chestnutsilver.github.io&#x2F;TJIS-My-Helloworld&#x2F;" rel="noopener" target="_blank">因果推断爱好者-ChestnutSilver</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://atritium.github.io/" title="https:&#x2F;&#x2F;atritium.github.io&#x2F;" rel="noopener" target="_blank">任天堂技术扛把子-manqi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.sakiyary.cn/" title="https:&#x2F;&#x2F;blog.sakiyary.cn&#x2F;" rel="noopener" target="_blank">教育部教学创新项目负责人-哈气鸭梨</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://huoxj.github.io/" title="https:&#x2F;&#x2F;huoxj.github.io&#x2F;" rel="noopener" target="_blank">离百年博客还有 98 年捞程序 Runz</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.erinwithbmq.xin/" title="https:&#x2F;&#x2F;www.erinwithbmq.xin&#x2F;" rel="noopener" target="_blank">摸鱼小能手 ErinwithBMQ の 尋夢之旅</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tilnel.github.io/" title="https:&#x2F;&#x2F;tilnel.github.io&#x2F;" rel="noopener" target="_blank">南大耐摔王 Tilnel 的杂谈小屋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.azifan.club/" title="https:&#x2F;&#x2F;blog.azifan.club&#x2F;" rel="noopener" target="_blank">水龙之魂</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mzy0624.github.io/" title="https:&#x2F;&#x2F;mzy0624.github.io&#x2F;" rel="noopener" target="_blank">Haibara AI</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EagleBear2002</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">40:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
