<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eaglebear2002.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"always","padding":18,"offset":12,"onmobile":true,"scroll_to_top_on_sidebar_toggle":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="函数  一个函数就是一个功能 函数包括  系统函数（库函数） 用户自己定义的函数  无参函数 有参函数      函数的原则  函数不可以被嵌套定义：函数内部不可以再次定义新的函数 函数可以通过原型完成有默认参数的函数 函数是先定义后使用，具体是指上下文环境 Runtime Environment 在我们 C++中是使用 Stack  函数模板">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 高级程序设计-02-函数">
<meta property="og:url" content="https://eaglebear2002.github.io/47546/index.html">
<meta property="og:site_name" content="EagleBear2002 的博客">
<meta property="og:description" content="函数  一个函数就是一个功能 函数包括  系统函数（库函数） 用户自己定义的函数  无参函数 有参函数      函数的原则  函数不可以被嵌套定义：函数内部不可以再次定义新的函数 函数可以通过原型完成有默认参数的函数 函数是先定义后使用，具体是指上下文环境 Runtime Environment 在我们 C++中是使用 Stack  函数模板">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eaglebear2002.github.io/47546/1.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47546/2.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47546/3.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47546/4.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47546/5.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47546/6.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47546/7.png">
<meta property="article:published_time" content="2022-05-30T10:52:45.000Z">
<meta property="article:modified_time" content="2025-10-02T04:11:35.839Z">
<meta property="article:author" content="EagleBear2002">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eaglebear2002.github.io/47546/1.png">

<link rel="canonical" href="https://eaglebear2002.github.io/47546/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ 高级程序设计-02-函数 | EagleBear2002 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<script>
  hljs.initLineNumbersOnLoad();
</script>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EagleBear2002 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里必须根绝一切犹豫，这里任何怯懦都无济于事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">61</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">481</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eaglebear2002" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eaglebear2002.github.io/47546/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="EagleBear2002">
      <meta itemprop="description" content="暮雪朝霜，毋改英雄意气">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EagleBear2002 的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 高级程序设计-02-函数
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-30 18:52:45" itemprop="dateCreated datePublished" datetime="2022-05-30T18:52:45+08:00">2022-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-02 12:11:35" itemprop="dateModified" datetime="2025-10-02T12:11:35+08:00">2025-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">南京大学软件学院本科课程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/2022Spring-C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">2022Spring-C++ 高级程序设计</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="函数">函数</h2>
<ol>
<li>一个函数就是一个功能</li>
<li>函数包括
<ol>
<li>系统函数（库函数）</li>
<li>用户自己定义的函数
<ol>
<li>无参函数</li>
<li>有参函数</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="函数的原则">函数的原则</h3>
<ol>
<li>函数不可以被嵌套定义：函数内部不可以再次定义新的函数</li>
<li>函数可以通过原型完成有默认参数的函数</li>
<li>函数是先定义后使用，具体是指上下文环境</li>
<li><code>Runtime Environment</code> 在我们 C++中是使用 <code>Stack</code></li>
</ol>
<h2 id="函数模板">函数模板</h2>
<ol>
<li><code>template &lt;typename T&gt;</code></li>
<li><code>T max(T a, T b, T c){}</code></li>
<li>在运行时确定 T 的类型</li>
</ol>
<h2 id="函数编译链接">函数编译链接</h2>
<ol>
<li>编译时只编译当前模块</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">g</span>()&#123;<span class="hljs-comment">//a.cpp</span><br>    <span class="hljs-built_in">f</span>();<span class="hljs-comment">//b.cpp</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>编译每个编译单元（<code>.cpp</code>）是相互独立的，即每个 cpp 文件之间是不知道对方的存在的，<code>.cpp</code> 编译成 <code>.obj</code> 后，link 期时 <code>a.obj</code> 才会从 <code>b.obj</code> 中获得 <code>f()</code> 函数的信息（这就是为什么要预处理）</li>
<li>link 时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的地址符号全换成实地址（call 指令在 a.cpp 被编译时只是 call f 的符号，而不知道 f 确切的地址）</li>
</ol>
<h2 id="重载与重写">重载与重写</h2>
<ol>
<li>overload：语言的多态</li>
<li>override：父子类的，OO 语言独有多态</li>
<li>多态不是程序语言独有的，而是语言拥有的特性。</li>
<li>C++支持重载，C 不支持重载。</li>
</ol>
<h3 id="函数的重载（Overload）">函数的重载（Overload）</h3>
<ol>
<li>原则：
<ol>
<li>名称相同，参数不同（重载函数的参数个数、参数类型、参数顺序至少一个不同）</li>
<li>返回值类型不作为区别重载函数的依据</li>
</ol>
</li>
<li>匹配原则：
<ol>
<li>严格匹配</li>
<li>内部转换</li>
<li>用户定义的转换</li>
</ol>
</li>
<li>以下为几个例子</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;bar(1)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> c)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;bar(2)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;func(1)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;func(2)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> ll)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;func(3)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hum</span><span class="hljs-params">(<span class="hljs-type">int</span> i, ...)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;hum(1)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hum</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;hum(2)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-built_in">bar</span>(c);<br>	<span class="hljs-type">short</span> s=<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">func</span>(s);<br>	<span class="hljs-built_in">hum</span>(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>);<br>	<span class="hljs-built_in">hum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br><span class="hljs-comment">//bar(2)</span><br><span class="hljs-comment">//func(1)</span><br><span class="hljs-comment">//hum(2)</span><br><span class="hljs-comment">//hum(1)</span><br><br><span class="hljs-comment">//下面这种是不被允许的，ambiguous</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
<h3 id="函数的默认参数（是对函数重载的补充）">函数的默认参数（是对函数重载的补充）</h3>
<ol>
<li>默认参数的声明：默认参数是严格从右至左的顺序使用的
<ol>
<li>在函数原型中给出</li>
<li>先定义的函数中给出</li>
</ol>
</li>
<li>默认参数的顺序：
<ol>
<li>右-&gt;左</li>
<li>不间断</li>
</ol>
</li>
<li>默认参数与函数重载要注意
<ul>
<li><code>void f(int); void f(int, int=2);</code></li>
</ul>
</li>
<li>在定义中一般不给出默认参数（给出了也不会 CE），在调用的时候使用函数原型的时候给出默认参数。</li>
<li>函数默认重载，在面向对象编程中，子类即便修改默认参数，也不生效（即，以父类为准）。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//a.cpp 中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;&#125;<br><span class="hljs-comment">//b.cpp 中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span> = <span class="hljs-number">2</span>,<span class="hljs-type">int</span> = <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//使用函数原型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//==f(1,2,3)</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//==f(1,3,3)</span><br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">//==f(1,5,5)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="外部函数-extern">外部函数 extern</h2>
<ol>
<li>符号表：Name mangling: extern &quot;C&quot;
<ul>
<li>在 C++的 g 中调用 C 中的 f，会在 link 的时候出问题（因为不在 C++ 的符号表中）</li>
<li>解决方案:在函数名前面加上 extern 的关键词（这样子编译器就会在编译过程中从外部进行寻找）</li>
</ul>
</li>
<li>C 编译器编译的文件被放置在 lib 库中，C++不能直接调用，而是需要 extern 才可以</li>
<li>原因:符号表机制</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="符号表机制">符号表机制</h3>
<ol>
<li>符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表<code>&lt;name,address&gt;</code>，对应的符号后面的地址还没确定（link 期决定），call name 根据 name 找到符号表对应的地址，再执行</li>
<li>对于 c 语言来说，编译得到的符号表内函数 f 在符号表里的 name 就是 f（不存在函数重载）</li>
<li>对于 c++来说，因为有重载，所以 f(int) f(float) 符号表里的 name 是不同的</li>
<li>c++对于 c 语言的函数 f 会按 c++的方式生成函数表中的 nameA，但 c 编译好的函数表内 f 对应的 nameB 和 nameA 不一致，导致 c++无法找到该函数</li>
</ol>
<h2 id="函数与内存">函数与内存</h2>
<ol>
<li>在内存中的 code，是不可以断章取义的。</li>
<li>需要按照类型来进行</li>
<li>函数是使用临时性存储空间，</li>
</ol>
<h3 id="存储空间与内存">存储空间与内存</h3>
<ol>
<li>从上往下分别是
<ul>
<li>code：每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的</li>
<li>data：存放数据（全局变量、静态局部变量）</li>
<li>Stack：由系统管理，存放函数</li>
<li>Heap：可以用程序员进行分配，可以在运行时动态确定，<code>int p = (int )malloc(4)</code>，归还内存 <code>free</code>（在 C++中不推荐使用这种方法进行处理，而是使用 new 和 delete）</li>
</ul>
</li>
<li>compiler 组织成符号表。CPP 是一个文件一个文件进行编译的。
<ul>
<li>在编译 A 文件的时候，是不知道 B 文件存在的，也就是说每一个文件都是单独编译的。</li>
<li>借助符号表来获取存储地址，问题? 函数名相同，重载（多态）的问题,解决:不仅仅按照函数名，还要按照函数参数来划分。</li>
<li>所以函数表，不仅仅存储函数名，还存储函数的参数返回值类型。</li>
</ul>
</li>
<li>问题:可以在不降低可读性的前提下，降低 COST 吗?</li>
<li>运行逻辑是由 Runtime Environment 是有差异的：注意合作方的运行环境（使用 Lib 的注意）</li>
</ol>
<h3 id="RunTime-Environment">RunTime Environment</h3>
<ol>
<li>每一个函数都有栈空间，被称为 frame（active frame 是当前运行函数的栈空间）</li>
<li>以下类似是一种契约，这种约定被 compiler 和 linker 共同管理</li>
</ol>
<h4 id="cdecl">_cdecl</h4>
<p>函数空间（参数）归调用者管理，本章讲解的是这种，调用者清空栈。</p>
<p>问题：函数调用结束后，原空间的参数仍然在（未归还）</p>
<p>好处：由调用者管理所有的调用参数，可以灵活管理参数</p>
<ul>
<li>例子：<code>printf()</code> 函数是可变参数，根据字符串形式决定（由调用者控制）：<code>int printf(const char  format,...)</code>。这种情况只能由调用者归还。</li>
</ul>
<p>坏处：安全问题，调用者环境被破坏。</p>
<ul>
<li>无法控制传递参数的个数，写了 8 个 <code>%d</code>，但是只传递了 1 个，则会导致调用者环境被破坏。</li>
<li>同样的问题，就算环境不被破坏，也会导致软件内部不应该被看到的数据被拿出来</li>
</ul>
<h4 id="stdcal">_stdcal</h4>
<p>函数调用后，函数空间由被调用者管理，被调用者清空栈。调用者来传递参数（申请空间），由被调用者归还参数（归还空间），这部分空间被称为中间地带。</p>
<p>好处：空间节省，跨平台性：比如 C++ 调用 C 的时候（C 不允许重载）</p>
<p>坏处：对于可变参数的函数无法计算 <code>%ebp</code> 的参数个数，但是对于调用者是知道的，这样只能使用_cdecl</p>
<h4 id="fastcall">_fastcall</h4>
<p>第 1 个参数放入 <code>%ecx</code>，第 2 个参数放入 <code>%edx</code>，其余参数放入栈中。</p>
<h2 id="函数执行机制">函数执行机制</h2>
<h3 id="建立被调用函数的栈空间">建立被调用函数的栈空间</h3>
<p><img src="/47546/1.png" alt></p>
<ul>
<li>栈空间是从高地址向低地址生长</li>
<li>栈底：ebp（当前函数的存取指针，即存储或者读取数时的指针基地址）</li>
<li>栈顶：esp（当前函数的栈顶指针）</li>
<li>保存：返回地址、调用者的基指针</li>
<li>过程描述：调用一个函数时，先将堆栈原先的基址（ebp）栈，以保存之前任务的信息。然后将栈顶指针的值赋给 ebp，将之前的栈顶作为新的基址（栈底），然后在这个基址上开辟相应的空间用作被调用函数的堆栈。函数返回后，从 ebp 中可取出之前的 esp 值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的 EBP 值，因为这个值在函数调用前一步被压入堆栈。这样，EBP 和 ESP 就都恢复了调用前的位置，堆栈恢复函数调用前的状态。</li>
</ul>
<p><img src="/47546/2.png" alt></p>
<h3 id="参数传递">参数传递</h3>
<h4 id="值传递">值传递</h4>
<p><img src="/47546/3.png" alt></p>
<p><img src="/47546/4.png" alt></p>
<ol>
<li>最上面是 main 函数，左侧，下面是 Function.</li>
<li>为什么 ebp 和 esp 之间距离很大，因为我们要对齐，提高内存管理效率。</li>
<li>数据类型决定存放数据的空间的大小</li>
<li>函数调用过程:
<ol>
<li>开始调用 esp 从栈顶向下移动 32 位，存 ret_addr，开辟 main 函数的栈空间</li>
<li>然后 esp 继续向下存 ebp_main</li>
<li>然后 ebp 到 esp 处</li>
<li>然后 esp 到新的函数空间的栈顶</li>
<li>函数处理</li>
<li>esp 先返回到 ebp</li>
<li>然后 ebp 根据 ebp_main 返回，然后 esp 加一（向上）</li>
<li>之后 esp 回到 ret_addr 位置即可。</li>
<li>动画过程看 PPT 50 页</li>
</ol>
</li>
<li>eip 存放了 ret_addr</li>
</ol>
<h4 id="引用传递：函数副作用">引用传递：函数副作用</h4>
<ol>
<li>传递的是地址，会同时修改对应地址单元中的值。</li>
</ol>
<p><img src="/47546/5.png" alt></p>
<p><img src="/47546/6.png" alt></p>
<h4 id="call-by-name">call by name</h4>
<ol>
<li>call by name 是指在用到该参数的时候才会计算参数表达式的值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    ++i;<br>    ++x;<br>&#125;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">p</span>(a[i]);<br><span class="hljs-comment">//值传递:对于 i 的修改会影响全局，但是不影响 a[i]</span><br><span class="hljs-comment">//引用传递:同时影响 i 和 a[i]</span><br><span class="hljs-comment">//call by name:将 p 函数中的 x 进行替换。(Delayed Evaluation)，也就是 a[2] = 3;x -&gt; a[i]</span><br><span class="hljs-comment">//call by name:主要是对于没有函数副作用的时候</span><br></code></pre></td></tr></table></figure>
<h4 id="call-value-result-copy-restore">call value-result: copy-restore</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    ++x;<br>    ++y;<br>&#125;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">p</span>(a,a);<br><span class="hljs-comment">//a = 1,如果两个都为引用传递，则 a=3</span><br></code></pre></td></tr></table></figure>
<h3 id="保存调用函数的运行状态（额外的-Cost）">保存调用函数的运行状态（额外的 Cost）</h3>
<ul>
<li>存储新的基指针：如上面，将 ret_addr 和 main_esp 进行存储。</li>
<li>分配函数存储的空间</li>
<li>执行某些功能</li>
<li>释放不必要的存储空间</li>
</ul>
<h3 id="将控制转交给被调函数">将控制转交给被调函数</h3>
<ul>
<li>加载调用者的基指针</li>
<li>记载返回地址</li>
</ul>
<h3 id="Summary">Summary</h3>
<ol>
<li>加载参数（进栈）</li>
<li>保存上下文环境
<ul>
<li>保存返回地址</li>
<li>保存调用者基指针</li>
</ul>
</li>
<li>执行函数
<ul>
<li>设置新的基指针</li>
<li>分配空间（可选）</li>
<li>执行一些任务</li>
<li>释放空间（如果分配了的话）</li>
</ul>
</li>
<li>恢复上下文环境
<ul>
<li>加载调用者基指针</li>
<li>加载返回指针</li>
</ul>
</li>
<li>继续执行调用者的功能</li>
</ol>
<h3 id="思考">思考</h3>
<p>如果所有数据都放置在内存中的数据区：</p>
<ul>
<li>好处：方便管理</li>
<li>坏处：占用空间大，没有利用程序的局部性。</li>
</ul>
<h2 id="函数原型">函数原型</h2>
<ol>
<li>遵守先定义后使用原则</li>
<li>自由安排函数定义位置</li>
<li>语句：只需参数类型，无需参数名称</li>
<li>编译器检查</li>
<li>函数原型：只需要看到函数名和参数读取到即可：<code>int func(int,int)</code>
<ul>
<li>在调用点一定要能看到接口</li>
<li>仅仅需要函数名和参数类型即可</li>
</ul>
</li>
<li>函数原型应当放置在头文件中</li>
</ol>
<h2 id="内外部函数划分使用">内外部函数划分使用</h2>
<h3 id="内部函数">内部函数</h3>
<ol>
<li>static 修饰</li>
</ol>
<h3 id="外部函数">外部函数</h3>
<ol>
<li>默认状态的 extern</li>
</ol>
<h2 id="内联函数-inline">内联函数 inline</h2>
<ol>
<li>目的:
<ol>
<li>提高可读性</li>
<li>提高效率</li>
<li>解决了两个 cost 的问题</li>
</ol>
</li>
<li>对象:使用频率高、简单、小段代码</li>
<li>实现方法:编译系统将为 inline 函数创建一段代码，在每次调用时，用相应的代码替换</li>
<li>限制：
<ol>
<li>必须是非递归函数,因为已经加入主体部分了</li>
<li>由编译系统控制,和编译器是完全相关的</li>
</ol>
</li>
<li>inline 关键字仅仅是请求
<ol>
<li>有可能是递归，无法加入</li>
<li>也有可能是很复杂的函数，导致无法理解（上下文比较复杂）</li>
</ol>
</li>
<li>提请 inline 但是被拒绝可能是有代价的</li>
<li>如果对象的初始化-构造函数为明确给出，计算机会给出 inline 的构造函数</li>
<li>宏：<code>max(a,b) (a) &gt; (b) ? (a) : (b)</code>：不同于 inline 函数，一定要有括号，因为运算数据中的优先级不同</li>
</ol>
<h3 id="例子">例子</h3>
<p><img src="/47546/7.png" alt></p>
<ol>
<li>没有进行替换，只是将 ascii 函数体内操作直接进行替换。</li>
<li>内联必须和函数体放在一起，而不是和原型放在一起，并且函数体必须出现在调用之前，否则函数可以编译，但是不出现内联。</li>
</ol>
<h3 id="使用-inline-的优点和缺点">使用 inline 的优点和缺点</h3>
<ol>
<li>只有对编译系统的提示
<ol>
<li>过大、复杂、循环选择和函数体过大的会导致被拒绝</li>
<li>函数指针</li>
</ol>
</li>
<li>编译器：静态函数</li>
<li>缺点:
<ol>
<li>增大目标代码</li>
<li>病态的换页:如果有过长的代码，被替换进入代码的段中，代码页在内存和磁盘中反复换页抖动（每调用一次内联函数就会将那段代码复制到主文件中，内存增加，内存调用时原本一页的内容可能出现在第一页+第二页的一部分，造成操作系统的“抖动”)</li>
<li>降低指令快取装置的命中率（instruction cache hit rate)</li>
</ol>
</li>
</ol>
<h3 id="问题">问题</h3>
<ol>
<li>是所有的编译器都能做到 inline 吗?不是都能做到</li>
<li>如果我向编译器要求 inline，是否一定能做到吗？如果做不到按照正常函数进行处理</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chunyexiyu/article/details/43673059">函数放在头文件中被多次包含的重定义问题</a></li>
</ol>
<h2 id="ROP">ROP</h2>
<ol>
<li>在返回地址的时候，攻击我们的程序，调整 Bad_addr 导致调用到坏的代码（将错误的代码注入 stack 中去,在传入参数的过程中传入错误的代码）</li>
<li>防止这种攻击：禁止在执行过程中写入 stack</li>
<li>新的攻击方式：修改 return 前面的短序列（rop 链攻击）
<ul>
<li>使用正确代码的错误组合进行攻击</li>
<li>如果太长，需要依赖寄存器，导致攻击困难</li>
</ul>
</li>
<li>防止这种攻击：禁止读系统中的代码
<ol>
<li>因为这种攻击需要先读出来所有的操作，然后进行组合，如果不能读出也就没有了</li>
</ol>
</li>
</ol>
<h3 id="什么是-ROP">什么是 ROP</h3>
<ol>
<li>所谓 ROP：就是面向返回语句的编程方式，它就用 libc 代码段里面的多个 retq 前的一段指令的一段指令拼凑出一段有效的逻辑，从而达到攻击目的。</li>
<li>什么是 retq：retq 指定决定程序返回值在哪里执行，由栈上的内容决定，这是攻击者很容易控制的地址。</li>
<li>控制参数:在 retq 前面执行的 pop reg 指令，将栈上的内容弹到指令的寄存器上，以达到预期。（重复上述操作指导达成目的）</li>
<li>我们利用 glibc 进行逆向工程来查看返回前的 pop 指令</li>
</ol>
<h3 id="参考">参考</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/linyt/article/details/48738757/">使用 ROP 攻击技术</a></p>
<h2 id="函数副作用">函数副作用</h2>
<p>函数副作用可以实现 call by reference，参考 scanf，而并不是通过 return 多参数而实现。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat-award.jpg" alt="EagleBear2002 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="EagleBear2002 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/54526/" rel="prev" title="C++11 新特性">
      <i class="fa fa-chevron-left"></i> C++11 新特性
    </a></div>
      <div class="post-nav-item">
    <a href="/31310/" rel="next" title="软件工程与计算II-01-软件工程基础">
      软件工程与计算II-01-软件工程基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">1.1.</span> <span class="nav-text">函数的原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.</span> <span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">函数编译链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="nav-number">4.</span> <span class="nav-text">重载与重写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">函数的重载（Overload）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%EF%BC%88%E6%98%AF%E5%AF%B9%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A1%A5%E5%85%85%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">函数的默认参数（是对函数重载的补充）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0-extern"><span class="nav-number">5.</span> <span class="nav-text">外部函数 extern</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.</span> <span class="nav-text">符号表机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E5%AD%98"><span class="nav-number">6.</span> <span class="nav-text">函数与内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E5%AD%98"><span class="nav-number">6.1.</span> <span class="nav-text">存储空间与内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunTime-Environment"><span class="nav-number">6.2.</span> <span class="nav-text">RunTime Environment</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cdecl"><span class="nav-number">6.2.1.</span> <span class="nav-text">_cdecl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdcal"><span class="nav-number">6.2.2.</span> <span class="nav-text">_stdcal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fastcall"><span class="nav-number">6.2.3.</span> <span class="nav-text">_fastcall</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">函数执行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%A2%AB%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="nav-number">7.1.</span> <span class="nav-text">建立被调用函数的栈空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.</span> <span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">7.2.1.</span> <span class="nav-text">值传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9A%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">引用传递：函数副作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call-by-name"><span class="nav-number">7.2.3.</span> <span class="nav-text">call by name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call-value-result-copy-restore"><span class="nav-number">7.2.4.</span> <span class="nav-text">call value-result: copy-restore</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%EF%BC%88%E9%A2%9D%E5%A4%96%E7%9A%84-Cost%EF%BC%89"><span class="nav-number">7.3.</span> <span class="nav-text">保存调用函数的运行状态（额外的 Cost）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%8E%A7%E5%88%B6%E8%BD%AC%E4%BA%A4%E7%BB%99%E8%A2%AB%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.</span> <span class="nav-text">将控制转交给被调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Summary"><span class="nav-number">7.5.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-number">7.6.</span> <span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E5%88%92%E5%88%86%E4%BD%BF%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">内外部函数划分使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">内部函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0"><span class="nav-number">9.2.</span> <span class="nav-text">外部函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-inline"><span class="nav-number">10.</span> <span class="nav-text">内联函数 inline</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">10.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-inline-%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">10.2.</span> <span class="nav-text">使用 inline 的优点和缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">10.3.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ROP"><span class="nav-number">11.</span> <span class="nav-text">ROP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ROP"><span class="nav-number">11.1.</span> <span class="nav-text">什么是 ROP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">11.2.</span> <span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">12.</span> <span class="nav-text">函数副作用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EagleBear2002"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">EagleBear2002</p>
  <div class="site-description" itemprop="description">暮雪朝霜，毋改英雄意气</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">481</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EagleBear2002" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EagleBear2002" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:eaglebear2002@foxmail.com" title="E-Mail → mailto:eaglebear2002@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://czxingchen.github.io/" title="https:&#x2F;&#x2F;czxingchen.github.io&#x2F;" rel="noopener" target="_blank">PL 顶会研究者-XiaoZhi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/the-sword-of-king/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;the-sword-of-king&#x2F;" rel="noopener" target="_blank">模式识别专家-崖山剑</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://en.ydjsir.com.cn/" title="https:&#x2F;&#x2F;en.ydjsir.com.cn&#x2F;" rel="noopener" target="_blank">愿逐月华流照君-YDJSIR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/m0_51691879?spm=1000.2115.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51691879?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank">软院科协掌门人-wbl_z</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://itxia.club/" title="https:&#x2F;&#x2F;itxia.club&#x2F;" rel="noopener" target="_blank">侠之大者为国为民-IT 侠</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://chestnutsilver.github.io/TJIS-My-Helloworld/" title="https:&#x2F;&#x2F;chestnutsilver.github.io&#x2F;TJIS-My-Helloworld&#x2F;" rel="noopener" target="_blank">因果推断爱好者-ChestnutSilver</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://atritium.github.io/" title="https:&#x2F;&#x2F;atritium.github.io&#x2F;" rel="noopener" target="_blank">任天堂技术扛把子-manqi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.sakiyary.cn/" title="https:&#x2F;&#x2F;blog.sakiyary.cn&#x2F;" rel="noopener" target="_blank">教育部教学创新项目负责人-哈气鸭梨</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://huoxj.github.io/" title="https:&#x2F;&#x2F;huoxj.github.io&#x2F;" rel="noopener" target="_blank">离百年博客还有 98 年捞程序 Runz</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.erinwithbmq.xin/" title="https:&#x2F;&#x2F;www.erinwithbmq.xin&#x2F;" rel="noopener" target="_blank">摸鱼小能手 ErinwithBMQ の 尋夢之旅</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tilnel.github.io/" title="https:&#x2F;&#x2F;tilnel.github.io&#x2F;" rel="noopener" target="_blank">南大耐摔王 Tilnel 的杂谈小屋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.azifan.club/" title="https:&#x2F;&#x2F;blog.azifan.club&#x2F;" rel="noopener" target="_blank">水龙之魂</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mzy0624.github.io/" title="https:&#x2F;&#x2F;mzy0624.github.io&#x2F;" rel="noopener" target="_blank">Haibara AI</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EagleBear2002</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">40:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
