<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eaglebear2002.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"always","padding":18,"offset":12,"onmobile":true,"scroll_to_top_on_sidebar_toggle":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="$$ \def\ran{\text{ran}} \def\dom{\text{dom}} \def\FUN{\mathsf{FUN}} \def\card{\mathrm{card\ }} \def\len{\mathsf{len}} \def\size{\mathsf{size}} \def\F{\mathcal{F}} \def\A{\mathfrak{A}} \def\B{\mathfrak">
<meta property="og:type" content="article">
<meta property="og:title" content="数理逻辑-期末考点合集">
<meta property="og:url" content="https://eaglebear2002.github.io/42645/index.html">
<meta property="og:site_name" content="EagleBear2002 的博客">
<meta property="og:description" content="$$ \def\ran{\text{ran}} \def\dom{\text{dom}} \def\FUN{\mathsf{FUN}} \def\card{\mathrm{card\ }} \def\len{\mathsf{len}} \def\size{\mathsf{size}} \def\F{\mathcal{F}} \def\A{\mathfrak{A}} \def\B{\mathfrak">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/392e50f2737f790fedbca3b6b85f5428_720.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/9cc8f6373130156ffaa6569243e992a3.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/0d6dca47449d9dc0497666c529a55abf_720.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/8efd4be803dfc68885176f9230e5fa4b_720.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/ba445266c8955304a261afab4ab471f7_720.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/30812e9c782c3e8dc2522ace4af92d7d.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/74be57b5604b5090c8e1c891e1d4b3bb.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/4ee8a3e5286d4c6459949ba48ca5e9db_720.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/8fbbc94383b84fe984fd3778d9fcfd79_720.jpg">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/image-20241222130310927.png">
<meta property="og:image" content="https://eaglebear2002.github.io/42645/image-20241230000750745.png">
<meta property="article:published_time" content="2024-12-30T13:58:11.000Z">
<meta property="article:modified_time" content="2025-10-02T04:11:35.987Z">
<meta property="article:author" content="EagleBear2002">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eaglebear2002.github.io/42645/392e50f2737f790fedbca3b6b85f5428_720.jpg">

<link rel="canonical" href="https://eaglebear2002.github.io/42645/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数理逻辑-期末考点合集 | EagleBear2002 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<script>
  hljs.initLineNumbersOnLoad();
</script>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EagleBear2002 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里必须根绝一切犹豫，这里任何怯懦都无济于事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">61</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">481</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eaglebear2002" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eaglebear2002.github.io/42645/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="EagleBear2002">
      <meta itemprop="description" content="暮雪朝霜，毋改英雄意气">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EagleBear2002 的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数理逻辑-期末考点合集
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-30 21:58:11" itemprop="dateCreated datePublished" datetime="2024-12-30T21:58:11+08:00">2024-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-02 12:11:35" itemprop="dateModified" datetime="2025-10-02T12:11:35+08:00">2025-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">南京大学软件学院研究生课程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B/2024Fall-%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">2024Fall-数理逻辑</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>49k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>44 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>$$
\def\ran{\text{ran}}
\def\dom{\text{dom}}
\def\FUN{\mathsf{FUN}}
\def\card{\mathrm{card\ }}
\def\len{\mathsf{len}}
\def\size{\mathsf{size}}
\def\F{\mathcal{F}}
\def\A{\mathfrak{A}}
\def\B{\mathfrak{B}}
\def\Th{\mathrm{Th}}
\def\Cn{\mathrm{Cn}}
\def\Mod{\mathrm{Mod}}
\def\N{\mathfrak{N}}
\def\K{\mathcal{K}}
\def\G{\mathcal{G}}
\def\lh{\mathrm{lh}}
\def\v{\bar{v}}
\def\0{\mathbf{0}}
\def\bfS{\mathbf{S}}
\def\Cons{\mathrm{Cons}}
\def\Sb{\mathrm{Sb}}
\def\Fr{\mathrm{Fr}}
$$</p>
<p><strong>摘要</strong></p>
<p>本文是 2024Fall-数理逻辑 的期末考点合集，包括讲义第 0 章、教材第 1-3 章内容，并标注了考点。</p>
<p>本文添加了一些笔者对知识的理解，这部分注明不是来自讲义或教材，仅供参考。中文版《数理逻辑（第二版）》教材中存在许多翻译错误和公式排版、印刷错误，本文指出了其中一些错误并注明错处。</p>
<p>考试题型：</p>
<p>简答题：9 个，每个 5 分，共 45 分。3 个写文字的，6 个带构造的。</p>
<p>大题：6 个（5 题 9 分，1 题 10 分）。第 6、7 大题，注意区分本科生/研究生题目。</p>
<p>主要考基本概念。</p>
<h2 id="大佬镇场">大佬镇场</h2>
<table>
  <tr align="center">
    <td align="center"><img src="/42645/392e50f2737f790fedbca3b6b85f5428_720.jpg" height="370px" alt="Image 1"></td>
    <td align="center"><img src="/42645/9cc8f6373130156ffaa6569243e992a3.jpg" height="370px" alt="Image 2"></td>
    <td align="center"><img src="/42645/0d6dca47449d9dc0497666c529a55abf_720.jpg" height="370px" alt="Image 3"></td>
  </tr>
  <tr align="center">
    <td align="center"><img src="/42645/8efd4be803dfc68885176f9230e5fa4b_720.jpg" height="370px" alt="Image 4"></td>
    <td align="center"><img src="/42645/ba445266c8955304a261afab4ab471f7_720.jpg" height="370px" alt="Image 5"></td>
    <td align="center"><img src="/42645/30812e9c782c3e8dc2522ace4af92d7d.jpg" height="370px" alt="Image 6"></td>
  </tr>
  <tr align="center">
    <td align="center"><img src="/42645/74be57b5604b5090c8e1c891e1d4b3bb.jpg" height="200px" alt="Image 7"></td>
    <td align="center"><img src="/42645/4ee8a3e5286d4c6459949ba48ca5e9db_720.jpg" height="200px" alt="Image 8"></td>
    <td align="center"><img src="/42645/8fbbc94383b84fe984fd3778d9fcfd79_720.jpg" height="200px" alt="Image 9"></td>
  </tr>
</table>
<h2 id="讲义-S-0-2-集合">讲义 $\S 0.2$ 集合</h2>
<p>关于 ZFC 集合论及其构造思路，可参考本人博客：<a href="https://eaglebear2002.github.io/60104/">公理的祖先是逻辑或形式二者之一 | EagleBear2002 的博客</a>。</p>
<h3 id="讲义-S-0-2-15-良序关系">讲义 $\S 0.2.15$ 良序关系</h3>
<p>良序：设 $(A, \le)$ 为全序集，如果任意 $A$ 的非空子集都有 $\le$-极小元，则称 $(A, \le)$ 为良序集。</p>
<h3 id="讲义-S-0-2-17-自然数的定义">讲义 $\S 0.2.17$ 自然数的定义</h3>
<p>设 $A$ 为任意的集合，我们称 $A^+ = A \cup \set{A}$ 为 $A$ 的后继，$A$ 为 $A^+$ 的前趋。</p>
<p>自然数的定义：$0 = \emptyset, 1 = 0^+$。</p>
<p>无穷公理：所有自然数组成的整体是集合，记为 $\omega$。</p>
<h3 id="讲义-S-0-2-18-数学归纳法">讲义 $\S 0.2.18$ 数学归纳法</h3>
<p>传递集合：设 $A$ 是一个集合，如果 $A$ 的任意元素都是 $A$ 的子集，则称 $A$ 是传递集合。</p>
<p>三歧性：$\forall x, y \in A. x \in y \lor x = y \lor y \in x$。</p>
<p>对任意自然数 $n, m$ 定义：$m &lt; n$ 当且仅当 $m \in n$，$m \le n$ 当且仅当 $m &lt; n$ 或 $m = n$。（这一定义在本书的习题中已经被滥用，不仅限于自然数，在序数上都可以使用）</p>
<p>习题 1：证明设 $A$ 为传递集合，则 $A^+$ 也是传递集合。</p>
<blockquote>
<p>证明：由 $A$ 的传递性可知，$\forall a \in A, a \subseteq A$。取任意 $b \in A^+$，只要证明 $b \subseteq A^+$。</p>
<p>$A^+$ 是 $A$ 的后继（此处右上角的 $+$ 并不是传递闭包），即 $A^+ = A \cup \set{A}$。</p>
<ol>
<li>若 $b \in A$ 则 $b \subseteq A \subseteq A^+$；</li>
<li>若 $b \notin A$ 则 $b = A$，此时 $b \subseteq A^+$ 成立。</li>
</ol>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2：证明对任意自然数 $n$，都有 $0 = n$ 或 $0 \in n$。</p>
<blockquote>
<p>证明：对 $n$ 使用数学归纳法。</p>
<ol>
<li>若 $n = 0$，显然命题 $0 = n$ 成立；</li>
<li>若 $n = 1$，即 $n = \set{\emptyset, \set{\emptyset}}$，显然命题 $0 \in n$ 成立；</li>
<li>若 $n = k(k &gt; 1)$ 时命题 $0 \in n$ 成立，则 $n = k + 1$ 时，$n = k \cup \set{k}$，显然命题 $0 \in n$ 成立。</li>
</ol>
<p>因此，对任意自然数 $n$，都有 $0 = n$ 或 $0 \in n$​。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="讲义-S-0-2-19-有穷集合和无穷集合">讲义 $\S 0.2.19$ 有穷集合和无穷集合</h3>
<p>习题 1: 证明 $\omega^{++}$ 与 $\omega$ 等势。</p>
<blockquote>
<p>证明：构造 $f: \omega \to \omega^{++}$，其中 $f(0) = \omega, f(1) = \omega^{+}, f(n) = n - 2(n \ge 2)$。显然 $f$ 是双射，因此 $\omega^{++}$ 与 $\omega$ 等势。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2：假设 $A, B, A_1, B_1$ 为满足如下条件的集合：</p>
<ol>
<li>$A \cap A_1 = \emptyset, B \cap B_1 = \emptyset$；</li>
<li>$A \sim B, A_1 \sim B_1$；</li>
</ol>
<p>证明：$A \cup A_1 \sim B \cup B_1$。</p>
<blockquote>
<p>证明：由题意得，$\exists f: A \to B, g: A_1 \to B_1$，$f,g$ 为双射。</p>
<p>构造 $h: A \cup A_1 \to B \cup B_1$：</p>
<p>$$
h(x) = \left{\begin{matrix}
f(x) &amp; \text{if } x \in A \
g(x) &amp; \text{if } x \in A_1\
\end{matrix}\right.
$$</p>
<p>显然，$h$ 为双射。因此 $A \cup A_1 \sim B \cup B_1$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 3：设 $A, B$ 为两个集合，证明：</p>
<p>(1)$A \preceq B$ 当且仅当 $A$ 与 $B$ 的某个子集等势。</p>
<blockquote>
<p>证明：先证充分性。若 $A \preceq B$，则 $\exists f : A \to B$ 是一个单射。令 $C = \ran(f) \subseteq B$，则 $f: A \to C$ 是双射，因此 $A \sim C$。</p>
<p>再证必要性。若 $\exists D \subseteq B. A \sim D$，则 $\exists g: A \to D$ 为双射。因此 $g: A \to B$ 是单射，故 $A \preceq B$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="讲义-S-0-2-21-有穷集合">讲义 $\S 0.2.21$ 有穷集合</h3>
<p>习题：设 $A, B$ 为两个集合，试证明：</p>
<p>（1）如果 $A$ 有穷，$B \preceq A$，则 $B$ 也是有穷集合。</p>
<blockquote>
<p>证明：$A$ 是有穷集合</p>
<p>$\Rightarrow \exists n \in \omega. A \preceq n$</p>
<p>$\Rightarrow B \preceq n$</p>
<p>$\Rightarrow B$ 是有穷集合。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="讲义-S-0-2-22-可数集合">讲义 $\S 0.2.22$ 可数集合</h3>
<p>习题 1：设 $A, B$ 为两个可数集合，且 $A, B$ 不相交，即 $A \cap B = \emptyset$。证明：$A \cup B$ 也是可数的。</p>
<blockquote>
<p>证明：$A, B$ 可数意味着 $\exists f: \omega \to A, g: \omega \to B$，$f, g$ 为满射。构造</p>
<p>$$
h(n) = \left{\begin{matrix}
f(\frac{n}{2}) &amp; \text{if } n \text{ 为偶数}  \
g(\frac{n-1}{2}) &amp; \text{if } n \text{ 为奇数} \
\end{matrix}\right.
$$</p>
<p>显然 $h: \omega \to A \cup  B$ 为满射。因此 $A \cup B$ 可数。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2：证明：</p>
<p>（1）对任意 $k \in \omega$ 有，$\omega^k$ 都是可数集合（约定 $\omega^0 = \set{\emptyset}, \omega^1 = \omega$）；</p>
<p>（2）集合 $\bigcup \set{\omega^k | k \in \omega}$ 是可数的。</p>
<blockquote>
<p>TODO：这道题用到了构造 $A \times B \to \omega$ 的函数，需要记住。</p>
<p>（1）证明：引理：两个可数集合的笛卡尔积是可数集合。对于可数集合 $A, B$，$f: A \to \omega, g: B \to \omega$ 为单射。构造 $h(x, y) = \frac{(f(x)+g(y))\times(f(x)+g(y)+1)}{2} + g(y)$ ，则 $h:A\times B \to \omega$ 为单射。因此 $A \times B$ 可数。</p>
<p>下面进行归纳：</p>
<p>$k = 0$ 时，$\omega^0 = \set{\emptyset}$ 显然是可数集合。</p>
<p>$k = 1$ 时，构造 $f_1: \omega \to \omega$，$f_1(x) = x$ 为双射，可知 $\omega^1$ 为可数集合。</p>
<p>由 $\omega^k$ 为可数集合和引理可知，$\omega^{k+1}=\omega^k \times \omega$ 为可数集合。</p>
<p>因此，对任意 $k \in \omega$ 有，$\omega^k$ 都是可数集合。</p>
<p>$Q.E.D.$</p>
<p>（2）证明：由定理 0.2.7，可数多个可数集合的并仍然是可数集合，因此 $\bigcup \set{\omega^k | k \in \omega}$ 是可数集合。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="讲义-S-0-2-24-不可数集合（不考）">讲义 $\S 0.2.24$ 不可数集合（不考）</h3>
<p>习题 1：令 $\FUN(\omega, \omega)$ 表示所有从 $\omega$ 到 $\omega$ 的映射组成的集合，即 $\FUN(\omega, \omega) = \set{f|f: \omega \to \omega 为映射}$，用对角线方法证明 $\FUN(\omega, \omega)$ 是不可数的。</p>
<blockquote>
<p>证明：使用反证法。假设 $\FUN(\omega, \omega)$ 可数，不妨设 $\FUN(\omega, \omega) = \set{f_0, f_1, f_2, \dots}$。</p>
<p>构造新映射 $f: \omega \to \omega$，$f(n) = f_n(n) + 1$。</p>
<ol>
<li>若 $f \notin \FUN(\omega, \omega)$，与 $\FUN(\omega, \omega)$ 的定义相矛盾；</li>
<li>若 $f \in \FUN(\omega, \omega)$，但 $\forall n \in \mathbb{N}. f(n) \ne f_n(n)$，矛盾。</li>
</ol>
<p>假设不成立。原命题成立。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="讲义-S-0-2-25-序数">讲义 $\S 0.2.25$ 序数</h3>
<p>具有三歧性的传递集合叫做序数。每个自然数都是序数，$\omega$ 是序数。</p>
<p>本书中对序数的定义并不直观，也没有说明序数的用途。此处补充序数的描述：</p>
<p>在数理逻辑中，序数（ordinal numbers） 是一种用于表示集合的“大小”和“顺序类型”的概念，尤其在集合论、公理集合论和模型论中起着重要作用。序数扩展了自然数的概念，可以用来描述无穷集合的大小和结构，起到了将有限和无限统一到同一框架下的作用。</p>
<p>序数是良序集的等价类。直观地，序数可以理解为一种表示“位置”的标签，且这些标签本身是有序的。</p>
<p>习题：设 $S$ 为序数集合，证明：</p>
<p>（1）如果 $\alpha$ 是 $S$ 的最大元，则 $\alpha = \bigcup S$；</p>
<p>（2）如果 $S$ 中无最大元，则对任何的 $\beta$ 属于 $S$，有 $\beta &lt; \bigcup S$。</p>
<blockquote>
<p>（1）证明：$\alpha$ 是 $S$ 的最大元，由三歧性得，$\forall \beta \in S. \beta = \alpha \vee \beta \in \alpha$。</p>
<p>由 $S$ 是传递集合，$\forall \beta \in S. \beta \subseteq \alpha$，即 $S$ 中任意元素都是 $\alpha$ 的子集，因此 $\bigcup S \subseteq \alpha$。</p>
<p>由 $\alpha \in S$ 得，$\alpha \subseteq \bigcup S$。</p>
<p>因此 $\alpha= \bigcup S$。</p>
<p>$Q.E.D.$</p>
<p>（2）证明：由传递集合得，$\forall \beta \in S. \beta \subseteq \bigcup S$。</p>
<p>$S$ 中没有最大元，即 $\forall \beta \in S. \exists \gamma \in S. \beta &lt; \gamma$，因此 $\beta \ne \bigcup S$。</p>
<p>因此，$\beta &lt; \bigcup S$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="讲义-S-0-2-26-超穷归纳法">讲义 $\S 0.2.26$ 超穷归纳法</h3>
<p>如果 $\alpha$ 存在前趋，称 $\alpha$ 为后继序数。不是后继序数的非零序数称为极限序数。</p>
<p>习题：设 $\alpha, \beta$ 为序数，且 $\alpha \ne 0$。</p>
<p>（1）$\alpha$ 是极限序数，当且仅当 $\bigcup \alpha = \alpha$；</p>
<p>（2）如果 $\beta \in \alpha$，且 $\beta$ 是 $\alpha$ 的最大元，则 $\alpha = \beta^+$。</p>
<blockquote>
<p>（1）证明：</p>
<p>先证必要性（$\alpha$ 是极限序数 $\Rightarrow \bigcup \alpha = \alpha$）：如果 $\alpha$ 是极限序数，那么 $\forall \beta \in \alpha. \beta &lt; \alpha$，并且 $\alpha$ 中没有最大元。</p>
<p>由 $\alpha$ 的传递性可知，$\alpha$ 中任意元素都是其子集，因此 $\bigcup \alpha \subseteq \alpha$。</p>
<p>$\forall \beta \in \alpha. \forall x \in \beta. x \in \bigcup \alpha$ 因此 $\beta \subseteq \bigcup \alpha$。又由传递性，$\beta \subseteq \alpha$，因此 $\beta \in \bigcup \alpha$。因此 $\alpha \subseteq \bigcup \alpha$。（TODO：这一步有点问题）</p>
<p>因此 $\bigcup \alpha = \alpha$。</p>
<p>再证充分性（$\bigcup \alpha = \alpha \Rightarrow \alpha$ 是极限序数）：假设 $\bigcup \alpha = \alpha$。这意味着 $\alpha$ 是由它自身的所有元素组成的，并且对于每个 $\beta \in \alpha$，都有 $\beta \subset \alpha$。</p>
<p>如果 $\alpha$ 不是极限序数，则 $\alpha$ 中应有一个最大元 $\gamma$，使得 $\alpha = \gamma^+$。由上一题结论，$\bigcup \alpha = \gamma$，但这与假设 $\bigcup \alpha = \alpha$ 矛盾。因此，$\alpha$ 不能有最大元。</p>
<p>因此，$\alpha$ 必须是极限序数。</p>
<p>$Q.E.D.$</p>
<p>（2）证明：由 $\beta$ 是 $\alpha$ 中最大元，$\forall \gamma \in \alpha. \gamma \le \beta$，且 $\alpha$ 为后继序数（TODO：这一步怎么来的？）。设 $\alpha = \beta_0^+ = \beta_0 \cup \set{\beta_0}$，只要证明 $\beta = \beta_0$。</p>
<p>若 $\beta &lt; \beta_0$，与 $\beta$ 是 $\alpha$ 中最大元矛盾；</p>
<p>若 $\beta_0 &lt; \beta$，则 $\alpha = \beta_0^+ \le \beta$，与 $\beta \in \alpha$ 矛盾。</p>
<p>因此，$\beta = \beta_0$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="讲义-S-0-2-28-可数序数">讲义 $\S 0.2.28$ 可数序数</h3>
<p>定义 $\omega_1 = \set{\alpha \mid \alpha \text{ 是可数序数}}$。$\omega_1$ 是序数，且不可数。</p>
<p>定义 $\omega_{\alpha+1} = \set{\beta \mid \beta \text{ 是序数且 } \beta \preceq \omega_\alpha}$。</p>
<h3 id="讲义-S-0-2-29-基数">讲义 $\S 0.2.29$ 基数</h3>
<p>设 $\alpha$ 是序数，如果对于任意的 $\beta &lt; \alpha$ 都有 $\beta \prec \alpha$，则称 $\alpha$ 是基数。</p>
<p>讲义中对基数的定义十分诡异，我们在这里补充教材中对基数的定义。集合 $A$ 的基数 $\card A$ 是与 $A$ 大小相等的最小序数，基数的意义是用于比较集合的大小：</p>
<p>$$
\card A = \card B \iff A \sim B
$$</p>
<p>习题 1：设 $\alpha$ 为基数，$\kappa$ 为集合 $\set{\beta | \beta \ 是序数且与\ \alpha \ 等势}$ 的最小元。证明：$\kappa$ 是基数。</p>
<blockquote>
<p>TODO：看不明白过程</p>
<p>证明：对每个序数 $\gamma &lt; \kappa$，即 $\gamma \in \kappa$，有 $\gamma \subseteq \kappa$，即 $\gamma \prec \kappa$ 或 $\gamma \sim \kappa$。</p>
<p>又因为 $\kappa$ 为集合中最小元，因此 $\gamma \prec \kappa$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2：对任意的 $\alpha$ 都有，$\alpha \le \omega_\alpha$。</p>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="教材-S-1-命题逻辑">教材 $\S 1$ 命题逻辑</h2>
<h3 id="教材-S-1-1-命题逻辑的语言">教材 $\S 1.1$ 命题逻辑的语言</h3>
<p>习题 2：证明不存在长度为 2、3、6 的合式公式，但其他任意正整数长度的合式公式都可能存在。</p>
<blockquote>
<p>证明：用 $\len(\alpha)$ 表示公式 $\alpha$ 的长度。定义谓词 $P$，命题 $P(\alpha): \len(\alpha) \notin \set{2, 3, 6}$。</p>
<p>对所有命题符号 $A_n$，$\len(A_n) = 1$，命题 $P(A_n)$ 成立。</p>
<p>对所有非命题符号的合式公式 $\alpha$ 归纳：</p>
<p>下面证明：若组成合式公式 $\alpha$ 的合式公式 $\beta, \gamma$ 均有 $P(\beta), P(\gamma)$ 成立，则 $P(\alpha)$ 成立。</p>
<ol>
<li>若 $\alpha = (\lnot \beta)$，则 $\len(\alpha) \ge 4$，$\len(\alpha) \notin \set{2, 3}$。若 $\len(\alpha) = 6$，则 $\len(\beta) = 3$，与 $P(\beta)$ 矛盾；</li>
<li>若 $\alpha = (\beta \square \gamma)$（其中 $\square \in \set{\vee, \wedge, \to, \leftrightarrow}$），显然 $\len(\alpha) = \len(\beta) + \len(\gamma) + 3&gt; 5$。若 $\len(\alpha) = 6$ 则 $\len(\beta) + \len(\gamma) = 3$，与 $P(\beta)$ 或 $P(\gamma)$ 矛盾。</li>
</ol>
<p>因此，$\len(\alpha) \notin \set{2, 3, 6}$。</p>
<p>下面证明 $\len(\alpha)$ 可以为其他任何长度。</p>
<p>$\len$ 函数存在如下递归关系：</p>
<p>$$
\len(A_n) = 1 \
\len((\lnot \alpha)) = \len(\alpha) + 3 \
\len((\alpha \square A_n)) = \len(\alpha) + 4
$$</p>
<p>显然，$\len(\alpha)$ 可以为 $\set{1, 4, 5, 7, 8, 9}$ 中的任何值。根据长度为 7、8、9 的公式，可以根据 $\len((\lnot \alpha)) = \len(\alpha) + 3$ 构造长度为大于 9 的任意整数的公式。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 3：设 $\alpha$ 是一个合式公式，$c$ 是二元连接符（$\wedge, \vee, \to, \leftrightarrow$）出现的次数，$s$ 是命题符合出现的次数（例如，若 $\alpha = (A \to (\lnot A))$，则 $c = 1, s = 2$）。使用归纳法证明：$s = c + 1$。</p>
<blockquote>
<p>证明：命题 $P(n): \text{当 } c = n \text{ 时}，s = c + 1$。</p>
<p>当 $c = 0$ 时，$\alpha = A$ 或 $\alpha = (\lnot A)$，其中 $A$ 是命题符号。$P(0)$ 成立。</p>
<p>若当 $c \le n (n \ge 1)$ 时都有 $P(c)$ 成立。则当 $c = n + 1$ 时，$\alpha = (\beta \square \gamma)$，其中 $c_\alpha = c_\beta + c_\gamma + 1, s_\alpha = s_\beta + s_\gamma = c_\beta + c_\gamma + 2 = c_\alpha + 1$。此时 $P(n+1)$ 成立。</p>
<p>因此，对任意 $c \ge 0$，都有 $P(c)$ 成立。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-1-2-真值指派">教材 $\S 1.2$ 真值指派</h3>
<p>对于命题符号集合 $S$，真值指派 $v$ 是函数：</p>
<p>$$
v : S \to \set{T, F}
$$</p>
<p>设 $\bar{S}$ 是由 $S$ 通过 5 种公式构造运算得到的合式公式的集合，我们将 $v$ 扩展到 $\bar{v}$：</p>
<p>$$
\bar{v} : \bar{S} \to \set{T, F}
$$</p>
<p>我们称真值指派 $v$ 满足 $\varphi$，当且仅当 $\bar{v}(\varphi) = T$。</p>
<p>重言蕴含：$\Sigma \models \tau$ 当且仅当满足 $\Sigma$ 中每个合式公式的真值指派也满足 $\tau$。$\set{\sigma} \models \tau$ 也记为 $\sigma \models \tau$。</p>
<p>重言式： $\emptyset \models \tau$ 也记为 $\models \tau$。</p>
<p>重言等价：$\sigma \models \tau$ 并且 $\tau \models \sigma$，记为 $\sigma \models =| \tau$。</p>
<p>紧致性定理：设 $\Sigma$ 是合式公式的无限集合，如果对于 $\Sigma$ 中的任意有限子集 $\Sigma_0$，都存在一个真值指派满足 $\Sigma_0$ 中的每个合式公式，那么，就存在一个真值指派满足 $\Sigma$ 的所有合式公式（即，如果 $\Sigma$ 的任意有限子集可满足，则 $\Sigma$ 可满足）。</p>
<p>习题 6：（a）证明：如果两个真值指派 $v_1, v_2$ 与在合式公式 $\alpha$ 中出现的命题符号的指派是一致的，那么 $\overline{v_1}(\alpha) = \overline{v_2}(\alpha)$。（使用归纳法则）。</p>
<blockquote>
<p>证明：设 $\langle \varepsilon_1 , \varepsilon_2 , \dots , \varepsilon_n \rangle$ 是 $\alpha$ 的构造序列。</p>
<p>$$
\forall A \in \alpha. v_1(A) = v_2(A) \
\Rightarrow v_1(\varepsilon_1) = v_2(\varepsilon_1) \
\Rightarrow \forall k \le n. \overline{v_1}(\langle \varepsilon_1 , \varepsilon_2 , \dots , \varepsilon_k \rangle) = \overline{v_2}(\langle \varepsilon_1 , \varepsilon_2 , \dots , \varepsilon_k \rangle) \
\Rightarrow \overline{v_1}(\alpha) = \overline{v_2}(\alpha)
$$</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 8：（置换）$\alpha_1, \alpha_2, \dots$ 一个合式公式的序列，对每个合式公式 $\varphi$，令 $\varphi^*$ 是用 $\alpha_n$ 置换 $A_n$（对所有 $n$）后得到的结果。</p>
<p>（a）设 $v$ 是所有命题符号的真值指派，定义 $u$ 为满足 $u(A_n) = \overline{v}(\alpha_n)$ 的真值指派，证明 $\overline{u}(\varphi) = v(\varphi^*)$ 使用归纳法。</p>
<p>（b）证明如果 $\varphi$ 是重言式，那么 $\varphi^*$ 也是。（例如，$((A \land B) \leftrightarrow (B \land A))$ 是一个重言式，因此对任意的合式公式 $\alpha, \beta$，通过置换可得 $((\alpha \land \beta) \leftrightarrow (\beta \land \alpha))$ 是重言式）</p>
<blockquote>
<p>（a）证明：命题 $P(k): \varphi \ 构造序列长度为\ k\ 时，\overline{u}(\varphi) = v(\varphi^*)$。设 $\varphi$ 的构造序列为 $\langle \varepsilon_1 , \varepsilon_2 , \dots , \varepsilon_k \rangle$。对 $k$ 进行归纳：</p>
<p>当 $k = 1$ 时，$\varepsilon_1$ 为命题符号，命题 $P(1)$ 成立。</p>
<p>若当 $k &lt; n(n &gt; 1)$ 时，命题 $P(k)$ 都成立。</p>
<p>则当 $k = n$ 时，$u(\varepsilon_{n}) = v(\varepsilon_{n})$，因此 $\overline{u}(\langle \varepsilon_1 , \varepsilon_2 , \dots , \varepsilon_n \rangle) = \overline{v}(\langle \varepsilon_1 , \varepsilon_2 , \dots , \varepsilon_n \rangle)$。</p>
<p>因此，对所有 $k \ge 1$，命题 $P(k)$ 都成立。</p>
<p>$Q.E.D.$</p>
<p>（b）证明：若 $\varphi$ 是重言式。对任意真值指派 $v$，$\overline{v}(\varphi^<em>) = \overline{u}(\varphi) = T$。因此 $\varphi^</em>$ 为重言式。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-1-3-解析算法">教材 $\S 1.3$ 解析算法</h3>
<p>习题 3（不考）：证明引理 13B 中关于运算 $\varepsilon_\lnot$ 的情形。</p>
<blockquote>
<p>证明：对具有该性质的合适公式的集合 $S$，使用归纳法。</p>
<p>只包括一个命题的合适公式，没有符合条件的真初始段，原命题显然成立。</p>
<p>下面验证 $S$ 在 $\varepsilon_\lnot$ 下是封闭的。考虑 $S$ 中的 $\alpha$，$(\lnot \alpha)$ 的真初始段如下：</p>
<ol>
<li>$($</li>
<li>$(\lnot$</li>
<li>$(\lnot \alpha_0$，其中 $\alpha_0$ 是 $\alpha$ 的真初始段</li>
<li>$(\lnot \alpha$</li>
</ol>
<p>显然，$\alpha_0 \in S$。原命题显然正确。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 4：假定将合式公式的定义修改为去掉其中所有的右括号。对于</p>
<p>$$
((A \wedge (\lnot B)) \to (C \vee D))
$$</p>
<p>我们写成：</p>
<p>$$
((A \wedge (\lnot B \to (C \vee D
$$</p>
<p>证明这种记法具有唯一可读性（即每个合式公式只有一个可能的分解方法）。提示：这种表达式具有的括号数和联结符号数相同。</p>
<blockquote>
<p>证明：只需给出算法，可以根据每个该记法下的公式 $e$ 和合式公式一一对应。</p>
<p>一种“自底向上”的构造算法：令 $S$ 表示所有合式公式（包括命题符号）的集合。</p>
<ol>
<li>对 $e$ 中出现的每个串 $\alpha， \beta$，若 $\alpha, \beta \in S$，执行替换：
$$
( \lnot \alpha \to (\lnot \alpha) \
( \alpha \wedge \beta \to ( \alpha \wedge \beta ) \
( \alpha \vee \beta \to ( \alpha \vee \beta ) \
$$</li>
<li>重复步骤 1，直到无法执行替换。</li>
</ol>
<p>在上述算法中，每次执行替换时在 $e$ 中增加了一个右括号 $)$，上述算法会在有限步骤内结束。替换后的子串都是合式公式，因此每个算法结束后 $e$ 成为合式公式。又因为该记法下每个公式都是由某个合式公式转化而来，因此该记法下每个公式和合式公式一一对应。</p>
<p>$Q.E.D.$</p>
<p>直观上，上述算法每次迭代时把一个或两个短的合式公式变成一个更长的合式公式，直到包含所有的命题符号，整个公式称为一个合式公式。</p>
</blockquote>
<h3 id="教材-S-1-4-归纳与递归">教材 $\S 1.4$ 归纳与递归</h3>
<p>习题 1：设 $C$ 是由集合 $B=\set{a, b}$ 在二元运算 $f$ 和一元运算 $g$ 的作用下生成的。试列出 $C_2$ 中的所有元素。$C_3$ 和 $C_4$ 中各有多少元素？</p>
<blockquote>
<p>$C_n$ 是长度为 $n$ 的构造序列的最后一个元素 $x$ 的集合，$C_1 = B$。</p>
<p>$$
C_2 = \set{a, b, g(a), g(b), f(a, a), f(b, b)}
$$</p>
<p>$\size(C_1) = 2, \size(C_2) = 6$</p>
<p>枚举 $C_3$ 中的元素：</p>
<p>$$
C_3 = \left{ a, b, g(a), g(b), f(a, a), f(b, b), \
g(g(a)), g(f(a, a)), g(g(b)), g(f(b, b)), \
f(a, b), f(b, a), f(a, g(a)), f(g(a), a), f(g(a), g(a)),\
f(a, f(a, a)), f(f(a, a), a), f(f(a, a), f(a, a)) \
f(b, g(b)), f(g(b), b), f(g(b), g(b)),\
f(b, f(b, b)), f(f(b, b), b), f(f(b, b), f(b, b)) \
\right}
$$</p>
<p>因此，$\size(C_3) = 24$ 。同理，$\size(C_4) = 144$。</p>
<p>陆老师原话：“数字不重要，你把前两个写出来就行了，后面的太难了”。</p>
</blockquote>
<p>习题 3：本节中关于要求 $\F$ 仅是 $U$ 上的关系类的讨论可以进行推广。$C_<em>$ 如前定义，但是如果对于每个 $i \le n$，我们有 $x_i \in B$ 或者对某个 $R \in \F$ 以及某些小于 $i$ 的数 $j_1, \dots, j_k$ 有 $\langle x_{j_1}, \dots , x_{j_k}, x_i \rangle \in R$，那么我们说 $\langle x_0, , x_1 \dots , x_n \rangle$ 是一个构造序列。请给出 $C^</em>$ 的正确定义，并证明 $C^* = C_*$。</p>
<blockquote>
<p>TODO：如何定义集合对多元关系（而非多元函数）封闭？</p>
<p>“自顶向下”的 $C^*$ 的扩展定义：</p>
<p>我们称 $U$ 的子集 $S$ 在 $R \in \F$ 的作用下是封闭的，当且仅当只要 $x_0 , x_1 \dots , x_n \in S$，那么 $\forall x_m. \langle x_0, , x_1 \dots , x_n , x_m \rangle \in R \Rightarrow x_m \in S$。称 $S$ 是归纳的，当且仅当 $B \subseteq S$ 并且 $S$ 在 $R$ 的作用下是封闭的。令 $C^<em>$ 是 $U$ 的所有归纳子集的交集，则 $x \in C^</em>$ 当且仅当 $x$ 属于 $U$ 的每个归纳子集。</p>
<p>证明 $C^* = C_*$：</p>
<p>首先验证 $C^* \subseteq C_<em>$。我们只需要证明 $C_</em>$ 是归纳的，即 $B \subseteq C_<em>$ 并且 $C_</em>$ 在 $R \in \F$ 的作用下是封闭的。显然 $B = C_1 \subseteq C_<em>$。如果 $x_0 , x_1 \dots , x_n \in C_</em>$，则将其构造序列进行连接，并添加每个新的元素 $x_m$，其中 $\langle x_0, , x_1 \dots , x_n , x_m \rangle \in R, R \in \F$，我们就得到了一个新的构造序列，并将 $x_m$ 加入了 $C_<em>$ 中。因此，$C_</em>$ 在 $R \in \F$ 的作用下是封闭的。</p>
<p>其次证明 $C_* \subseteq C^<em>$。考察构造序列 $\langle x_0, , x_1 \dots , x_n, x_m \rangle$，对 $i \le n$ 进行归纳，可得到 $x_i \in C^</em>$。首先 $x_0 \in B \subseteq C^<em>$。在归纳步骤使用 $C_</em>$ 的封闭特性即可。因此得到：</p>
<p>$$
\bigcup_n C_n = C_* = C^* = \bigcap\set{S | S \ 是归纳的}
$$</p>
<p>$Q.E.D.$</p>
<p>这种题考场会出吗？根本不认得符号 😭</p>
</blockquote>
<h3 id="教材-S-1-5-命题连接词">教材 $\S 1.5$ 命题连接词</h3>
<p><img src="/42645/image-20241222130310927.png" alt></p>
<p>习题 1：设 $G$ 是三元布尔函数，定义如下：</p>
<p>$$
G(F, F,F)= F, G(T, F, F) =T, \
G(F, F,T) = T, G(T, F,T) = F, \
G(F,T, F) =T, G(T,T, F) = F, \
G(F,T,T)=F, G(T,T,T) = F.
$$</p>
<p>（a）给出一个仅使用 $\wedge, \vee, \lnot$ 的能够实现的合式公式；</p>
<p>（b）给出一个合式公式，其联结词最多出现 5 个。</p>
<blockquote>
<p>（a）观察可知，当且仅当三个参数中只有一个 $T$ 时，函数值为 $T$。</p>
<p>构造析取范式：</p>
<p>$$
G(A, B, C) = (A \wedge \lnot B \wedge \lnot C) \vee (\lnot A \wedge B \wedge \lnot C) \vee (\lnot A \wedge \lnot B \wedge C)
$$</p>
<p>（b）将上述函数简化：</p>
<p>$$
G(A, B, C) = (A \wedge \lnot (B \lor C)) \vee (\lnot A \wedge (B + C)) \
= ((B \lor C) &lt; A) \vee (A &lt; (B + C))
$$</p>
<p>思路：应用 $A \land \lnot B = B &lt; A$ 来减少连接个数。</p>
</blockquote>
<p>习题 5：证明 $\set{\top, \bot, \lnot, \leftrightarrow , +}$ 是不完备的。提示：证明任意使用这些联结词和命题符号 $A, B$ 的合式公式在 $\bar{v}(\alpha)$ 的 4 种可能的取值下有偶数个取值为 $T$。说明：另一种方法是使用域 $\set{0，1}$ 上的代数，任意使用这些联结词的可实现的布尔函数具有线性的特性。</p>
<blockquote>
<p>证明：由于 $\top \equiv A \leftrightarrow A, \bot \equiv A \leftrightarrow \lnot A, \alpha + \beta \equiv \alpha \leftrightarrow \lnot \beta$，其中 $\equiv$ 表示重言等价（LaTeX 中没有重言等价符号）。即 $\set{\top, \bot, +}$ 可以用其他连结词表示，因此只需要证明 $\set{\lnot, \leftrightarrow}$ 是不完备的。</p>
<p>令 $\alpha$ 是任意只包含 $A, B$ 的公式，只要证明在 $\bar v(\alpha)$ 下的四种可能取值中有偶数个为 $T$。</p>
<p>合式公式 $A$ 和 $B$ 显然只有偶数个 $T$。若合式公式 $\alpha, \beta$ 有偶数个 $T$，则合式公式 $\lnot \alpha$ 和 $\alpha \leftrightarrow \beta$ 也有偶数个 $T$​。</p>
<p>因此，该联结词集合和命题符号无法构造与 $A \vee B$ 等价的公式，该连结词集合不完备。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-1-7-紧致性和能行性（不考）">教材 $\S 1.7$ 紧致性和能行性（不考）</h3>
<p>习题 1：设 $\Sigma$ 的每个有限子集都是可满足的，证明 $\Sigma ; \alpha$ 和 $\Sigma ; \neg \alpha$ 中至少有一个也是如此。(这是紧致性定理证明的一部分)</p>
<p>提示：如果不是这样，那么对于有限子集 $\Sigma_1 \subseteq \Sigma$ 和 $\Sigma_2 \subseteq \Sigma$，$\Sigma_1 ; \alpha$ 和 $\Sigma_2 ; \neg \alpha$ 都是不可满足的。再考虑 $\Sigma_1 \cup \Sigma_2$。</p>
<blockquote>
<p>不使用紧致性定理的证明：使用反证法。如果不是这样，则对于有限子集 $\Sigma_1 \subseteq \Sigma$ 和 $\Sigma_2 \subseteq \Sigma$，$\Sigma_1 ; \alpha$ 和 $\Sigma_2 ; \neg \alpha$ 都是不可满足的。因此 $\Sigma_1 \cup \Sigma_2$ 也是不可满足的。这与“$\Sigma$ 的每个有限子集都是可满足的”相矛盾。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2：设 $\Delta$ 是满足以下条件的合式公式集合：</p>
<ol>
<li>$\Delta$ 的每个有限子集是可满足的，</li>
<li>对每个合式公式 $\alpha$，要么 $\alpha \in \Delta$ 要么 $(\neg \alpha) \in \Delta$。</li>
</ol>
<p>对每个命题符号 $A$，定义真值指派 $v$：</p>
<p>$$
v(A) =
\begin{cases}
T &amp; \text{iff } A \in \Delta, \
F &amp; \text{iff } A \notin \Delta
\end{cases}
$$</p>
<p>证明对每个合式公式 $\varphi$，$\v(\varphi) = T$ 当且仅当 $\varphi \in \Delta$。（这也是紧致性定理证明的一部分）</p>
<p>提示：对 $\varphi$ 使用归纳法。</p>
<blockquote>
<p>证明：对 $\varphi$ 使用归纳法。</p>
<p>若 $\varphi$ 为命题符号，则根据 $v$ 的定义，$\v(\varphi) = T$ 当且仅当 $\varphi \in \Delta$，原命题对 $\varphi$ 成立。</p>
<p>若对于构造序列长度小于 $n$ 的所有合式公式，原命题都成立。</p>
<p>则对于构造序列长度为 $n$ 的合式公式 $\varphi$，设其构造序列为 $\langle \varepsilon_1 , \varepsilon_2 , \dots , \varepsilon_n \rangle$。</p>
<ol>
<li>若 $\varphi = (\lnot \alpha)$，$\v(\lnot \alpha) = T \iff \v(\alpha) = F \iff \alpha \notin \Delta \iff (\lnot \alpha) \in \Delta$，原命题对 $\varphi$ 显然成立；</li>
<li>若 $\varphi = (\alpha \wedge \beta)$，$\v(\alpha \wedge \beta) = T \iff \v(\alpha) = T \wedge \v(\beta) = T \iff \alpha \in \Delta \wedge \beta \in \Delta$。由条件 2 可知，$\Delta$ 对 $\wedge$ 封闭。因此 $\alpha \in \Delta \wedge \beta \in \Delta \iff \alpha \wedge \beta \in \Delta$。原命题对 $\varphi$ 成立。</li>
<li>若 $\varphi = (\alpha \vee \beta)$，可转化为 $\varphi = \lnot(\lnot \alpha \wedge \lnot \beta)$。根据 1 和 2 归纳即可。</li>
</ol>
<p>因此，原命题对所有合式公式 $\varphi$ 成立。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h2 id="教材-S-2-一阶逻辑">教材 $\S 2$ 一阶逻辑</h2>
<h3 id="教材-S-2-1-一阶语言">教材 $\S 2.1$ 一阶语言</h3>
<p>表达式是符号的任意有限序列。大多数表达式没有意义，项和合式公式是具有特定意义的表达式。</p>
<p>项定义为在常数符号和变量之前加上函数符号构成的表达式，如 $fx$。</p>
<p>原子公式的做工相当于命题逻辑中的命题符号，原子公式是具有如下形式的表达式：</p>
<p>$$
Pt_1t_2\dots t_n
$$</p>
<p>合式公式（或公式）是指由原子公式通过使用 0 次或多次连接符号和量词符号构成的表达式。</p>
<p>自由变量是“没有量词约束”的变量。</p>
<p>句子是没有自由变量的合式公式。</p>
<h4 id="概念辨析">概念辨析</h4>
<table>
<thead>
<tr>
<th>特点</th>
<th>公式（Formula）</th>
<th>句子（Sentence）</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否含自由变量</td>
<td>可能含有自由变量</td>
<td>不含自由变量</td>
</tr>
<tr>
<td>可判定性</td>
<td>不能直接判定，需要赋值</td>
<td>可以直接判定真值</td>
</tr>
<tr>
<td>作用</td>
<td>描述性质或关系，通常作为表达式的一部分</td>
<td>完整断言，可以作为公理或定理</td>
</tr>
<tr>
<td>示例</td>
<td>$P(x) \rightarrow Q(y)$</td>
<td>$\forall x (P(x) \rightarrow Q(x))$</td>
</tr>
</tbody>
</table>
<p>我们会尽量使用如下字母表：</p>
<ul>
<li>谓词符号：大写斜体的字母和 $\in, &lt;$；</li>
<li>变量：$v_i, u, v, x, y, z$；</li>
<li>函数符号：$f,g,h,S,+$ 等；</li>
<li>常数符号：$a,b,\dots,0$；</li>
<li>项：$u,t$；</li>
<li>公式：小写希腊字母；</li>
<li>句子：$\sigma, \tau$；</li>
<li>公式集：大写希腊字母和特定的斜体字母（看作是希腊字母）即 $A(\alpha), T(\tau)$；</li>
<li>结构 $\S 2.2$，大写德文字母。</li>
</ul>
<p>以上都是语法概念，与语义无关。</p>
<h3 id="教材-S-2-2-真值与模型">教材 $\S 2.2$ 真值与模型</h3>
<p>一阶语言的结构 $\A$ 是一个函数，把一些语法上的符号映射到有实际意义的元素。</p>
<p>形式上，一阶语言的一个结构是一个函数，其定义域为参数的集合，且满足以下条件：</p>
<ol>
<li>全称量词 $\forall$：指派一个非空集合 $|\A|$，称为 $\A$ 的论域（universe）（或者定义域（domain））。</li>
<li>n 元谓词符号 $P$：指派一个 n 元关系，$ P^\A \subseteq |\A|^n $，即 $P^\A$ 是 P 上一个 n 元组的集合。</li>
<li>常数符号 $c$：指派一个论域 $|\A|$ 中的元素 $c^\A$。</li>
<li>n 元函数符号 $f$：指派一个 $|\A|$ 上的 n 元运算 $f^{\A}$，即 $f^\A : |\A|^n \rightarrow |\A|$。</li>
</ol>
<p>例如，数论结构（$\S 3$） $\A = (\mathbb{N}; \0, \bfS, &lt; ,+ ,\cdot, E)$。其中 $|\A| = \mathbb{N}$。</p>
<p>若句子 $\sigma$ 在 $\A$ 中为真，则称 $\A$ 是 $\sigma$ 的一个模型，记为 $\models_\A \sigma$。注意，中文版教材中将该公式写成了 $\models \A \sigma$，这是错误的。</p>
<p>对于结构 $\A$，函数 $s : V \to |\A|$ 满足合式公式 $\varphi$ 记为 $\models_\A \varphi[s]$。这一定义可以扩充到项：$s: T \to |\A|$，含义相似，下图是一个一元函数的交换图（commutative graph）。</p>
<p>$$
\begin{array}{ccc}
T &amp; \xrightarrow{\bar{s}} &amp; |\mathfrak{A}| \
\mathcal{F}_f \downarrow  &amp;  &amp; \downarrow{f^\mathfrak{A}} \
T &amp; \xrightarrow{\bar{s}} &amp;  |\mathfrak{A}|
\end{array}
$$</p>
<p>一阶逻辑中全程量词的语义解释：对于合式公式 $\varphi$，$\models_\A \forall x \varphi[s]$ 当且仅当对每个 $\forall d \in |\A|.\models_\A \varphi[s(x|d)]$。其中 $s(x|d)$ 是一个函数，其取值在变量 $x$ 处为 $d$，其他曲直与 $s$ 相同。这一定义相当于把全称量词 $\forall$ 从 $\models_\A$ 右侧转移到了左侧，常用于证明带全称量词的命题。</p>
<p>习题 3：证明：$\set{\forall x(\alpha \to \beta), \forall x\alpha} \models \forall x \beta$</p>
<blockquote>
<p>证明：对每个结构 $\A$ 和每个函数 $s: V \to | \A |$，有 $\models_\A \forall x(\alpha \to \beta)[s]$ 和 $\models_\A \forall x \alpha[s]$，即 $\models_\A \forall x((\alpha \to \beta) \land \alpha)[s]$。因此</p>
<p>$$
\models_\A \forall x((\alpha \to \beta) \land \alpha)[s] \
\iff \forall d \in \A. \models_\A((\alpha \to \beta) \land \alpha)[s(x|d)] \
\iff \forall d \in \A. \models_\A(\beta \land \alpha)[s(x|d)] \
\iff \models_\A \forall x(\beta \land \alpha)[s] \
\iff \models_\A \forall x(\beta)[s] \land \models_\A \forall x(\alpha)[s] \
$$</p>
<p>$Q.E.D.$</p>
</blockquote>
<h4 id="教材-S-2-2-1-逻辑蕴涵">教材 $\S 2.2.1$ 逻辑蕴涵</h4>
<p>合式公式集合 $\Gamma$ 逻辑蕴含合式公式 $\varphi$ 记作 $\Gamma \models \varphi$，当且仅当对语言中的每个结构 $\A$ 和每个函数 $s: V \to |\A|$，使得 $\A$ 以 $s$ 满足 $\Gamma$ 的每个元素时，也满足 $\varphi$。</p>
<p>$\models$ 在命题逻辑中（$\S 1.2$）表示重言蕴含，在一阶语言中表示逻辑蕴含。逻辑蕴涵的其他记法与重言蕴含相似，不再赘述。</p>
<p>下面这段话来自教材，对我们理解定义非常重要：</p>
<blockquote>
<p>逻辑蕴涵的定义与第 1 章中的重言蕴涵非常相似，但是其复杂性却大大不同。在命题逻辑中想要判定一个合式公式是否是重言式，只需要考虑<strong>有限个真值指派</strong>，其中每一个都是有限函数。对每个真值指派，只要计算 $\v(\alpha)$，这可以在有限长的时间内完成。（如前所述，<strong>重言式的集合是可以判定的</strong>）</p>
<p>与之相反，如果要判定一阶语言中的合式公式是否恒真，则需要考虑<strong>每一个结构 $\mathfrak{A}$</strong>。（特别地，这需要使用每个非空集合，而每个集合都有很多元素）对于每个结构，还要考虑每个从变量集合 $V$ 到 $|\mathfrak{A}|$ 的函数 $s$。并且对每一个给定的结构 $\mathfrak{A}$ 和 $s$，还需要判定 $\mathfrak{A}$ 是否以 $s$ 满足 $\varphi$。如果 $|\mathfrak{A}|$ 是无限的，其本身就是一个非常复杂的概念。</p>
<p>考虑到这些复杂性，恒真公式集的无法判定性就不足为怪了（$\S 3.5$）。奇怪的是，可以证明恒真性的概念与另外一个概念（可推导性）是等价的，这个概念更接近有限性（$\S 2.4$）。利用这个等价，在某些推理假设下，可以证明恒真集（恒真合式公式的集合）事实上是可数的。由这个可数的性质可以得到恒真公式集的一个更具体的特性。</p>
</blockquote>
<p>习题 4：证明：如果 $x$ 在 $\alpha$ 中不是自由出现的，那么 $\alpha \models \forall x \alpha$。</p>
<blockquote>
<p>证明：对每个结构 $\A$ 和每个函数 $s: V \to | \A |$，由定理 22A，有：</p>
<p>$$
\models_\A\forall x \alpha[s] \iff \forall d \in |\A|. \models_\A \alpha[s(x|d)] \
\iff \models_\A \alpha[s] \
$$</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 9：设语言具有相等和二元谓词符号 $P$。对下面的条件中的每一个，找出一个句子 $\sigma$ 使得结构 $\A$ 是 $\sigma$ 的模型，当且仅当条件被满足。</p>
<p>（a）$|\A|$ 中恰好有两个元素</p>
<blockquote>
<p>下面的句子 $\sigma$ 满足要求：</p>
<p>$$
\exists x \exists y x \neq y \land (\forall z y = z \lor x = z)
$$</p>
<p>该句子用自然语言描述，即集合中存在至少两个不相等的元素，且任意三个元素中都至少有两个相等，因此集合中只存在两个不相等的元素。</p>
</blockquote>
<h4 id="教材-S-2-2-2-可定义性">教材 $\S 2.2.2$ 可定义性</h4>
<p>习题 11：给出能够在 $(\mathbb{N}; +, \cdot )$ 中定义如下每个关系/集合的公式，假设语言具有相等符号和参数 $\forall, +, \cdot$。</p>
<p>（a）$\set{0}$</p>
<p>（b）$\set{1}$</p>
<p>（c）$\set{\langle m, n\rangle | n 是 \mathbb{N} 中 m 的后继}$</p>
<p>（d）$\set{\langle m, n\rangle | 在 \mathbb{N} 中 m &lt; n}$</p>
<blockquote>
<p>（a）$\forall x y \cdot x = y$</p>
<p>（b）$\forall x y \cdot x = x$</p>
<p>（c）$\exists x (n = m + x \land \forall y x \cdot y = y)$ 即 $n = m + 1$</p>
<p>（d）$\exists x (n = m + x \land \exists y x \cdot y \ne x)$ 即 $n=m+x \land x \neq 0$</p>
</blockquote>
<p>习题 13（不考）：证明同态定理的（a）。</p>
<p>设 $h$ 是从 $\A$ 到 $\B$ 中的同态，$s$ 将变量的集合映射到 $|\A|$ 中。</p>
<p>（a）对每个项 $t$，我们有 $h(\overline{s}(t)) = \overline{h \circ s}(t)$，其中 $\overline{s}(t)$ 是在 $\A$ 中计算的，而 $\overline{h \circ s}(t)$ 是在 $\B$ 中计算的；</p>
<blockquote>
<p>影印版教材中同态定理的横线印刷不清晰，本题中的表述是正确的。</p>
<p>证明：对于常量 $c$，$h(\overline{s}(c)) = h(c^\A) = c^\B = \overline{h \circ s}(c)$；</p>
<p>对于变量 $x$，$h(\overline{s}(t)) = h(s(x)) = h \circ s(x) = \overline{h \circ s}(x)$；</p>
<p>对于 $n$ 元函数函数 $f$，按照归纳，</p>
<p>$$
h(\overline{s}(f t_1 \dots t_n)) = h(f^\A(\overline s(t_1), \dots, \overline s(t_n))) \
= f^\B(h(\overline{s}(t_1)), \dots, h(\overline{s}(t_n))) \
= f^\B(\overline{h \circ s}(t_1), \dots, \overline{h \circ s}(t_n)) \
= \overline{h \circ s}(ft_1 \dots t_n)
$$</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 18：全称公式 ($\forall_1$) 是形式为 $\forall x_1 \cdots x_n \theta$ 的公式，存在公式 ($\exists_1$) 是形式为 $\exists x_1 \cdots x_n \theta$ 的公式，其中 $\theta$ 是无量词。设 $\A$ 是 $\B$ 的子结构，$ s: V \rightarrow |\A|$。</p>
<p>（a）证明：如果 $\vDash_\A \psi[s]$ 且 $\psi$ 是存在公式，那么 $\vDash_\B \psi[s]$。如果 $\vDash_\B \varphi[s]$ 且 $\varphi$ 是全称公式，那么 $\vDash_\A \varphi[s]$。</p>
<p>说明：（a）的意思是（当 $\varphi$ 是句子时）任何全称句子 $\varphi$ 在子结构中都可以保持。由于全称是语法性质，其必定与符号串相关。反过来，在子结构中保持则是语义性质，其必定与结构相关。但是这一语义性质保持了逻辑等价的语法性质（这正是我们所需要的）。即，如果句子 $\sigma$ 在子结构中总是成立，那么 $\sigma$ 逻辑等价于全称句子（这一点要归功于洛斯和塔斯基）。</p>
<blockquote>
<p>证明：本题的证明过程要用到一阶逻辑的全称量词语义解释，以及与之相似的一阶逻辑的存在量词语义解释。后者并没有在教材中提到。</p>
<p>我们假设 $\vDash_{\B} \forall x_{1} \dots \forall x_{n} \theta [s] $，于是对于每个 $d_1, \dots, d_n \in |\B|$，$\vDash_\B \theta[s(x_i|d_i)_{i=1}^n]$。</p>
<p>这意味着，对于每个 $d_1, \dots, d_n \in |\A|$，$\vDash_\B \theta[s(x_i|d_i)<em>{i=1}^n]$。因此，对每个 $d_1, \dots, d_n \in |\A|$，$\vDash</em>\A \theta[s(x_i|d_i)<em>{i=1}^n]$。等价地，$\vDash</em>\A \forall x_1 \dots \forall x_n \theta [s]$。</p>
<p>用同样的证明方法，我们假设 $\vDash_\A \exists x_1 \dots \exists x_n \theta [s]$，则存在 $d_1, \dots, d_n \in |\A|$，$\vDash_\A \theta[s(x_i|d_i)<em>{i=1}^n]$。进而存在 $d_1, \dots, d_n \in |\B|$，$\vDash</em>\B \theta[s(x_i|d_i)<em>{i=1}^n]$。可推出 $\vDash</em>\B \exists x_1 \dots \exists x_n \theta [s]$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 20：设语言有等号和二元谓词符号 $P$。考虑两个结构 $(\mathbb{N}, &lt;), (\mathbb{R}, &lt;)$。</p>
<p>（a）试找出一个句子，它在一个结构中是真的，在另外一个中是假的。</p>
<blockquote>
<p>直观来说，$(\mathbb{N}, &lt;)$ 中存在“相邻”的两个数而 $(\mathbb{R},&lt;)$ 中不存在。“相邻”可以被形式化描述为“这两个数之间没有其他的数”。我们使用公式来表达这一性质：</p>
<p>$$
\forall x \exists y (x &lt; y \land \forall z ( \lnot(x &lt; z \land z &lt; y)))
$$</p>
</blockquote>
<p>习题 22：设 $\A$ 是结构且 $h$ 是函数，$\ran \ h = |\A|$。证明存在结构 $\B$ 使得 $h$ 是一个从 $\B$ 到 $\A$ 上的同态。提示：取 $|\B| = \dom \ h$。一般地，需要使用选择公理在 $\B$ 中定义函数，除非 $h$ 是一对一的。</p>
<blockquote>
<p>证明：取 $|\B| = \ran \ h$，则 $h:|\B| \to |\A|$ 是满射。对每个 $a \in \A$，使用选择公理定义 $G(a) = \set{b \in |\B| \mid h(b) = a}$，定义 $g(a)$ 为 $G(a)$ 中的任意一个元素（例如，某个全序下的最小元素）。接下来，我们可以根据对同态的定义构造 $\B$ 中的谓词参数、常数符号函数符号对应的元素：</p>
<p>$$
\langle b_1, \dots, b_n\rangle \in P^\B \iff \langle h(b_1), \dots, h(b_n)\rangle \in P^\A \
c^\B = g(c^\A) \
f^\B(b_1, \dots, b_n) = g(f^\A(h(b_1), \dots, h(b_n)))
$$</p>
<p>以上定义的 $\B$ 显然使得 $h$ 为同态。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-2-3-解析算法">教材 $\S 2.3$ 解析算法</h3>
<p>项是通过符号函数对变量和常数的运算得到的。定义符号函数 $K$，使得对符号 $s$，$K(s) = 1 - n$，其中 $n$ 是项的个数。</p>
<p>$$
K(x) = 1 - 0 = 1, \text{ 对变量 } x; \
K(c) = 1 - 0 = 1, \text{ 对常数符号 } c; \
K(f) = 1 - n, \text{ 对 } n \text{ 元函数符号 } f
$$</p>
<p>通过如下方式将 $K$ 扩充到表达式的集合</p>
<p>$$
K(s_1 s_2 \cdots s_n) = K(s_1) + K(s_2) + \cdots + K(s_n).
$$</p>
<p>习题 1：对于合式公式 $\alpha$ 的任意真的初始段 $\alpha'$，$K(\alpha) &lt; 1$。</p>
<blockquote>
<p>证明：对波兰记法下的 $\alpha$ 使用归纳法。</p>
<ol>
<li>若 $\alpha = (\lnot \beta)$，有以下几种情况：
<ul>
<li>$\alpha' = ($，$K(\alpha') = -1$</li>
<li>$\alpha' = (\lnot$，$K(\alpha') = 0$</li>
<li>$\alpha' = (\lnot \beta'$，$K(\alpha') \le -1$</li>
<li>$\alpha' = (\lnot \beta$，$K(\alpha') = -1$</li>
</ul>
</li>
<li>若 $\alpha = (\beta \land \gamma)$，有以下几种情况：
<ul>
<li>$\alpha' = ($，$K(\alpha') = -1$</li>
<li>$\alpha' = (\beta'$，$K(\alpha') \le -1$</li>
<li>$\alpha' = (\beta$，$K(\alpha') = 0$</li>
<li>$\alpha' = (\beta \land$，$K(\alpha') = -1$</li>
<li>$\alpha' = (\beta \land \gamma'$，$K(\alpha') \le -1$</li>
<li>$\alpha' = (\beta \land \gamma$，$K(\alpha') \le 0$</li>
</ul>
</li>
</ol>
<p>因此，总有 $K(\alpha') \le 0$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2：设 $\varepsilon$ 是包含变量、常数符号和函数符号的表达式。证明：$\varepsilon$ 是项当且仅当 $K(\varepsilon) = 1$ 且对 $\varepsilon$ 的任意终段 $\varepsilon'$，我们有 $K(\varepsilon') &gt; 0$。提示：证明更强一些的结果：如果对 $\varepsilon$ 的任意终段 $\varepsilon'$，$K(\varepsilon') &gt; 0$，那么 $\varepsilon$ 是 $K(\varepsilon)$ 个项的连接。</p>
<blockquote>
<p>证明：先证充分性。由引理 23A，$K(\varepsilon) = 1$。由引理 23B，对 $\varepsilon$ 的任意终段 $\varepsilon'$，我们有 $K(\varepsilon') &gt; 0$。</p>
<p>再证必要性。</p>
<p>对 $\varepsilon$ 归纳。若 $\varepsilon$ 长度为 1，则为变量或常数符号，命题显然成立。</p>
<p>若 $\varepsilon$ 长度超过 1，由 $K(\varepsilon) = 1$ 且对 $\varepsilon$ 的任意终段 $\varepsilon'$，$K(\varepsilon') &gt; 0$，可知必然存在至少一个 $n$ 元函数符号 $f$。</p>
<p>若只存在一个 $n$ 元函数符号 $f$，则由 $K(\varepsilon) = 1$ 知 $\varepsilon$ 中必然存在 $n$ 个变量或常数符号，由 $K(\varepsilon') \ge 1$ 知这些变量符号必然都出现在 $\varepsilon$ 右端。命题成立。</p>
<p>对 $\varepsilon$ 中函数符号的个数归纳，由 $K(\varepsilon) = 1$ 且对 $\varepsilon$ 的任意终段 $\varepsilon'$，$K(\varepsilon') &gt; 0$，可知 $\varepsilon$ 必然以 $n$ 元函数符号开始，且函数符号后恰好有 $n$ 项。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-2-4-演绎计算">教材 $\S 2.4$ 演绎计算</h3>
<h4 id="教材-S-2-4-1-形式演绎">教材 $\S 2.4.1$ 形式演绎</h4>
<p>假言推理（Modus Ponen，又称 MP 规则或直言三段论）：</p>
<p>$$
\frac{\alpha, \alpha \to \beta}{\beta}
$$</p>
<p>$\Lambda$ 是 6 组逻辑公理的集合：</p>
<ol>
<li>重言式；</li>
<li>去掉全称量词：$\forall x \alpha \to \alpha^x_t$，其中 $t$ 是 $x$ 在 $\alpha$ 中的替换，即把 $\alpha$ 中出现的 $x$ 换成 $t$；</li>
<li>全称量词右移：$\forall x (\alpha \to \beta) \to (\forall x \alpha \to \forall x \beta)$；</li>
<li>添加全称量词：$\alpha \to \forall x \alpha$，其中 $x$ 在 $\alpha$ 中不是自由出现的（自由出现的意思是无量词限定，例如 $\forall y x + y = 2$ 中 $x$ 是自由出现的，$y$ 不是）；</li>
<li>$x=x$；</li>
<li>$x = y \to (\alpha \to \alpha')$，其中 $\alpha$ 是原子的，$\alpha'$ 是有限次的将 $\alpha$ 中的 $x$ 替换为 $y$ 得到的。</li>
</ol>
<h4 id="教材-S-2-4-2-替换">教材 $\S 2.4.2$ 替换</h4>
<p>对原子公式 $\alpha$，$\alpha_t^x$ 是将 $\alpha$ 中自由出现的变量 $x$ 都替换为 $t$ 所得到的表达式。</p>
<p>$$
(\forall y \alpha)_t^x = \left{\begin{matrix}
\forall y \alpha \text{ if } x = y \
\forall y (\alpha_t^x) \text{ if } x \ne y \
\end{matrix}\right.
$$</p>
<p>上述定义的含义为，如果待替换的变量不是自由出现的，例如被全称量词限定的 $y$，则不执行替换。</p>
<h4 id="教材-S-2-4-4-演绎与元定理">教材 $\S 2.4.4$ 演绎与元定理</h4>
<p>由 $\Gamma \cup \Lambda$ 和假言推理可以获得的公式集叫做 $\Gamma$ 的定理集合。</p>
<p>概化定理（添加全称量词）：如果 $\Gamma \vdash \varphi$ 且 $x$ 不在 $\Gamma$ 的任何公式中自由出现，则 $\Gamma \vdash \forall x \varphi$。</p>
<p>规则 T：如果 $\Gamma \vdash \alpha_1, \dots, \Gamma \vdash \alpha_n$，且 $\set{\alpha_1, \dots, \alpha_n}$ 重言蕴含 $\beta$ ，那么 $\Gamma \vdash \beta$。</p>
<p>演绎定理：如果 $\Gamma;\gamma \vdash \varphi$，那么 $\Gamma \vdash (\gamma \to \varphi)$。从右到左叫做演绎，从左到右叫演绎定理。</p>
<p>习题 3：（a）设 $\A$ 是结构，且令 $s:V \to |\A|$，在基本公式集上定义真值指派 $v$ 如下：</p>
<p>$$
v(\alpha) = T \iff \models_\A \alpha[s]
$$</p>
<p>证明：对于任意公式（基本与否均可），有：</p>
<p>$$
\overline{v}(\alpha) = T \iff \models_\A \alpha[s]
$$</p>
<p>（b）证明：如果 $\Gamma$ 重言蕴含 $\varphi$，则 $\Gamma$ 逻辑蕴涵 $\varphi$。</p>
<blockquote>
<p>（a）证明：使用归纳法证明。对于基本公式 $\alpha$，$\overline{v}(\alpha) = v(\alpha) = T \iff \models_\A \alpha[s]$。</p>
<p>对于公式 $\lnot \alpha$，$\overline{v}(\alpha) = T \iff \overline{v}(\alpha) = F \iff \not \models_\A \alpha[s] \iff \models_\A \lnot \alpha[s]$。</p>
<p>对于公式 $\beta \to \alpha$，$\overline{v}(\beta \to \alpha) = T \iff \overline{v}(\beta) = F \lor \overline{v}(\alpha) = T \iff \models_\A \lnot \beta[s] \lor \models_\A \alpha[s] \iff \models \beta \to \alpha [s]$。</p>
<p>$Q.E.D.$</p>
<p>（b）证明：$\Gamma$ 重言蕴含 $\varphi$，意味着对每个结构 $\A$，若对于每个 $\alpha \in \Gamma$，$\overline{v}(\alpha) = T$，有 $\overline{v}(\varphi) = T$。</p>
<p>因此，对每个结构 $\A$ 和 $s:V \to |\A|$，若对每个 $\alpha \in \Gamma$，都有 $\models_\A \alpha[s]$，则 $\models_\A \varphi[s]$。因此，$\Gamma \models \varphi$。</p>
<p>上述证明实际上展示了“语法上的重言蕴含为什么在逻辑语义上是对的”。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 8：设 $x$ 不在 $\alpha$ 中自由出现，证明 Q2b</p>
<p>$$
\vdash (\alpha \to \exists x \beta) \leftrightarrow \exists x (\alpha \to \beta)
$$</p>
<p>在同样的假设下，证明 Q3a：</p>
<p>$$
\vdash (\forall x \beta \to \alpha) \leftrightarrow \exists x (\beta \to \alpha)
$$</p>
<blockquote>
<p>TODO：回头再看。</p>
<p>证明 Q2b：由规则 T，需要证明 $\vdash (\alpha \to \exists x \beta) \rightarrow \exists x (\alpha \to \beta)$ 和 $\vdash (\alpha \to \exists x \beta) \leftarrow \exists x (\alpha \to \beta)$。</p>
<p>通过推导、反证法和假言推理，我们可以得到第一个公式等价于 $\forall x (\alpha \rightarrow \beta) \vdash \neg (\alpha \rightarrow \exists x \beta)$。现在，根据第 2 组公理和假言推理，我们有 $\forall x (\alpha \rightarrow \beta) \vdash \neg (\alpha \rightarrow \beta)$。此外，$\neg (\alpha \rightarrow \beta) \rightarrow \alpha$ 和 $\neg (\alpha \rightarrow \beta) \rightarrow \neg \beta$ 都是重言式。通过假言推理，我们得到 $\forall x (\alpha \rightarrow \beta) \vdash \alpha$ 和 $\forall x (\alpha \rightarrow \beta) \vdash \neg \beta $。根据推广定理，$ \forall x (\alpha \rightarrow \beta)$ 重言蕴含 $\neg (\alpha \rightarrow \exists x \beta)$，根据规则 T，我们得到了需要的结果。</p>
<p>通过推导、反证法和假言推理，我们可以得到第二个公式等价于 $\neg (\alpha \rightarrow \exists x \beta) \vdash \forall x (\alpha \rightarrow \beta)$。对于这个公式，基于推广定理并假设 $x$ 没有自由出现在 $\alpha$ 中，我们只需证明 $\neg (\alpha \rightarrow \exists x \beta) \vdash \neg (\alpha \rightarrow \beta)$，而通过反证法、推导和假言推理，它等价于 $\set{ \alpha, \neg \beta } \vdash \exists x \beta $。通过假言推理，我们只需证明 $\beta \vdash \exists x \beta $，或者通过推导 $\beta \vdash \exists x \beta $，或者通过反证法和假言推理，得到 $\forall x \neg \beta \vdash \neg \beta $，这是第 2 组公理的一项。</p>
<p>通过将 $\neg \alpha$ 替换为 $\alpha$ ，将 $\neg \beta$ 替换为 $\beta $，并使用反证法的重言式等价性，我们得到 $\vdash (\forall x \beta \rightarrow \alpha) \leftrightarrow \exists x (\beta \rightarrow \alpha)$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 9：（再替换引理）（a）试证： $(\varphi_y^x)^y_x$ 与 $\varphi$ 一般不相等，而且以下两种情况均有可能发生：$x$ 在 $(\varphi_y^x)_x^y$ 中的某个位置上出现，而在 $\varphi$ 中同样的位置上不出现；或者反过来，$x$ 在 $\varphi$ 中的某个位置上出现，而在 $(\varphi_y^x)_x^y$ 中同样的位置上不出现。</p>
<p>（b）证明：如果 $y$ 不在 $\varphi$ 中出现，那么在 $\varphi_y^x$ 和 $(\varphi_y^x)_x^y = \varphi$ 中 $x$ 可替换 $y$。提示：对 $y$ 使用归纳法。</p>
<blockquote>
<p>本题中证明会使用替换的定义（4）</p>
<p>（a）证明：如果 $\varphi = \forall yx$，则 $(\varphi_y^x)^y_x = \forall yy$，此时 $x$ 在 $(\varphi_y^x)_x^y$ 中同样的位置上不出现。</p>
<p>如果 $\varphi = \forall xy$，则 $(\varphi_y^x)^y_x = \forall xx$，此时 $x$ 在 $\varphi$ 中同样的位置上不出现。</p>
<p>$Q.E.D.$</p>
<p>TODO：再看看（b）</p>
<p>（b）证明：如建议的那样，我们通过归纳法证明该陈述。对于变量或常量符号 $z \neq y $，如果 $z \neq x $，则 $\varphi^z_y = (\varphi^y_x)^y_x = z $，否则 $\varphi^z_y = y$ 且 $(\varphi^y_x)^y_x = x = z $。对于不包含 $y$ 的项 $t = f_i t_1 \ldots t_n $，通过归纳，$(t^y_x)^y_x = f_i ((t_1)^y_x)^y_x \ldots ((t_n)^y_x)^y_x = f_i t_1 \ldots t_n = t$。同样，对于不包含 $y$ 的原子公式 $\varphi = Pt_1 \ldots t_n$，通过归纳，$(\varphi^y_x)^y_x = P((t_1)^y_x)^y_x \ldots ((t_n)^y_x)^y_x = \varphi$（并且 $x$ 可以替代 $y$ 因为后者也是一个原子公式）。</p>
<p>此外，根据定义和归纳，如果不包含 $y$ 的 $\alpha$ 和 $\beta$ 使得 $x$ 可替代 $y$ 在 $\alpha^y_x$ 和 $\beta^y_x$ 中，那么 a)$(\neg \alpha)^y_x = \neg \alpha^y_x$，$x$ 可替代 $y$ 在其中，且 b)$((\alpha \rightarrow \beta)^y_x = \alpha^y_x \rightarrow \beta^y_x $。此外，$ (\forall x \alpha)^y_x = \forall x \alpha$ 不包含任何 $y$，因此 $x$ 不在 $\set{x, y}$ 中，$x$ 不自由出现在其中，$x$ 可替代 $y$ 在其中，且 $((\forall x \alpha)^y_x)^y_x = \forall x(\alpha^y_x)^y_x = \forall x \alpha$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 11：证明 Eq3：</p>
<p>$$
\vdash \forall x \forall y \forall z (x = y \to y = z \to x = z)
$$</p>
<blockquote>
<p>证明：在数理逻辑中，$\to$ 运算符具有右结合性，即 $\alpha \to \beta \to \gamma$ 的含义是 $\alpha \to (\beta \to \gamma)$。本题的表达中不使用括号。</p>
<p>根据泛化定理，我们只需证明 $\vdash x = y \rightarrow y = z \rightarrow x = z $。根据公理组 5，我们有 $\vdash x = x $。根据公理组 6，我们有 $\vdash x = y \rightarrow x = x \rightarrow y = x$ 和 $\vdash y = x \rightarrow y = z \rightarrow x = z $。前两个式子根据规则 T 可以推出 $\vdash x = y \rightarrow y = x $，再结合第三个式子并再次应用规则 T，可以推出 $\vdash x = y \rightarrow y = z \rightarrow x = z$。</p>
<p>$Q.E.D.$</p>
<p>另一种基于命题逻辑（而不是一阶逻辑）的证明：</p>
<p>$$
\vdash \forall x \forall y \forall z (x = y \to y = z \to x = z) \
\iff \vdash \forall x \forall y \forall z (x \ne y \lor (y \ne z \lor x = z)) \
\iff \vdash \forall x \forall y \forall z (x \ne y \lor \lnot(y = z \land x \ne z)) \
\iff \vdash \forall x \forall y \forall z \lnot(x = y \land y = z \land x \ne z)
$$</p>
<p>其中 $\ne$ 就是 $=$ 的否定。由于相等关系（或者逻辑上的相等）的传递性，$\lnot(x = y \land y = z \land x \ne z)$ 为重言式。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-2-5-可靠性与完备性理论">教材 $\S 2.5$ 可靠性与完备性理论</h3>
<p>可靠性定理：如果 $\Gamma \vdash \varphi$，那么 $\Gamma \models \varphi$。</p>
<p>引理 25A：逻辑公理都是恒真的。</p>
<p>完备性定理（哥德尔 1930）：</p>
<ol>
<li>如果 $\Gamma \models \varphi$，那么 $\Gamma \vdash \varphi$。</li>
<li>任意和谐的公式集都是可满足的。</li>
</ol>
<p>紧致性定理：</p>
<ol>
<li>如果 $\Gamma \vdash \varphi$，那么存在某个有限的 $\Gamma_0 \subseteq \Gamma$，有 $\Gamma_0 \vdash \varphi$。</li>
<li>如果 $\Gamma$ 的每个有限子集 $\Gamma_0$ 都是可满足的，那么 $\Gamma$ 是可满足的。特别地，句子集 $\Sigma$ 有模型当且仅当其每个有限子集有模型。</li>
</ol>
<p>可枚举定理：</p>
<p>对合理的语言，恒真（valid）合式公式的集合是能行可枚举的。</p>
<p>定理 26A：如果句子集合 $\Sigma$ 有任意大的计数的有限模型，那么就有一个无限模型。</p>
<p>定理 26C：对有限语言中的有限结构 $\A$，$\Th \ \A$ 是可判定的。</p>
<p>习题 1：（语义规则 EI）假设常数符号 $c$ 不在 $\varphi$、$\psi$ 和 $\Gamma$ 中出现，$\Gamma; \varphi_c^x \models \psi$，证明：$\Gamma; \exists x \varphi \models \psi$。（不使用可靠性定理和完备性定理。）</p>
<blockquote>
<p>该规则将推论 24H 中的 $\vdash$ 换成了 $\models$，该题应该从语义方面证明而不是从语法方面。</p>
<p>证明：$\Gamma ; \varphi^{x}<em>c \models \psi \iff$ 对任意 $\A$ 和 $s$，如果 $\models</em>{\A} \Gamma[s]$ 且 $\models_{\A} \varphi^{x}<em>{c}[s]$，则 $\models</em>{\A} \psi[s]$；</p>
<p>$\iff$ 对任意 $\A$ 和 $s$，如果 $\models_{\A} \Gamma[s]$ 且 $\models_{\A} \varphi[s(x\mid c^\A)]$，则 $\models_{\A} \psi[s]$；</p>
<p>$\iff$ 对任意 $\A$ 和 $s$，如果 $\models_{\A} \Gamma[s]$ 且 $\models_{\A} \exists x \varphi$，则 $\models_{\A} \psi[s]$；</p>
<p>$\iff \Gamma; \exists x \varphi \models \psi$；</p>
<p>上述证明完成了“在 $\A$ 中把 $x$ 替换成 $c^\A$” 这件事。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2（不考）：证明完备性定理（a）与（b）等价。提示：$\Gamma \vdash \varphi$ 当且仅当 $\Gamma \cup \set{\neg \varphi}$ 是不可满足的，且 $\Delta$ 是可满足的当且仅当 $\Delta \nvDash \bot$，其中 $\Delta$ 是某个不可满足的、可批驳的公式集，如 $\neg \forall x x = x$。</p>
<p>说明：类似地，可靠性定理也适用于每个可满足的公式集是和谐的。</p>
<blockquote>
<p>证明：在计算机学科中，consistent 被翻译为“一致的”。</p>
<p>先证充分性。若（a）成立。若 $\Gamma$ 不可满足，则 $\Gamma \models \set{\phi, \lnot \phi}$，因此 $\Gamma \vdash \set{\phi, \lnot \phi}$，即 $\Gamma$ 不和谐。推出（b）的逆否命题。</p>
<p>再证必要性。若（b）成立。若 $\Gamma \models \phi$，则对任意 $\A, s$，$\models_\A \Gamma[s] \implies \models_\A \phi[s]$ 即 $\not\models_\A \lnot\phi[s]$。即 $\Gamma ; \lnot \phi$ 是不可满足的，也因此是不和谐的。导出矛盾，因此 $\Gamma \vdash \phi$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 3：设 $\Gamma \vdash \varphi$，且 $P$ 是不在 $\Gamma$ 和 $\varphi$ 中出现的谓词符号。是否存在不出现 $P$ 的从 $\Gamma$ 到 $\varphi$ 的演绎？提示：这个问题有两种不同的方法。“软”方法使用两个不同的语言，一个含有 $P$，另一个不含 $P$；“硬”方法则考虑是否能够可以从 $\Gamma$ 到 $\varphi$ 的演绎中消去 $P$。</p>
<blockquote>
<p>必然存在不出现 $P$ 的从 $\Gamma$ 到 $\varphi$ 的演绎。</p>
<p>证明：使用“软”方法完成证明。</p>
<p>对于一个不含 $P$ 的语言，在该语言中 $\Gamma \vdash \varphi$，存在不出现 $P$ 的从 $\Gamma$ 到 $\varphi$ 的演绎，设该演绎为 $q$。对于包含 $P$ 的语言，$q$ 同样是该语言中一个从 $\Gamma$ 到 $\varphi$ 的演绎。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 4：设 $\Gamma = \set{ \neg \forall v_1 Pv_1, Pv_2, Pv_3, \dots}$，$\Gamma$ 是否和谐？是否可满足？</p>
<blockquote>
<p>证明：假设 $\A = (\set{0,1};P)$，其中 $P^\A = \set{\langle 1 \rangle}$，且构造 $s :V \to |\A|$ 使得 $\forall i&gt;0.s(v_i) = 1$。于是 $\models_\A Pv_i[s], \models_\A P v_1[s(v_1|1)]$ 并且 $\not\models_\A P v_1[s(v_1|0)]$。</p>
<p>因此 $\Gamma$ 可满足。由可靠性和完备性定理得，$\Gamma$ 是和谐的。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-2-6-理论的模型">教材 $\S 2.6$ 理论的模型</h3>
<p>理论是逻辑蕴涵意义下封闭的句子集合，$T$ 是一个理论当且仅当 $T$ 是一些句子的集合，该集合使得语言中的任意句子 $\sigma$，</p>
<p>$$
T \models \sigma \Rightarrow \sigma \in T
$$</p>
<p>注意：我们仅指句子，而不是带有自由变量的公式。</p>
<p>对语言的结构类 $\K$，定义其理论为（记作 $\Th \ \K$）</p>
<p>$$
\Th \ \K = \set{ \sigma | \sigma \ 在 \ \K \ 的每个元素中都是真的}
$$</p>
<p>这一概念由先前的特殊情况 $\K = \set{\A}$ 而来。</p>
<p>对于句子集合 $\Sigma$，定义 $\Mod \ \Sigma$ 为 $\Sigma$ 所有模型的类。$\Th \ \Mod \ \Sigma$ 则是在 $\Sigma$ 的所有模型中都是真的的所有句子的集合。称此集合为 $\Sigma$ 的推论集，记作 $\Cn \ \Sigma$，这样</p>
<p>$$
\Cn \Sigma = \set{\sigma | \Sigma \models \sigma} \
= \Th \ \Mod \ \Sigma
$$</p>
<p>一个句子集合是一个理论当且仅当 $T = \Cn \ T$。</p>
<p>一个理论 $T$ 称为完备的，当且仅当对每个句子 $\sigma$，或者 $\sigma \in T$，或者 $(\lnot \sigma) \in T$，</p>
<p>理论 $T$ 是有限可公理化的当且仅当对于某个有限句子集合 $\Sigma$，$T = \Cn\ \Sigma$。</p>
<p>习题 1（不考）：证明下述句子是有限恒真的（即在每个有限结构中是真的）：</p>
<p>$$
(a) \exists x \exists y \exists z [(Pxf x \rightarrow Pxx) \lor (Pxy \land Pyz \land \lnot Pxz)]
$$</p>
<p><strong>提示</strong>：这些句子的逆的任意模型都是无限的。</p>
<blockquote>
<p>证明：题中的 negation 在计算机科学中一般被翻译为“否定”而不是“逆”。</p>
<p>题中公式的含义是，在论域中存在一个 $x$，使得 $Pxfx \rightarrow Pxx$ 或者“$P$ 在 $x$ 处不传递”。</p>
<p>本题的证明中反复使用了 6 条公理和概化公理。</p>
<p>我们按照一阶逻辑的规则对句子的逆进行恒等变形：</p>
<p>$$
\neg \exists x \exists y \exists z \big((Pxf x \to Pxx) \lor (Pxy \land Pyz \land \neg Pxz)\big)\
\iff \neg \exists x \exists y \exists z \big[\lnot (Pxf x \to Pxx) \rightarrow (Pxy \land Pyz \land \neg Pxz) \big]\
\iff  \neg \exists x \big[\neg (Pxf x \to Pxx) \rightarrow \exists y \exists z (Pxy \land Pyz \land \neg Pxz \big]\
\iff \forall x \neg \big[\lnot (Pxf x \to Pxx) \rightarrow \exists y \exists z (Pxy \land Pyz \land \neg Pxz) \big]\
\iff \forall x \big[\neg (Pxf x \to Pxx) \land \neg \exists y \exists z (Pxy \land Pyz \land \neg Pxz)\big]\
\iff \forall x \big[Pxf x \land \neg Pxx \land \forall y \forall z (\neg Pxy \lor \neg Pyz \lor Pxz)\big]\
\iff \forall x \big[Pxf x \land \neg Pxx \land \forall y \forall z (Pxy \to (Pyz \to Pxz))\big]
$$</p>
<p>如果 $\A$ 是该句子的模型，我们有：</p>
<p>$$
\Th \ \A \vdash \set{Pxf x; \neg Pxx; \forall y \forall z (Pxy \to Pyz \to Pxz)}
$$</p>
<p>只要证符合上述条件的 $\A$ 必是无限的。</p>
<p>由子集 $\set{Pxfx, \lnot Pxx}$ 可知，$\Th \ \A \vdash \set{x \neq fx}$。由 $Pxfx \vdash \set{Pfxffx, Pffxfffx , \dots}$。由传递性 $\forall y \forall z (Pxy \to Pyz \to Pxz)$ 可知，$\Th \ \A \vdash \set{Pf^nxf^mx}$ 对任意 $0 \le n \lt m$ 都成立。因此，$\A$ 是无限的。</p>
<p>$Q.E.D.$</p>
<p>特别地，$\A = (\mathbb{N};P=&lt;,f=S)$ 即自然数上的后继函数和小于关系是该（a）的逆的一个模型。</p>
</blockquote>
<p>习题 2：设 $T_1$ 和 $T_2$ 是（同一语言的）理论，使得：(i)$T_1 \subseteq T_2$ (ii)$T_1$ 是完备的 (iii)$T_2$ 是可满足的。证明：$T_1 = T_2$。</p>
<blockquote>
<p>证明：对任意句子 $\sigma$，$\sigma \in T_2 \Rightarrow \lnot \sigma \notin T_2 \Rightarrow \lnot \sigma \notin T_1 \Rightarrow \sigma \in T_1$，又 $T_1 \subseteq T_2$，由外延公理，有 $T_1 = T_2$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 5（不考）：给出与如下公式等价的前束公式</p>
<p>$$
(a) (\exists x A x \land \exists x B x) \to Cx
$$</p>
<blockquote>
<p>其前束公式为：</p>
<p>$$
\exists y \exists z ((Ay \land Bz) \to Cx)
$$</p>
</blockquote>
<p>习题 7：考虑带有二元谓词符号 $&lt;$ 的语言，设 $\N = (\mathbb{N}; &lt;)$ 是包含（通常序的）自然数的结构。证明：存在某个初等等价于 $\N$ 的 $\A$，使得 $&lt;^\A$ 具有降序链。（即在 $|\A|$ 中存在 $a_0, a_1, \cdots$，使得对所有 $i$ 有 $\langle a_{i+1}, a_i \rangle \in &lt;^\A$。）</p>
<p>提示：应用紧致性定理。</p>
<p>说明：该习题的目的在于说明在这个语言中无法表达“不存在降序链。”</p>
<blockquote>
<p>证明：构造 $&lt;^\A$：$\langle a^\A, b^\A \rangle \in &lt;^\A$ 当且仅当 $\langle b^\N, a^\N \rangle \in &lt;^\N$。显然 $\A \equiv \N$，且在 $\A$ 中存在 $&lt;^\A$ 的降序链，该降序链 $a_0, a_1, \cdots$ 对应的正是 $\N$ 中的升序链。</p>
<p>$Q.E.D.$</p>
<p>“初等等价”的含义是，两个语言或结构满足完全相同的一阶逻辑公式集，在一阶逻辑的层面上“无法区分”。这道题的论证过程还有些问题，<a target="_blank" rel="noopener" href="https://dbfin.com/logic/enderton/chapter-2/section-2-6-models-of-theories/problem-7-solution/">Section 2.6: Problem 7 Solution | dbFin</a> 提供了本题的一种证明方式，但笔者认为这种证明方式也并不正确，因为其并没有定义 $\A$ 与 $\A_n$ 的关系。</p>
</blockquote>
<p>习题 10：设有一个不带函数符号的有限语言，</p>
<p>（a）（不考）证明：可满足的 $\exists_2$ 句子集是可判定的（术语及相关背景见 2.2 节的习题 19）；</p>
<p>（b）证明：恒真的 $\forall_2$ 句子集是可判定的。（$\forall_2$ 公式是指具有形式 $$\forall x_1 \dots \forall x_m \exists y_1 \dots \exists y_n \theta$$ 的公式，其中 $\theta$ 是无量词的公式。）</p>
<p>说明：在一阶逻辑中，“判定问题”（Entscheidungs 问题）就是在给定一个公式后判定其是否恒真。由于丘奇定理（3.5 节），这一问题通常是无解的。这个习题给出的是判定问题中的一个可解的情形。</p>
<blockquote>
<p>（a）证明：我们知道 $\exists_2$ 句子是可满足的，当且仅当其在一个有限模型内是可满足的。在先前的习题中，我们可以判定它是否有任意模型，即其是否可满足。</p>
<p>（b）证明：$\sigma$ 是一个可行的 $\forall_2$ 句子，当且仅当 $\lnot \sigma$ 是不可满足的。通过 (a)，我们知道它是可判定的。</p>
</blockquote>
<h3 id="教材-S-2-7-理论之间的解释（不考）">教材 $\S 2.7$ 理论之间的解释（不考）</h3>
<p>习题 1：假设 $L_0$ 和 $L_1$ 含有相同参量的语言，但 $L_0$ 中有一个 $n$ 元函数符号 $f$ 不在 $L_1$ 中，同时 $L_1$ 中有一个 $(n + 1)$ 元谓词符号 $P$ 不在 $L_0$ 中。证明对于 $L_0$ 的任意理论 $T$，存在一个忠实解释将 $T$ 解释到 $L_1$ 上。</p>
<blockquote>
<p>证明：简单来说，忠实解释是指能够保持理论 $T$ 中所有公式的真假值不变的解释。</p>
<p>要证明对于 $L_0$ 的任意理论 $T$，存在一个忠实解释将 $T$ 解释到 $L_1$ 上，我们可以通过构造一个从 $L_0$ 到 $L_1$ 的忠实解释来实现。</p>
<p>构造过程：</p>
<ol>
<li>定义解释映射：首先，我们需要定义一个映射，将 $L_0$ 中的项和公式转换为 $L_1$ 中对应的项和公式。对于 $L_0$ 中的项，如果它们不涉及函数符号 $f$，则直接对应到 $L_1$ 中相同的项。对于涉及 $f$ 的项，如 $f(t_1, t_2, ..., t_n)$，我们定义其在 $L_1$ 中的对应项为 $t$，其中 $P(t_1, t_2, ..., t_n, t)$ 成立。这实际上是在说，对于 $L_0$ 中的每一组输入 $t_1, t_2, ..., t_n$，在 $L_1$ 中存在一个输出 $t$，使得 $P$ 关系成立。</li>
<li>定义公式转换：接下来，我们需要定义如何将 $L_0$ 中的公式转换为 $L_1$ 中的公式。对于不涉及 $f$ 的原子公式，可以直接对应到 $L_1$ 中相同的原子公式。对于形如 $f(t_1, t_2, ..., t_n) = s$ 的原子公式，我们将其转换为 $L_1$ 中的公式 $P(t_1, t_2, ..., t_n, s)$。对于复合公式，按照标准的逻辑运算符的转换规则进行转换。</li>
<li>验证忠实性：最后，我们需要验证这个解释是忠实的，即它保持了 $L_0$ 中的所有公式的真假值。这意味着，如果一个公式在 $L_0$ 下是真（或假）的，那么经过解释后，在 $L_1$ 下它也应该保持同样的真假值。这可以通过结构归纳法来证明，首先证明对于原子公式这一点成立，然后逐步扩展到所有复杂的公式。</li>
</ol>
<p>忠实性的证明</p>
<ul>
<li>对于原子公式，如 $f(t_1, t_2, ..., t_n) = s$，在 $L_0$ 下它为真意味着 $f$ 在输入 $t_1, t_2, ..., t_n$ 时确实产生输出 $s$。在 $L_1$ 下，这意味着存在一个元素 $s$ 使得 $P(t_1, t_2, ..., t_n, s)$ 为真，这与原始的原子公式在 $L_0$ 下的意义是一致的。</li>
<li>对于复合公式，忠实性可以通过逻辑运算符的性质和原子公式的忠实性来保证。例如，如果一个合取式在 $L_0$ 下为真，那么它的每个组成部分在 $L_0$ 下也为真，根据忠实性，这些组成部分在 $L_1$ 下也应为真，因此整个合取式在 $L_1$ 下也为真。</li>
</ul>
<p>综上所述，通过这种方式构造的解释是一个忠实的解释，它可以将 $L_0$ 的任意理论 $T$ 解释到 $L_1$ 上，而不会改变公式的真假值。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2：设 $L_0$ 是含有等号及二元函数符号 $+$ 和 $\cdot$ 的语言，$L_1$ 也一样，只不过用三元谓词符号表示加法和乘法。令 $\mathfrak{M}_i = (\mathbb{N};+, \cdot)(i = 0, 1)$ 分别是包含自然数和加法、乘法的语言 $L_i$ 的结构。证明在 $\mathfrak{M}_0$ 中由 $L_0$ 公式定义的任何关系都能在 $\mathfrak{M}_1$ 中由 $L_1$ 公式定义。</p>
<blockquote>
<p>证明：假设非空的 $n$ 元关系 $R$ 可以由 $L_0$ 公式 $\phi$ 在 $\N_0$ 中定义（对于空关系结论显而易见）。</p>
<p>考虑 $\pi$ 从 $L_0$ 参数集到 $L_1$ 公式集中的映射，使得 $\pi_\vee = v_1 = v_1$ ，$\pi_+ = +v_1v_2v_3$ 和 $\pi_\cdot = \cdot v_1v_2v_3$ 。因为 $\exists v_1v = v_1$ ，$\forall v_1\forall v_2\exists x\forall v_3 +v_1v_2v_3 \leftrightarrow v_3 = x$ ，以及 $\forall v_1\forall v_2\exists x\forall v_3 \cdot v_1v_2v_3 \leftrightarrow v_3 = x$ 在 $\N_1$ 中为真，所以 $\pi$ 是 $\N$ 的 $L_0$ 到 $\Th \N_1$ 的解释，并且 $\N_1$ 是 $\Th\N_1$ 的模型。</p>
<p>于是，$|^\pi\N_1| = \mathbb{N}$ ，$a + ^{^\pi\N_1} b = c$ 当且仅当 $+^{\N_1}abc$ 当且仅当 $a + b = c$ ，以及 $a \cdot^{^\pi\N_1} b = c$ 当且仅当 $\cdot^{\N_1}abc$ 当且仅当 $a \cdot b = c$ ，表明 $^\pi\N_1 = \N_0$ 。但是，对于每一个 $s:V \to \mathbb{N}$ ，$\models_{\N_0} \phi[s]$ 当且仅当 $\models_{^\pi\N_1}[s]$ 当且仅当 $\models_{\N_1} \phi^n[s]$ （引理 27B）。这意味着 $R$ 可以在 $\N_1$ 中由 $\phi^n$ 定义。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h2 id="教材-S-3-不可判定性">教材 $\S 3$ 不可判定性</h2>
<p>本章主要学习三种方法：自代入法、对角线法和可计算法。</p>
<h3 id="教材-S-3-0-数论">教材 $\S 3.0$ 数论</h3>
<p>本章涉及到的模型：</p>
<p>$$
\N = (\mathbb{N}; \0, \bfS, &lt;, +, \cdot, E) \
\N_S = (\mathbb{N}; \0, \bfS) \
\N_L = (\mathbb{N}; \0, \bfS, &lt;) \
\N_A = (\mathbb{N}; \0, \bfS, &lt;, +) \
\N_M = (\mathbb{N}; \0, \bfS, &lt;, +, \cdot)
$$</p>
<p>定理 30A：设 $A \subseteq \Th \N$ 是 $\N$ 中取值为真的句子集，且 $A$ 的哥德尔数集合 $\set{\sharp \alpha \mid \alpha \in A}$ 是一个在 $\N$ 中可定义的集合。则我们可以找到一个在 $\N$ 中为真的句子 $\sigma$，但 $\sigma$ 不能由 $A$ 推出。</p>
<blockquote>
<p>该命题的证明方式是证明哥德尔第一不完备性定理的雏形。本视频推导了证明两个哥德尔不完备定理的过程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19u4y1D7GT?t=554.2">【毕导】这个视频里说的都是真的，但你却永远无法证明_哔哩哔哩_bilibili</a>。中文版教材的证明过程中有一些翻译错误，请以本文为准。</p>
<p>证明：命题的证明思路如下：</p>
<ol>
<li>利用哥德尔数（$\S 3.4$）构造自指句子 $\sigma$；</li>
<li>使用反证法，通过假设推出矛盾以证明假设的反面；</li>
<li>得出结论。</li>
</ol>
<p>下面是命题证明的详细过程。</p>
<p>我们来构造一个句子 $\sigma$ 来表示 $\sigma$ 本身不是 $A$ 的定理。概括地说，接下去的讨论是这样的：如果 $A \vdash \sigma$，那么 $\sigma$ 是假的，这与 $A$ 是取值为真的句子集相矛盾。因此，$\sigma$ 是取值为真的句子，但 $A \not\vdash \sigma$。</p>
<p>为了构造 $\sigma$，我们首先考虑这样的一个三元关系 $R$：TODO：从这个定义开始看不懂的。推理在 $\S 3.4$ P168 定义。</p>
<p>$$
(a, b, c) \in R \quad \text{iff} \quad a \text{ 是某个公式 } \alpha \text{ 的哥德尔数，} c \text{ 是 } \alpha(\bfS^b \0) \text{ 的从 } A \text{ 出发的某个推理上的 } \G \text{ 值}
$$</p>
<p>简言之，$(a, b, c)$ 的含义是，哥德尔数为 $a$ 的公式中的 $v_1$ 替换为 $b$，得到的推理的哥德尔数为 $c$。</p>
<p>因为 $\set{\sharp \alpha \mid \alpha \in A}$ 在 $\N$ 中可定义，因此 $R$ 也是可定义的。（这里面的细节要等几节后才能证明）令 $\rho$ 是 $\N$ 中定义 $R$ 的一个公式，$q$ 为</p>
<p>$$
q = \sharp (\forall v_3 \neg \rho(v_1, v_1, v_3))
$$</p>
<p>（在此，用下列记号：$\varphi(t) = \varphi_{t}^{v_1}, \varphi(t_1, t_2) = (\varphi_{t_1}^{v_1})_{t_2}^{v_2}$，等等）</p>
<p>下面开始正式构造自指句子 $\sigma$，令</p>
<p>$$
\sigma = \forall v_3 \neg \rho(\bfS^q \0, \bfS^q \0, v_3)
$$</p>
<p>则 $\sigma$ 表示任何一个数都不是 $q$ 的从 $A$ 出发的某个推理上的 $\G$ 值，这个推理是将哥德尔数为 $q$ 的公式中的变元 $v_1$ 换成数字 $q$ 后所得到的公式的推理；即任何一个数都不是 $\sigma$ 的推理 $\G$ 的值。这个句子就是毕导视频中提到的 $\mathrm{sub}(n, n, 17)$。</p>
<p>下面使用反证法，通过假设推出矛盾以证明假设的反面。</p>
<p>假设和我们期望的结果相反，存在一个从 $A$ 出发的 $\sigma$ 的推论。我们设 $k$ 是这个推理 $\G$ 的值，则 $\langle q, q, k\rangle \in R$ 并且</p>
<p>$$
\models_\N \rho(\bfS^q \0, \bfS^q \0, \bfS^k \0)
$$</p>
<p>显然</p>
<p>$$
\sigma \vdash \neg \rho(\bfS^q \0, \bfS^q \0, \bfS^k \0)
$$</p>
<p>并且这两个公式说明 $\sigma$ 在 $\N$ 中是假的。但 $A \vdash \sigma$ 和 $A$ 中的句子在 $\N$ 中都是真的，这就得到了矛盾。</p>
<p>因此，不存在 $\sigma$ 的从 $A$ 出发的推论。这样对于每个 $k$，我们有 $\langle q, q, k\rangle \notin R$。即对于每个 $k$，</p>
<p>$$
\models_\N \neg \rho(\bfS^q \0, \bfS^q \0, \bfS^k \0),
$$</p>
<p>由此我们有（使用替换引理）</p>
<p>$$
\models_\N \forall v_3 \neg \rho(\bfS^q \0, \bfS^q \0, v_3);
$$</p>
<p>即，$\sigma$ 在 $\N$ 中是真的。</p>
</blockquote>
<p>大题考点：TODO</p>
<ol>
<li>定理 30A 的证明思路。要点：自指、反证法</li>
<li>定理 30A 中三元关系 $R$ 是怎么定义的？其中的符号 $a,b,c,\alpha$ 分别代表什么？其中的推理是如何编码的？</li>
</ol>
<h3 id="教材-S-3-3-数论的子理论">教材 $\S 3.3$ 数论的子理论</h3>
<h4 id="教材-S-3-3-1-公理集-A-E">教材 $\S 3.3.1$ 公理集 $A_E$</h4>
<p>$$
\begin{aligned}
\0 \text{ 是后继运算的递归边界 } &amp; \forall x &amp;&amp; \mathbf{S}x \neq \0 &amp; (S1) \
\text{后继运算的递归定义 }&amp; \forall x \forall y &amp;&amp; (\mathbf{S}x = \mathbf{S}y \rightarrow x = y) &amp; (S2) \
&lt; \text{ 运算的递归定义 }&amp; \forall x \forall y &amp;&amp; (x &lt; \mathbf{S}y \leftrightarrow x \leq y) &amp; (L1) \
\0 \text{ 是小于运算定义的递归边界 } &amp; \forall x &amp;&amp; (x \not&lt; \0) &amp; (L2) \
&lt; \text{ 是一个全序 } &amp; \forall x \forall y &amp;&amp; (x &lt; y \lor x = y \lor y &lt; x) &amp; (L3) \
\0 \text{ 是加法定义的递归边界 } &amp; \forall x &amp;&amp; x + \0 = x &amp; (A1) \
\text{加法运算的递归定义 }&amp; \forall x \forall y &amp;&amp; x + \mathbf{S}y = \mathbf{S}(x + y) &amp; (A2) \
\0 \text{ 是乘法定义的递归边界 } &amp; \forall x &amp;&amp; x \cdot \0 = \0 &amp; (M1) \
\text{乘法运算的递归定义} &amp; \forall x \forall y &amp;&amp; x \cdot \mathbf{S}y = x \cdot y + x &amp; (M2) \
\0 \text{ 是幂乘定义的递归边界 } &amp; \forall x &amp;&amp; x \mathbf{E} \0 = \mathbf{S} \0 &amp; (E1) \
\text{幂乘运算的递归定义 } &amp; \forall x \forall y &amp;&amp; x \mathbf{E} \mathbf{S}y = x \mathbf{E} y \cdot x &amp; (E2)
\end{aligned}
$$</p>
<p>其中，$S1, S2$ 构成对后继运算的定义，$L1,L2,L3$ 构成对小于运算的定义，$A1,A2,M1,M2,E1,E2$ 分别构成对加法、乘法、幂乘运算的递归定义。</p>
<p>大题考点：</p>
<ol>
<li>AE 公理集有哪些？分别是什么？</li>
</ol>
<h4 id="教材-S-3-3-2-可表示关系">教材 $\S 3.3.2$ 可表示关系</h4>
<p>可定义关系：设 $R$ 是 $\mathbb{N}$ 上的 $m$ 元关系，即 $R \subseteq \mathbb{N}^m$。我们已经知道，公式 $\rho$（其中只有 $v_1,\cdots,v_m$ 是自由变元）在 $\N$ 中定义 $R$ 当且仅当对于 $\mathbb{N}$ 中任意的 $a_1,\cdots,a_m$，</p>
<p>$$
\langle a_1,\cdots,a_m \rangle \in R \iff \models_{\N} \rho[a_1,\cdots,a_m] \
\iff \models_{\N} \rho(\bfS^{a_1}\0,\cdots,\bfS^{a_m}\0).
$$</p>
<p>（后两个条件等价是根据替换引理）我们可以把上述结果写成两个蕴涵式：</p>
<p>$$
\langle a_1,\cdots,a_m \rangle \in R \Rightarrow \models_{\N} \rho(\bfS^{a_1}\0,\cdots,\bfS^{a_m}\0) \
\langle a_1,\cdots,a_m \rangle \notin R \Rightarrow \models_{\N} \neg \rho(\bfS^{a_1}\0,\cdots,\bfS^{a_m}\0)
$$</p>
<p>可表示关系：如果在上述两个蕴涵式中，“在 $\N$ 中为真”的概念可以被更强的概念“从 $A_E$ 中推出”取代，我们称 $\rho$ 在理论 $\Cn \ A_E$ 中可以表示 $R$。</p>
<p>$$
\langle a_1,\cdots,a_m \rangle \in R \Rightarrow \rho(\bfS^{a_1}\0,\cdots,\bfS^{a_m}\0) \in T \
\langle a_1,\cdots,a_m \rangle \notin R \Rightarrow \neg \rho(\bfS^{a_1}\0,\cdots,\bfS^{a_m}\0) \notin T
$$</p>
<p>$\rho$ 在理论 $\Th \ \N$ 中表示 $R$ 当且仅当 $\rho$ 在 $\N$ 中定义 $R$。</p>
<p>一个关系在 $T$ 中是可表示的，当且仅当存在一个公式，在 $T$ 中表示该关系。</p>
<p>定理 33E 公式 $\rho$ 在 $\Cn \ A_E$ 中表示关系 $R$ 当且仅当</p>
<ol>
<li>$\rho$ 由 $A_E$ 数字确定，且</li>
<li>$\rho$ 在 $\mathfrak{N}$ 中定义 $R$。</li>
</ol>
<p>我们有必要比较一下可表示和可定义这两个概念。在这两个概念中，我们都是用公式来描述自然数之间的关系。对于可定义性，我们关心的是句子的解释是否是真的；而对于在 $\Cn \ A_E$ 中可表示，我们关心的是句子是否能从公理推出。</p>
<p>大题考点：</p>
<ol>
<li>可表示、可定义是怎么定义的？他们有什么区别？</li>
</ol>
<p>笔者认为，“定义”意味着创造了新的概念，而“表示”并不创造新的概念。$\Cn \ A_E$ 作为一个封闭的理论，无法在其中创造更多的概念，因此使用“表示”这一术语。结构 $\N$ 本身并不包含句子，因此用“定义”这一术语。</p>
<h4 id="教材-S-3-3-5-可表示函数">教材 $\S 3.3.5$ 可表示函数</h4>
<p>在很多情况下，使用函数要比用关系来得方便。设 $f: \mathbb{N}^m \to \mathbb{N}$ 是自然数上的 $m$ 元函数，公式 $\varphi$ 中只有 $v_1, \cdots, v_{m+1}$ 是自由变元。我们称 $\varphi$（在 $\Cn \ A_E$ 中）函数表示 $f$，当且仅当对于 $\mathbb{N}$ 中的每一 $m$ 元组 $a_1, \cdots, a_m$，</p>
<p>$$
A_E \vdash \forall v_{m+1} [\varphi(\bfS^{a_1}\0, \cdots, \bfS^{a_m}\0, v_{m+1}) \leftrightarrow v_{m+1} = \bfS^{f(a_1, \cdots, a_m)}\0]
$$</p>
<p>大题考点：</p>
<ol>
<li>可表示函数的定义</li>
</ol>
<p>习题 1：证明：在结构 $( \mathbb{N}; \cdot, E)$ 中，我们能够定义加法关系 $\set{\langle m, n, m+n\rangle | m, n \in \mathbb{N}}$。进一步证明在此结构中 $\set{\0}$，序关系 $&lt;$，后继关系 $\set{\langle n, \bfS(n) \rangle | n \in \mathbb{N}}$ 都是可定义的。(说明：如果把结构 $( \mathbb{N}; \cdot, E)$ 简化为 $( \mathbb{N}; E)$, 这个结果还能加强。在此处，乘法关系可以通过指数运算的一个法则: $(d^a)^b = d^{ab}$ 来定义）</p>
<p>本题的第二小问在中文版教材前置条件被翻译为“在结构 $\set{\0}$ 中”，这是完全错误的翻译！请以本题的翻译为准！</p>
<blockquote>
<p>证明：在算数关系中，很容易使用对数将乘法转化为加法。例如 $\log(nm) = \log(n) + \log(m)$。利用这一思路，定义加法关系为 $\set{\langle n, m, p\rangle | 2En \cdot 2Em = 2Ep}$，其中 $2 = \bfS^2\0$。至此我们完成了对加法的定义，在后续我们会使用加法。</p>
<p>在此结构中，定义 $\set{\0}$ 为：$\forall x x + \0 = x$。</p>
<p>定义序关系为 $\set{\langle n, m\rangle | \exists x (x + x \neq x \land n + x = m)}$；</p>
<p>在算数关系中，后继可以用 $m = n+1$ 表示，只要构造 $x=1$ 即可。</p>
<p>定义后继关系为 $\set{\langle n, m\rangle | \exists x (x + x \neq x \land \forall y \forall z (y+y\neq y \to z+z \neq z \to y+z\neq x) \land n + x = m)}$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 2（不考）：证明定理 33C, 即（在 $\N$ 中）真的无量词句子都是 $A_E$ 的定理。</p>
<blockquote>
<p>证明：</p>
<p>首先，令 $\tau$ 是一个原子句子。那么，$\tau = t &lt; u$ 或 $\tau = t = u$，其中 $t$ 和 $u$ 是不含变量的项。根据引理 33B，存在 $m$ 和 $n$ 使得 $A_E \vdash t = \bfS^m \0$ 和 $A_E \vdash u = \bfS^n \0$。进一步地，$A_E \vdash \bfS^m \0 = \bfS^n \0$ 当且仅当 $m = n$，而 $A_E \vdash \bfS^m \0 \neq \bfS^n \0$ 当且仅当 $m \neq n$（根据 S1 和 S2），并且，利用这一点，根据引理 33A，$A_E \vdash \bfS^m \0 &lt; \bfS^n \0$ 当且仅当 $m &lt; n$，而 $A_E \vdash \bfS^m \0 \not&lt; \bfS^n \0$ 当且仅当 $m \geq n$。利用这些事实，我们可以证明 $A_E \vdash t &lt; u$ 当且仅当 $m &lt; n$，而 $A_E \vdash \neg t &lt; u$ 当且仅当 $m \geq n$，并且 $A_E \vdash t = u$ 当且仅当 $m = n$，而 $A_E \vdash \neg t = u$ 当且仅当 $m \neq n$。例如，对于 $m &lt; n$，$A_E \vdash \forall x \forall y \forall z (x = y \rightarrow x &lt; z \rightarrow y &lt; z)$ 和 $A_E \vdash \forall x \forall y \forall z (x = y \rightarrow z &lt; x \rightarrow z &lt; y)$（演绎公理组 6，DA6），并且利用 DA2，我们可以推导出 $A_E \vdash \bfS^m \0 = t \rightarrow \bfS^m \0 &lt; \bfS^n \0 \rightarrow t &lt; \bfS^n \0$ 和 $A_E \vdash \bfS^n \0 = u \rightarrow t &lt; \bfS^n \0 \rightarrow t &lt; u$，并且类似地对于 $A_E \vdash \neg u = t$ 和 $A_E \vdash \neg u &lt; t$。</p>
<p>其次，令 $\tau$ 是一个形式为 $\neg \tau_1$ 或 $\tau_2 \rightarrow \tau_3$ 的句子，并且在 $\mathfrak{A}$ 中为真，其中 $\tau_i$ 是使得 $A_E \vdash \tau_i$ 当且仅当 $\tau_i$ 在 $\mathfrak{A}$ 中为真，而 $A_E \vdash \neg \tau_i$ 当且仅当 $\tau_i$ 在 $\mathfrak{A}$ 中为假。我们证明同样的结论也适用于 $\tau$。确实，如果 $\tau$ 在 $\mathfrak{A}$ 中为真，那么分别地，$\tau_1$ 在 $\mathfrak{A}$ 中为假，而 $\tau_2$ 在 $\mathfrak{A}$ 中为假或 $\tau_3$ 在 $\mathfrak{A}$ 中为真，这意味着 $A_E \vdash \neg \tau_1$，并且 $A_E \vdash \neg \tau_2 \lor \tau_3$，即 $A_E \vdash \tau$；否则，$\tau_1$ 在 $\mathfrak{A}$ 中为真，而 $\tau_2$ 在 $\mathfrak{A}$ 中为真，$\tau_3$ 在 $\mathfrak{A}$ 中为假，这意味着 $A_E \vdash \neg \neg \tau_1$，并且 $A_E \vdash \neg (\neg \tau_2 \lor \tau_3)$，即 $A_E \vdash \neg \tau$。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 5（不考）：证明：序列数字的集合是可表示的（编目 10）。</p>
<blockquote>
<p>证明：序列数的集合定义为 $\mathcal{S} = \set{ b \mid \forall x (x \leq b \rightarrow x \in \mathcal{P} \rightarrow &lt; x, b &gt; \in \mathcal{D} \rightarrow \forall y (y &lt; x \rightarrow y \in \mathcal{P} \rightarrow &lt; y, b &gt; \in \mathcal{D}) }$，其中 $\mathcal{P}$ 是素数的集合，而 $\mathcal{D}$ 是可整除关系。换句话说，如果某个素数 $x$ 能整除 $b $，那么所有小于 $x$ 的素数 $y$ 也能整除 $b $。特别地，这在 $b = 1 = \langle \rangle$ 和 $b = 2 = \langle 0 \rangle$ 时是显然成立的。通过目录项 0、3、4 和 5，我们得出结论 $\mathcal{S}$ 是可表示的。</p>
<p>$Q.E.D.$</p>
</blockquote>
<p>习题 6（不考）：3 是序列数字吗？$\lh 3$ 等于多少？求出 $(1 \ast 3) \ast 6$ 和 $1 \ast (3 \ast 6)$。</p>
<blockquote>
<p>$3 = 2^0 \cdot 3^1$ 是不是一个序列数，因为 $p_1 = 3$ 能整除 3，但 $p_0 = 2$ 不能整除 3。然而，形式上，我们仍然可以计算问题中的公式。</p>
<p>首先，形式上，$\lh b$ 定义为最小的 $n \in \mathbb{N}$，使得要么 $b = 0 $，要么 $\langle p_n, b \rangle \notin \mathcal{D}$，其中 $\mathcal{D}$ 是可整除关系。在我们的例子中，$ \langle p_0, 3 \rangle \notin \mathcal{D}$，因此 $\lh 3 = 0$。</p>
<p>其次，形式上，$(b)_c$ 定义为最小的 $n \in \mathbb{N}$，使得要么 $b = 0 $，要么 $\langle p_c^{n+2}, b \rangle \notin \mathcal{D}$。在我们的例子中，$(3)_c = 0$ 对所有 $c \in \mathbb{N}$（包括 $c = 1$ 时 $p_1 = 3 $）。</p>
<p>最后，$a * b = a \cdot \prod_{i &lt; \lh b} p^{(b)<em>i + 1}</em>{i + \lh a}$ 对所有自然数也定义。特别地，由于 $\text{lh} 1 = 0$，$1 * b = \prod_{i &lt; \text{lh} b} p_i^{(b)<em>i + 1}$，这仅仅是能整除 $b$ 的最大序列数。因此，$1 * 3 = 1$ 和 $(1 _ 3) _ 6 = 6 $（$ 6 = \langle 0, 0 \rangle$ 是一个序列数）。进一步，$3 * 6 = 3 \cdot \prod</em>{i &lt; 2} p_i^{(6)_i + 1} = 3 \cdot 6 = 18 = 2^1 \cdot 3^2 = \langle 0, 1 \rangle $。因此，$1 * (3 * 6) = 18$。</p>
</blockquote>
<p>习题 10：设 $R$ 是可表示的关系，$ g$ 和 $h$ 是可表示的函数。证明：$ f$ 是可表示的，其中</p>
<p>$$
f(\bar{a}) = \begin{cases}
g(\bar{a}) &amp; \text{若 } \bar{a} \in R, \
h(\bar{a}) &amp; \text{若 } \bar{a} \notin R.
\end{cases}
$$</p>
<blockquote>
<p>证明：函数 $f$ 可以表示为组合（定理 33L）$d(g(\bar{a}), h(\bar{a}), K_R(\bar{a}))$，其中 $g , h , K_R$（目录项 1），且 $d(x, y, z) = x \cdot z + y \cdot (1 - z)$ 是可表示的。</p>
<p>$Q.E.D.$</p>
</blockquote>
<h3 id="教材-S-3-4-语法的算数化">教材 $\S 3.4$ 语法的算数化</h3>
<p>本节完成了对哥德尔数的具体定义，这意味着所有的公式都可以用自然数来表示。</p>
<p><img src="/42645/image-20241230000750745.png" alt></p>
<p>如表 3-1，函数 $h$ 把每个左边的整数指派给右边的符号。例如 $h(\forall) = 0, h(\0) = 2, h(v_i) = 9 + 2i$。</p>
<p>对于一个语言的表达式 $\varepsilon = (s_0 \dots s_m)$，定义其哥德尔数为 $\sharp(\varepsilon)$</p>
<p>$$
\sharp(s_0 \dots s_m) = \langle h(s_0), \dots, h(s_n)\rangle
$$</p>
<p>比如，对 $\mathfrak{N}$ 的语言使用上述的函数 $h$，我们可以得到</p>
<p>$$
\begin{align*}
\sharp(\exists v_3 v_3 = \0) &amp; =  \sharp((\neg \forall v_3 (\neg = v_3 \0))) \
&amp; =  \langle 1, 5, 0, 15, 1, 5, 9, 15, 2, 3, 3 \rangle \
&amp; =  2^2 \cdot 3^6 \cdot 5^1 \cdot 7^{16} \cdot 11^2 \cdot 13^6 \cdot 17^{10} \cdot 19^{16} \cdot 23^3 \cdot 29^4 \cdot 31^4
\end{align*}
$$</p>
<p>对于一个推理（序列），$\langle \alpha_1, \dots, \alpha_n\rangle$，做如下指派：</p>
<p>$$
\G(\langle \alpha_1, \dots, \alpha_n\rangle) = \langle \sharp\alpha_1, \dots, \sharp\alpha_n \rangle
$$</p>
<p>存在可表示函数 $\Sb$，使得对于一个项或公式 $\alpha$，变元 $x$，及项 $t$，</p>
<p>$$
\Sb(\sharp \alpha, \sharp x, \sharp t) = \sharp \alpha_t^x
$$</p>
<p>存在一个可表示关系 $\Fr$，使得对于一个项或公式 $\alpha$，及变元 $x$，</p>
<p>$$
\langle \sharp \alpha, \sharp x \rangle \in \Fr \iff x \text{ 在 } \alpha \text{ 中自由出现}
$$</p>
<p>性质：</p>
<p>$$
\langle a, b\rangle \in \Fr \iff \Sb(a, b, \sharp \0) \ne a
$$</p>
<h3 id="教材-S-3-5-不完全性和不可判定性">教材 $\S 3.5$ 不完全性和不可判定性</h3>
<p>不动点引理：对于只含有自由变元 $v_1$ 的公式 $\beta$ ，我们可以找到句子 $\sigma$ 使得</p>
<p>$$
A_E \vdash [\sigma \leftrightarrow \beta (\bfS^{\sharp\sigma} \0)].
$$</p>
<p>我们可以认为 $\sigma$ 间接地表达 “$\beta$ 是真的我。” 当然，实际上 $\sigma$ 什么也没说，它只是一些符号串而已。甚至当我们在 $\mathfrak{N}$ 中把它翻译成自然语言时，它也仅仅是关于一些数字和它们的后继及运算结果的句子。正是因为我们把数字和表达式联系起来，我们才能把 $\sigma$ 看作一个公式。</p>
<p>大题考点：</p>
<ol>
<li>TODO：不动点定理的证明思路？</li>
</ol>
<h4 id="教材-S-3-5-2-弱可表示性">教材 $\S 3.5.2$ 弱可表示性</h4>
<p>我们考虑递归可枚举集 $Q$，其中对于递归 $R$</p>
<p>$$
a \in Q \Leftrightarrow \exists b \langle a , b \rangle \in R
$$</p>
<p>我们知道存在公式 $\rho$ 在 $\Cn \ A_E$ 中表示 $R$ 。因此，公式 $\exists v_2 \rho$ 在 $\mathfrak{N}$ 中定义了 $Q$。这个公式在 $\Cn \ A_E$ 中不能表示 $Q$，除非 $Q$ 是递归的。但我们说这个公式几乎可以表示 $Q$。</p>
<p>$$
\begin{aligned}
a \in Q &amp; \Rightarrow \langle a , b \rangle \in R &amp;&amp; \text{对于某个 } b \
&amp; \Rightarrow A_E \vdash \rho(\bfS^a \0 , \bfS^b \0) &amp;&amp; \text{对于某个 } b \
&amp; \Rightarrow A_E \vdash \exists v_2 \rho(\bfS^a \0 , v_2)
\end{aligned}
$$</p>
<p>$$
\begin{aligned}
a \notin Q &amp; \Rightarrow \langle a , b \rangle \notin R &amp;&amp; \text{对于所有的 } b \
&amp; \Rightarrow A_E \vdash \neg \rho(\bfS^a \0 , \bfS^b \0) &amp;&amp; \text{对于所有的 } b \
&amp; \Rightarrow A_E \not\vdash \exists v_2 \rho(\bfS^a \0 , v_2)
\end{aligned}
$$</p>
<p>大题考点：</p>
<ol>
<li>TODO：弱可表示性的定义</li>
</ol>
<h3 id="教材-S-3-6-递归函数">教材 $\S 3.6$ 递归函数</h3>
<p>另有：习题 3.6 1；2（a);3;4;8</p>
<p>习题 1：如下定义函数 $f$ 和 $g$，</p>
<p>$$
f(n) =
\begin{cases}
0 &amp; \text{如果哥德巴赫猜想是对的} \
1 &amp; \text{其他情况}
\end{cases} \
g(n) =
\begin{cases}
0 &amp; \text{如果在 $\pi$ 的十进制小数展开式中至少连续出现 $n$ 个 $7$} \
1 &amp; \text{其他情况}
\end{cases}
$$</p>
<p>那么，$f$ 是递归的吗？$g$ 是递归的吗？（哥德巴赫猜想是指任意一个比 2 大的偶数都可以写成两个素数的和。在这本书的第一版使用的是 Fermat 最终定理。）</p>
<blockquote>
<p>函数 $f$ 不是递归的，因为 $f$ 是常函数。</p>
<p>函数 $g$ 是递归可枚举函数，不是递归函数。</p>
</blockquote>
<p>习题 2：定义对角线函数 $d(a) = [a]_1(a)+1$。</p>
<p>（a）证明：$d$ 是部分递归函数</p>
<blockquote>
<p>这题不会，跳过。</p>
</blockquote>
<p>习题 3：（a）证明：任意部分递归函数的值域都是递归可枚举的。</p>
<p>（b）证明：严格递增的全递归函数 $f$（即, $f(n) &lt; f(n + 1)$）的值域是递归的。</p>
<p>（c）证明：递增全递归函数 $f$（即, $f(n) \leq f(n + 1)$）的值域是递归的。</p>
<blockquote>
<p>这道题考前重点讲解。</p>
<p>证明：听了，但没听懂。真不会了，考到就认命吧。</p>
</blockquote>
<h4 id="教材-S-3-6-2-部分递归函数">教材 $\S 3.6.2$ 部分递归函数</h4>
<p>范式定理（Kleene，1943）</p>
<p>（a）在 $\langle e, a_1, \cdots, a_m \rangle$ 的值是 $[e]_m(a_1, \cdots, a_m)$ 的 $(m+1)$ 元部分函数是部分递归函数）</p>
<p>（b）对于每个 $e \geqslant 0$，$[e]_m$ 是 $m$ 元部分递归函数</p>
<p>（c）对于任意 $m$ 元部分递归函数, 都存在某个 $e$, 使得这个部分递归函数等于 $[e]_m$</p>
<p>在范式定理中，符号 $e, a, k, T_m$, 和 $k'$ 的含义如下：</p>
<ol>
<li>$e$: 这是递归函数的索引或编码，通常对应于一个程序或计算过程的标识符。它表示一个递归函数或其对应的程序。</li>
<li>$a$: 这是输入向量，通常表示为 $a_1, a_2, \ldots, a_m$，是递归函数的输入参数。</li>
<li>$k$: 这是一个编码，表示从公式 $\varphi$ 推导出结果的推理过程的哥德尔数。它包含了推理过程和结果的信息。</li>
<li>$T_m$: 这是一个 $(m+2)$ 元关系，包含 $e, a_1, \ldots, a_m, k$。它定义了计算步骤，表示 $e$、输入 $a$ 和编码 $k$ 之间的关系，其中 $k$ 编码了从公式 $\varphi$ 推导出结果的推理过程。</li>
<li>$k'$: 这是在 $k$ 之前的某个值，用于确保 $k$ 是满足条件的最小值。在最小化操作 $\mu k$ 中，$k'$ 代表比 $k$ 更小的值，用于检查是否有更小的 $k$ 满足条件。</li>
</ol>
<p>范式定理的核心思想是，对于任意递归函数 $f$，存在一个索引 $e$，使得 $f(a_1, \ldots, a_m)$ 可以表示为 $U(\mu k (e, a_1, \ldots, a_m, k) \in T_m)$，其中 $U(k)$ 提取编码 $k$ 中的结果部分。通过这些符号和关系，定理描述了递归函数的计算过程和其通用性。</p>
<p>大题考点：</p>
<ol>
<li>解释范式定理中符号 $e, a, k, T_m$, 和 $k'$的意思</li>
</ol>
<h3 id="教材-S-3-7-第二不完全性定理">教材 $\S 3.7$ 第二不完全性定理</h3>
<p>哥德尔第二不完全性定理（1931） 设 $T$ 是一个足够强的递归可公理化理论，则 $T \vdash \Cons T$ 当且仅当 $T$ 是不和谐的。</p>
<p>证明思路：</p>
<p>哥德尔第二不完备定理表明，如果一个足够强大的公理系统是相容的，那么它不能证明它自身的相容性。以下是该定理的证明思路，分为几个关键步骤：</p>
<p>可证明性公式：首先，我们定义一个公式 $\text{Prb}_T(x)$，它表示“ $x$ 在系统 $T$ 中是可证明的”。这个公式通过哥德尔编码来表示公式和证明的过程。</p>
<p>相容性公式：接下来，我们定义系统的相容性公式 $\text{ConsT}$，它表示“系统 $T$ 是相容的”，即不存在可证明的矛盾。具体来说，$\text{ConsT}$ 可以表示为 $\neg \text{Prb}_T(0=1)$，即系统 $T$ 不能证明 $0 = 1$。</p>
<p>不动点引理：利用不动点引理，我们可以构造一个自指命题 $\sigma$，使得 $\sigma$ 等价于 $ \neg \text{Prb}_T(\sigma)$。这个命题 $\sigma$ 可以被理解为“我不可证明”。</p>
<p>假设系统证明相容性：假设系统 $T$ 能够证明其相容性，即 $T \vdash \text{ConsT}$。根据 $\sigma$ 的定义，我们有：</p>
<p>$$
T \vdash (\sigma \leftrightarrow \neg \text{Prb}_T(\sigma))
$$</p>
<p>利用反射性质：通过反射性质，我们可以证明如果 $T \vdash \sigma$，那么 $T \vdash \text{Prb}_T(\sigma)$。然而，根据 $\sigma$ 的定义，这会导致矛盾，因为 $T$ 不能同时证明 $\sigma$ 和 $\neg \text{Prb}_T(\sigma)$。</p>
<p>Löb 定理的应用：Löb 定理指出，如果 $T$ 证明“$\text{Prb}_T(\tau) \rightarrow \tau$”，那么 $T$ 证明 $\tau$。在这个情境下，如果 $T$ 证明 $\text{ConsT}$，那么根据 Löb 定理，$T$ 会证明 $\neg \text{Prb}_T(0=1)$，即 $\text{ConsT}$ 本身。</p>
<p>结论：如果 $T$ 是相容的，它不能证明 $\text{ConsT}$，因为如果 $T$ 能证明 $\text{ConsT}$，那么根据上述推理，$T$ 会变得不相容。因此，哥德尔第二不完备定理成立：如果 $T$ 是相容的，它不能证明自身的相容性。</p>
<p>总结：哥德尔第二不完备定理的证明思路是通过构造自指命题 $\sigma$，利用可证明性和相容性的表达，结合反射性质和 Löb 定理，最终得出系统无法证明自身相容性的结论。</p>
<p>一个基于哥德尔第一不完备定理的更简单的证明思路：</p>
<p>哥德尔第一不完备定理可以简化为对“若公理体系具有一致性，则构造的自指命题 $\sigma$ 为真”这一命题的否定。</p>
<p>哥德尔第二不完备定理可以简化为对“从公理可推出公理体系具有一致性”这一命题的否定。</p>
<p>若“从公理可推出公理体系具有一致性”这一命题成立，则有从公理出发可推出自指命题 $\sigma$ 为真，这本身就是一个推导出（证明出）$\sigma$ 的过程，与第一不完备定理相悖。因此“从公理可推出公理体系具有一致性”这一命题为假。</p>
<p>大题考点：</p>
<ol>
<li>TODO：简叙哥德尔第二不完全性定理（P200）的证明思路</li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat-award.jpg" alt="EagleBear2002 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="EagleBear2002 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/47226/" rel="prev" title="软件安全课程实验-第三题-实验报告">
      <i class="fa fa-chevron-left"></i> 软件安全课程实验-第三题-实验报告
    </a></div>
      <div class="post-nav-item">
    <a href="/28165/" rel="next" title="高级软件设计-期末复习">
      高级软件设计-期末复习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E4%BD%AC%E9%95%87%E5%9C%BA"><span class="nav-number">1.</span> <span class="nav-text">大佬镇场</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-%E9%9B%86%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">讲义 $\S 0.2$ 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-15-%E8%89%AF%E5%BA%8F%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.</span> <span class="nav-text">讲义 $\S 0.2.15$ 良序关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-17-%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">讲义 $\S 0.2.17$ 自然数的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-18-%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">讲义 $\S 0.2.18$ 数学归纳法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-19-%E6%9C%89%E7%A9%B7%E9%9B%86%E5%90%88%E5%92%8C%E6%97%A0%E7%A9%B7%E9%9B%86%E5%90%88"><span class="nav-number">2.4.</span> <span class="nav-text">讲义 $\S 0.2.19$ 有穷集合和无穷集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-21-%E6%9C%89%E7%A9%B7%E9%9B%86%E5%90%88"><span class="nav-number">2.5.</span> <span class="nav-text">讲义 $\S 0.2.21$ 有穷集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-22-%E5%8F%AF%E6%95%B0%E9%9B%86%E5%90%88"><span class="nav-number">2.6.</span> <span class="nav-text">讲义 $\S 0.2.22$ 可数集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-24-%E4%B8%8D%E5%8F%AF%E6%95%B0%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8D%E8%80%83%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">讲义 $\S 0.2.24$ 不可数集合（不考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-25-%E5%BA%8F%E6%95%B0"><span class="nav-number">2.8.</span> <span class="nav-text">讲义 $\S 0.2.25$ 序数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-26-%E8%B6%85%E7%A9%B7%E5%BD%92%E7%BA%B3%E6%B3%95"><span class="nav-number">2.9.</span> <span class="nav-text">讲义 $\S 0.2.26$ 超穷归纳法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-28-%E5%8F%AF%E6%95%B0%E5%BA%8F%E6%95%B0"><span class="nav-number">2.10.</span> <span class="nav-text">讲义 $\S 0.2.28$ 可数序数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89-S-0-2-29-%E5%9F%BA%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">讲义 $\S 0.2.29$ 基数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-1-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91"><span class="nav-number">3.</span> <span class="nav-text">教材 $\S 1$ 命题逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-1-1-%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="nav-number">3.1.</span> <span class="nav-text">教材 $\S 1.1$ 命题逻辑的语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-1-2-%E7%9C%9F%E5%80%BC%E6%8C%87%E6%B4%BE"><span class="nav-number">3.2.</span> <span class="nav-text">教材 $\S 1.2$ 真值指派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-1-3-%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">教材 $\S 1.3$ 解析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-1-4-%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92"><span class="nav-number">3.4.</span> <span class="nav-text">教材 $\S 1.4$ 归纳与递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-1-5-%E5%91%BD%E9%A2%98%E8%BF%9E%E6%8E%A5%E8%AF%8D"><span class="nav-number">3.5.</span> <span class="nav-text">教材 $\S 1.5$ 命题连接词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-1-7-%E7%B4%A7%E8%87%B4%E6%80%A7%E5%92%8C%E8%83%BD%E8%A1%8C%E6%80%A7%EF%BC%88%E4%B8%8D%E8%80%83%EF%BC%89"><span class="nav-number">3.6.</span> <span class="nav-text">教材 $\S 1.7$ 紧致性和能行性（不考）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91"><span class="nav-number">4.</span> <span class="nav-text">教材 $\S 2$ 一阶逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-1-%E4%B8%80%E9%98%B6%E8%AF%AD%E8%A8%80"><span class="nav-number">4.1.</span> <span class="nav-text">教材 $\S 2.1$ 一阶语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90"><span class="nav-number">4.1.1.</span> <span class="nav-text">概念辨析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-2-%E7%9C%9F%E5%80%BC%E4%B8%8E%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">教材 $\S 2.2$ 真值与模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-2-1-%E9%80%BB%E8%BE%91%E8%95%B4%E6%B6%B5"><span class="nav-number">4.2.1.</span> <span class="nav-text">教材 $\S 2.2.1$ 逻辑蕴涵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-2-2-%E5%8F%AF%E5%AE%9A%E4%B9%89%E6%80%A7"><span class="nav-number">4.2.2.</span> <span class="nav-text">教材 $\S 2.2.2$ 可定义性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-3-%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">教材 $\S 2.3$ 解析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-4-%E6%BC%94%E7%BB%8E%E8%AE%A1%E7%AE%97"><span class="nav-number">4.4.</span> <span class="nav-text">教材 $\S 2.4$ 演绎计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-4-1-%E5%BD%A2%E5%BC%8F%E6%BC%94%E7%BB%8E"><span class="nav-number">4.4.1.</span> <span class="nav-text">教材 $\S 2.4.1$ 形式演绎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-4-2-%E6%9B%BF%E6%8D%A2"><span class="nav-number">4.4.2.</span> <span class="nav-text">教材 $\S 2.4.2$ 替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-4-4-%E6%BC%94%E7%BB%8E%E4%B8%8E%E5%85%83%E5%AE%9A%E7%90%86"><span class="nav-number">4.4.3.</span> <span class="nav-text">教材 $\S 2.4.4$ 演绎与元定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-5-%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8E%E5%AE%8C%E5%A4%87%E6%80%A7%E7%90%86%E8%AE%BA"><span class="nav-number">4.5.</span> <span class="nav-text">教材 $\S 2.5$ 可靠性与完备性理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-6-%E7%90%86%E8%AE%BA%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.6.</span> <span class="nav-text">教材 $\S 2.6$ 理论的模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-2-7-%E7%90%86%E8%AE%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%A7%A3%E9%87%8A%EF%BC%88%E4%B8%8D%E8%80%83%EF%BC%89"><span class="nav-number">4.7.</span> <span class="nav-text">教材 $\S 2.7$ 理论之间的解释（不考）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">教材 $\S 3$ 不可判定性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-0-%E6%95%B0%E8%AE%BA"><span class="nav-number">5.1.</span> <span class="nav-text">教材 $\S 3.0$ 数论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-3-%E6%95%B0%E8%AE%BA%E7%9A%84%E5%AD%90%E7%90%86%E8%AE%BA"><span class="nav-number">5.2.</span> <span class="nav-text">教材 $\S 3.3$ 数论的子理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-3-1-%E5%85%AC%E7%90%86%E9%9B%86-A-E"><span class="nav-number">5.2.1.</span> <span class="nav-text">教材 $\S 3.3.1$ 公理集 $A_E$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-3-2-%E5%8F%AF%E8%A1%A8%E7%A4%BA%E5%85%B3%E7%B3%BB"><span class="nav-number">5.2.2.</span> <span class="nav-text">教材 $\S 3.3.2$ 可表示关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-3-5-%E5%8F%AF%E8%A1%A8%E7%A4%BA%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.3.</span> <span class="nav-text">教材 $\S 3.3.5$ 可表示函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-4-%E8%AF%AD%E6%B3%95%E7%9A%84%E7%AE%97%E6%95%B0%E5%8C%96"><span class="nav-number">5.3.</span> <span class="nav-text">教材 $\S 3.4$ 语法的算数化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-5-%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7"><span class="nav-number">5.4.</span> <span class="nav-text">教材 $\S 3.5$ 不完全性和不可判定性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-5-2-%E5%BC%B1%E5%8F%AF%E8%A1%A8%E7%A4%BA%E6%80%A7"><span class="nav-number">5.4.1.</span> <span class="nav-text">教材 $\S 3.5.2$ 弱可表示性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-6-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">教材 $\S 3.6$ 递归函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-6-2-%E9%83%A8%E5%88%86%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.1.</span> <span class="nav-text">教材 $\S 3.6.2$ 部分递归函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E6%9D%90-S-3-7-%E7%AC%AC%E4%BA%8C%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%86"><span class="nav-number">5.6.</span> <span class="nav-text">教材 $\S 3.7$ 第二不完全性定理</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EagleBear2002"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">EagleBear2002</p>
  <div class="site-description" itemprop="description">暮雪朝霜，毋改英雄意气</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">481</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EagleBear2002" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EagleBear2002" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:eaglebear2002@foxmail.com" title="E-Mail → mailto:eaglebear2002@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://czxingchen.github.io/" title="https:&#x2F;&#x2F;czxingchen.github.io&#x2F;" rel="noopener" target="_blank">PL 顶会研究者-XiaoZhi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/the-sword-of-king/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;the-sword-of-king&#x2F;" rel="noopener" target="_blank">模式识别专家-崖山剑</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://en.ydjsir.com.cn/" title="https:&#x2F;&#x2F;en.ydjsir.com.cn&#x2F;" rel="noopener" target="_blank">愿逐月华流照君-YDJSIR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/m0_51691879?spm=1000.2115.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51691879?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank">软院科协掌门人-wbl_z</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://itxia.club/" title="https:&#x2F;&#x2F;itxia.club&#x2F;" rel="noopener" target="_blank">侠之大者为国为民-IT 侠</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://chestnutsilver.github.io/TJIS-My-Helloworld/" title="https:&#x2F;&#x2F;chestnutsilver.github.io&#x2F;TJIS-My-Helloworld&#x2F;" rel="noopener" target="_blank">因果推断爱好者-ChestnutSilver</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://atritium.github.io/" title="https:&#x2F;&#x2F;atritium.github.io&#x2F;" rel="noopener" target="_blank">任天堂技术扛把子-manqi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.sakiyary.cn/" title="https:&#x2F;&#x2F;blog.sakiyary.cn&#x2F;" rel="noopener" target="_blank">教育部教学创新项目负责人-哈气鸭梨</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://huoxj.github.io/" title="https:&#x2F;&#x2F;huoxj.github.io&#x2F;" rel="noopener" target="_blank">离百年博客还有 98 年捞程序 Runz</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.erinwithbmq.xin/" title="https:&#x2F;&#x2F;www.erinwithbmq.xin&#x2F;" rel="noopener" target="_blank">摸鱼小能手 ErinwithBMQ の 尋夢之旅</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tilnel.github.io/" title="https:&#x2F;&#x2F;tilnel.github.io&#x2F;" rel="noopener" target="_blank">南大耐摔王 Tilnel 的杂谈小屋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.azifan.club/" title="https:&#x2F;&#x2F;blog.azifan.club&#x2F;" rel="noopener" target="_blank">水龙之魂</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mzy0624.github.io/" title="https:&#x2F;&#x2F;mzy0624.github.io&#x2F;" rel="noopener" target="_blank">Haibara AI</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EagleBear2002</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">40:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
