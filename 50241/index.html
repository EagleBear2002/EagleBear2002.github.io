<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eaglebear2002.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"always","padding":18,"offset":12,"onmobile":true,"scroll_to_top_on_sidebar_toggle":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="问答题例题 影响 http 事务的 TCP 相关延迟 以下内容来自 chatGPT：   建立连接延迟：在客户端和服务器之间建立 TCP 连接需要时间，包括发送和接收握手消息。因此，建立连接的延迟可能会影响 HTTP 事务的性能。 往返时间（RTT）延迟：RTT 是客户端发送请求到服务器并接收响应的时间。较高的 RTT 延迟可能会导致 HTTP务的响应时间增加。 拥塞窗口延迟：TCP 使用拥塞控制">
<meta property="og:type" content="article">
<meta property="og:title" content="Web 前端开发-14-期末总结">
<meta property="og:url" content="https://eaglebear2002.github.io/50241/index.html">
<meta property="og:site_name" content="EagleBear2002 的博客">
<meta property="og:description" content="问答题例题 影响 http 事务的 TCP 相关延迟 以下内容来自 chatGPT：   建立连接延迟：在客户端和服务器之间建立 TCP 连接需要时间，包括发送和接收握手消息。因此，建立连接的延迟可能会影响 HTTP 事务的性能。 往返时间（RTT）延迟：RTT 是客户端发送请求到服务器并接收响应的时间。较高的 RTT 延迟可能会导致 HTTP务的响应时间增加。 拥塞窗口延迟：TCP 使用拥塞控制">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-21T07:57:00.000Z">
<meta property="article:modified_time" content="2025-10-02T04:11:35.726Z">
<meta property="article:author" content="EagleBear2002">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eaglebear2002.github.io/50241/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Web 前端开发-14-期末总结 | EagleBear2002 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<script>
  hljs.initLineNumbersOnLoad();
</script>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EagleBear2002 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里必须根绝一切犹豫，这里任何怯懦都无济于事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">61</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">481</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eaglebear2002" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eaglebear2002.github.io/50241/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="EagleBear2002">
      <meta itemprop="description" content="暮雪朝霜，毋改英雄意气">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EagleBear2002 的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Web 前端开发-14-期末总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-21 15:57:00" itemprop="dateCreated datePublished" datetime="2023-02-21T15:57:00+08:00">2023-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-02 12:11:35" itemprop="dateModified" datetime="2025-10-02T12:11:35+08:00">2025-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">南京大学软件学院本科课程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/2022Fall-Web-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">2022Fall-Web 前端开发</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="问答题例题">问答题例题</h2>
<h3 id="影响-http-事务的-TCP-相关延迟">影响 http 事务的 TCP 相关延迟</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<ol>
<li>建立连接延迟：在客户端和服务器之间建立 TCP 连接需要时间，包括发送和接收握手消息。因此，建立连接的延迟可能会影响 HTTP 事务的性能。</li>
<li>往返时间（RTT）延迟：RTT 是客户端发送请求到服务器并接收响应的时间。较高的 RTT 延迟可能会导致 HTTP务的响应时间增加。</li>
<li>拥塞窗口延迟：TCP 使用拥塞控制算法来防止网络拥塞。当网络拥塞时，TCP 将减小拥塞窗口大小以降低数据包的发送速率。这种拥塞窗口大小的调整可能会导致 HTTP 事务的响应时间变化。</li>
<li>重传延迟：如果 TCP 数据包在传输过程中丢失或损坏，TCP 将重传数据包。重传可能会导致 HTTP 事务的响应时间延迟，因为它需要额外的时间来等待数据包的重传和重新处理。</li>
<li>关闭连接延迟：当 HTTP 事务完成时，客户端和服务器之间需要关闭 TCP 连接。关闭连接需要时间，包括发送和接收关闭消息。因此，关闭连接的延迟可能会影响 HTTP 事务的性能。</li>
</ol>
</blockquote>
<h3 id="对-meta-标签的理解">对 <code>&lt;meta&gt;</code> 标签的理解</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p><code>&lt;meta&gt;</code> 标签是一种 HTML 标签，用于为 HTML 文档提供元数据信息。元数据是描述数据的数据，它提供了有关文档的信息，如文档的描述、作者、关键字、编码方式和其他有关文档的信息。</p>
<p>以下是一些常用的<code>&lt;meta&gt;</code>标签及其作用：</p>
<ul>
<li><code>&lt;meta charset&gt;</code>：指定 HTML 文档的字符编码方式，以确保浏览器正确地解析和显示文档内容。</li>
<li><code>&lt;meta name=&quot;viewport&quot;&gt;</code>：指定视口（viewport）的大小和缩放比例，以确保文档在不同设备上的显示效果一致。</li>
<li><code>&lt;meta name=&quot;description&quot;&gt;</code>：提供网页的描述信息，用于 SEO（搜索引擎优化）。</li>
<li><code>&lt;meta name=&quot;keywords&quot;&gt;</code>：提供网页的关键字信息，用于 SEO。</li>
<li><code>&lt;meta name=&quot;robots&quot;&gt;</code>：指示搜索引擎是否应该抓取该页面以及如何抓取和索引页面内容。</li>
<li><code>&lt;meta http-equiv   &gt;</code>：提供 HTTP 头信息，例如指定缓存策略、重定向和刷新。</li>
</ul>
<p>除了上述常用的<code>&lt;meta&gt;</code>标签外，还有许多其他类型的<code>&lt;meta&gt;</code>标签，用于指定文档的作者、创建日期、更新日期、版权信息等等。</p>
<p>使用<code>&lt;meta&gt;</code>标签可以为 HTML 文档提供有用的元数据信息，以提高文档在搜索引擎中的排名，改善文档的可读性，以及提供其他的功能。</p>
</blockquote>
<h3 id="优雅降级和渐进增强">优雅降级和渐进增强</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>优雅降级（Graceful Degradation）和渐进增强（Progressive Enhancement）是 Web 设计和开发中常用的两种策略。</p>
<p>优雅降级指的是设计人员先针对高级浏览器和设备设计和开发网站，然后再通过检测低级浏览器或设备功能来逐步降低网站的功能。例如，一个使用 HTML5 和 CSS3 技术开发的网站，可以通过使用 JavaScript 来检测浏览器是否支持这些技术，如果不支持，就降低网站的一些高级功能，以保证在低级浏览器上正常运行。优雅降级的思想是先为高级浏览器和设备提供更好的用户体验，然后再为低级浏览器提供一种可用的解决方案。</p>
<p>渐进增强则是指设计人员先针对低级浏览器和设备设计和开发网站，然后再通过检测高级浏览器或设备功能来逐步增强网站的功能。例如，一个使用 HTML 和 CSS 技术开发的网站，可以通过使用 JavaScript 来检测浏览器是否支持 CSS3 技术，如果支持，就增加网站的一些高级功能，以提供更好的用户体验。渐进增强的思想是先为低级浏览器提供可用的解决方案，然后再为高级浏览器提供更好的用户体验。</p>
<p>总的来说，优雅降级和渐进增强都是为了在不同的浏览器和设备上提供更好的用户体验，只是采取的策略不同。选择哪种策略取决于设计人员和开发人员的具体需求和目标。</p>
</blockquote>
<h3 id="use-strict-的含义和原因">use strict 的含义和原因</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>&quot;use strict&quot; 是一种 ECMAScript 5 中的指令（directive），它告诉 JavaScript 引擎以严格模式（strict mode）解析 JavaScript 代码。严格模式是一种 JavaScript 执行模式，它对 JavaScript 语言的某些部分施加了更严格的限制，从而帮助开发人员编写更加健壮、安全的代码。</p>
<p>使用 use strict 指令的原因有以下几点：</p>
<ol>
<li>增强代码安全性：在严格模式下，某些可能引起安全问题的代码将会被禁止，例如不能使用 <code>eval()</code> 函数，也不能使用 with 语句。这可以避免一些安全漏洞，提高代码的安全性。</li>
<li>消除代码歧义：在严格模式下，某些不规范的代码行为将被禁止，例如不能在未声明的变量上进行赋值操作。这可以消除代码中一些不必要的歧义，提高代码的可读性和可维护性。</li>
<li>提高性能：在严格模式下，JavaScript 引擎可以进行更加严格的优化，从而提高代码的性能。</li>
</ol>
<p>总之，使用&quot;use strict&quot;指令可以帮助开发人员编写更加健壮、安全、可读性强、性能更高的 JavaScript 代码，从而提高代码的质量和可维护性。</p>
</blockquote>
<h3 id="HTTP-缓存的分类和使用方式">HTTP 缓存的分类和使用方式</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>HTTP 缓存是指客户端（浏览器）或服务器在请求或响应 HTTP 资源时，保存一份副本（或缓存）以便以后重复使用，从而减少网络流量和提高响应速度。HTTP 缓存主要分为两种类型：客户端缓存和服务端缓存。</p>
<ol>
<li>客户端缓存：客户端缓存指的是浏览器或其他客户端设备保存 HTTP 资源的副本，以便在以后的请求中重复使用。常见的客户端缓存方式包括：
<ul>
<li>强缓存：客户端通过 Cache-Control 和 Expires 响应头来缓存资源。当资源处于缓存期间内，浏览器不会向服务器发起请求，而是直接使用缓存的资源。如果缓存已经过期，则浏览器会向服务器发起请求。</li>
<li>协商缓存：客户端通过 Last-Modified 和 Etag 响应头来缓存资源。当资源处于缓存期间内，浏览器会向服务器发起请求，但服务器会比较资源的修改时间或标识符，如果资源未发生变化，则服务器会返回 304 状态码，告诉浏览器直接使用缓存的资源。</li>
</ul>
</li>
<li>服务端缓存：服务端缓存指的是服务器端保存 HTTP 资源的副本，以便在后续的请求中重复使用。常见的服务端缓存方式包括：
<ul>
<li>页面缓存：服务器将动态生成的页面缓存到内存或磁盘中，以便在后续请求中直接使用缓存的页面。</li>
<li>数据库缓存：服务器将数据库中的查询结果缓存到内存或磁盘中，以便在后续请求中直接使用缓存的结果。</li>
<li>CDN 缓存：服务器将 HTTP 资源分发到全球各地的 CDN 节点，以便用户从就近的 CDN 节点获取缓存的资源，减少网络延迟和流量消耗。</li>
</ul>
</li>
</ol>
<p>HTTP 缓存的使用可以大大提高 Web 应用的响应速度和用户体验，降低服务器和网络的负载。但是，缓存也可能带来一些副作用，例如缓存数据不及时更新、缓存过期时间设置不合理等。因此，开发人员需要根据具体的应用场景和需求，合理选择缓存策略，避免出现不必要的问题。</p>
</blockquote>
<h3 id="前端框架的种类、优势和选型">前端框架的种类、优势和选型</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>前端框架是用于开发 Web 应用程序的工具集，可以帮助开发人员更高效、更方便地构建 Web 应用程序。常见的前端框架包括：</p>
<ol>
<li>React：React 是由 Facebook 开发的 JavaScript 库，用于构建用户界面。它采用组件化的思想，将 UI 分解成独立的、可重用的部件。React 具有高效、快速、简单、灵活等优点，广泛应用于单页面应用程序（SPA）和移动应用程序的开发。</li>
<li>Vue：Vue 是由尤雨溪开发的渐进式 JavaScript 框架，也用于构建用户界面。Vue 具有易用性、灵活性、高性能等优点，适用于大型和小型项目，广泛应用于 Web 应用程序的开发。</li>
<li>Angular：Angular 是由 Google 开发的完整的 Web 应用程序框架，也用于构建用户界面。Angular 具有模块化、高效、可维护性等优点，但也需要一定的学习成本和开发时间。</li>
<li>jQuery：jQuery 是一种流行的 JavaScript 库，用于简化 Web 开发。它提供了丰富的 API 和插件，可以快速开发交互式 Web 应用程序。</li>
</ol>
<p>使用前端框架的主要优势如下：</p>
<ol>
<li>提高开发效率：前端框架提供了丰富的功能和组件，可以帮助开发人员更快速、更高效地完成任务。</li>
<li>提高代码质量：前端框架提供了一些最佳实践和规范，可以帮助开发人员编写更好的代码，提高代码质量和可维护性。</li>
<li>跨平台支持：一些前端框架可以支持多个平台，如 Web、移动端和桌面应用程序等，可以提高应用程序的可用性和可访问性。</li>
<li>社区支持：前端框架拥有庞大的社区，可以提供技术支持、文档和示例等，有助于开发人员解决问题和学习新技术。</li>
<li>适应性强：前端框架可以适应不同的应用场景和需求，如单页应用、响应式布局、移动端应用等，有助于开发人员快速开发出适应不同场景的应用程序。</li>
</ol>
<p>选型时，需要考虑以下因素：</p>
<ol>
<li>项目需求：不同的项目有不同的需求，需要根据实际情况选择合适的框架。</li>
<li>技术水平：不同的框架有不同的学习曲线，需要考虑开发人员的技术水平和团队协作。</li>
<li>性能：不同的框架在性能方面有所差异，需要根据实际需求选择适合的框架。</li>
<li>社区支持：框架的社区支持对开发人员很重要，可以帮助他们解决问题和学习新技术。</li>
</ol>
<p>总体来说，选用合适的前端框架可以提高 Web 应用程序的开发效率和质量，但需要根据实际情况进行权衡和选择。</p>
</blockquote>
<h3 id="Ajax-的背景、原理、优缺点，比较不同的数据格式（不考）">Ajax 的背景、原理、优缺点，比较不同的数据格式（不考）</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>Ajax 的出现主要解决了传统的同步请求的问题，即当浏览器向服务器发送请求时，必须等待服务器返回数据才能继续操作，这会导致用户体验变差。而 Ajax 可以<strong>异步请求数据</strong>，不需要等待服务器响应，可以让用户在等待过程中继续进行其他操作，提高了用户体验。</p>
<p>Ajax 的原理是通过 JavaScript 代码发送 HTTP 请求到服务器，接收服务器返回的数据，然后使用 JavaScript <strong>动态更新</strong>页面内容。Ajax 的优点包括：</p>
<ol>
<li>提高用户体验：异步请求可以让用户在等待过程中继续操作页面，提高用户体验。</li>
<li>减少带宽消耗：Ajax 只请求需要的数据，减少了不必要的数据传输，减少了带宽消耗。</li>
<li>提高网站性能：Ajax 可以减少页面刷新次数，减少了服务器负载和网络延迟，提高了网站性能。</li>
<li>支持多种数据格式：Ajax 可以支持多种数据格式，如 XML、JSON 等，方便开发人员使用。</li>
</ol>
<p>Ajax 的缺点包括：</p>
<ol>
<li>对搜索引擎不友好：由于 Ajax 是异步请求数据，搜索引擎难以获取到页面内容，影响 SEO。</li>
<li>安全性问题：如果没有合适的安全措施，Ajax 请求容易受到跨站点脚本攻击。</li>
<li>代码复杂性：使用 Ajax 需要编写复杂的 JavaScript 代码，需要一定的技术水平。</li>
</ol>
<p>不同的数据格式包括 XML 和 JSON，它们都可以用于 Ajax 请求。相比之下，JSON 更加轻量级和易于解析，是一种更流行的数据格式。JSON 的优点包括：</p>
<ol>
<li>轻量级：JSON 是一种轻量级数据格式，比 XML 更加简单。</li>
<li>易于解析：JSON 可以很容易地解析为 JavaScript 对象，方便开发人员使用。</li>
<li>流行度高：JSON 在现代 Web 应用中广泛使用，有更好的支持和文档。</li>
</ol>
<p>而 XML 的优点包括：</p>
<ol>
<li>可扩展性：XML 具有可扩展性，可以定义自己的元素和属性，更加灵活。</li>
<li>支持多种数据类型：XML 支持多种数据类型，如文本、数字、日期等。</li>
<li>更好的文档支持：XML 有更好的文档支持，支持 XSLT 转换等技术。</li>
</ol>
<p>在实际开发中，开发人员需要根据具体的应用场景和数据需求选择适合的数据格式。</p>
</blockquote>
<h3 id="let、const-和-var-的区别"><code>let</code>、<code>const</code> 和 <code>var</code> 的区别</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p><code>let</code>、<code>const</code> 和 <code>var</code> 是 JavaScript 中用于声明变量的关键字。它们之间的区别主要有以下几个方面：</p>
<ol>
<li>作用域：<code>let</code> 和 <code>const</code> 声明的变量具有块级作用域，而 <code>var</code> 声明的变量具有函数级作用域。块级作用域指的是花括号 <code>{}</code> 内的代码块，函数级作用域指的是函数内的代码块。</li>
<li>变量提升：<code>var</code> 声明的变量存在变量提升现象，即变量可以在声明前使用；而 <code>let</code> 和 <code>const</code> 声明的变量不存在变量提升，必须先声明后使用，否则会报错。</li>
<li>重复声明：<code>var</code> 可以重复声明同名变量，后声明的变量会覆盖先声明的变量；而 <code>let</code> 和 <code>const</code> 不允许重复声明同名变量，否则会报错。</li>
<li>赋值方式：<code>let</code> 和 <code>var</code> 声明的变量可以重新赋值，而 <code>const</code> 声明的变量是常量，不能重新赋值。</li>
<li>初始化：<code>let</code> 和 <code>var</code> 声明的变量可以不初始化而直接声明，此时变量的值为 <code>undefined</code>；而 <code>const</code> 声明的变量必须进行初始化赋值，否则会报错。</li>
</ol>
</blockquote>
<p>即：<code>let</code> 声明方式类似 C 语言中局部变量声明，<code>const</code> 声明方式类似 C 语言中局部常量声明，<code>var</code> 则类似全局（函数内）变量声明。</p>
<h3 id="描述变量提升和暂时性死区">描述变量提升和暂时性死区</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>变量提升是 JavaScript 中的一个特性，指的是在代码执行前，JavaScript 引擎会将声明的变量提升到当前作用域的顶部，使其在当前作用域内任何位置都可以访问。也就是说，无论变量声明语句在哪里，都会被视为在作用域顶部声明的变量。</p>
<p>例如，以下代码中的 <code>x</code> 变量可以在声明语句之前使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>这段代码等价于以下代码，其中变量声明被提升到了作用域顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// undefined</span><br>x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>暂时性死区（Temporal Dead Zone，简称 TDZ）指的是在代码块中使用 <code>let</code> 或 <code>const</code> 声明的变量，从声明语句开始到实际声明之前的这段时间内，变量是不能被访问或使用的。如果在 TDZ 中访问这个变量，会抛出一个 <code>ReferenceError</code> 错误（类似 Java 中的 <code>NullPointError</code>）。</p>
<p>例如，以下代码中的 <code>x</code> 变量在声明语句之前被访问，会抛出 <code>ReferenceError</code> 错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>这段代码等价于以下代码，其中 <code>x</code> 变量在 TDZ 中，不能被访问：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x; <span class="hljs-comment">// TDZ 开始</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span><br>x = <span class="hljs-number">10</span>; <span class="hljs-comment">// TDZ 结束，变量初始化</span><br></code></pre></td></tr></table></figure>
<p>暂时性死区的存在使得 JavaScript 中的变量声明更加规范和严谨，避免了在变量未初始化时就使用变量的情况。同时，变量提升和暂时性死区也会对代码的理解和调试带来一定的挑战，需要开发者熟练掌握相关知识。</p>
</blockquote>
<h3 id="什么是持久连接？在-http1-0-和-1-1-中是如何描述的？">什么是持久连接？在 http1.0+和 1.1 中是如何描述的？</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>在 HTTP 协议中，持久连接（Persistent Connection），也称为 HTTP Keep-Alive，是指在一个 HTTP 会话中，客户端和服务器之间可以发送多个请求和响应，而不必为每个请求和响应都创建新的连接。</p>
<p>在 HTTP/1.0 中，每个请求和响应都需要独立的 TCP 连接，请求结束后立即关闭连接，这会带来一些问题，例如在请求频繁的场景下会造成不必要的 TCP 连接开销，从而影响性能。</p>
<p>为了解决这个问题，HTTP/1.1 引入了持久连接的概念，即使用同一个 TCP 连接可以传输多个请求和响应，而不是每次请求都要重新建立连接。HTTP/1.1 规定了持久连接的默认行为，即默认情况下所有的连接都是持久连接，除非明确指定关闭连接。在 HTTP/1.1 中，可以在请求头中添加 <code>Connection: keep-alive</code> 来指定持久连接，或者 <code>Connection: close</code> 来指定关闭连接。</p>
<p>持久连接的好处在于可以减少 TCP 连接的建立和关闭次数，从而减少网络开销和延迟，提高性能。同时，持久连接还支持管线化（Pipeline），即发送多个请求到服务器，而不必等待服务器的响应，这可以进一步提高效率。</p>
<p>需要注意的是，虽然 HTTP/1.1 中默认开启了持久连接，但是仍然需要注意连接的过期时间，即空闲超时时间，如果连接在规定时间内没有被使用，服务器会关闭连接，以节省资源。为了避免这种情况，可以在请求头中添加 <code>Keep-Alive</code> 字段，并指定一个适当的超时时间，以保证连接一直保持活动状态。</p>
</blockquote>
<h3 id="说明-session-和-cookie-的区别">说明 session 和 cookie 的区别</h3>
<p>cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。</p>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>Session 和 Cookie 都是用于在 Web 应用中保持状态的机制，但它们的实现方式和使用场景略有不同。</p>
<p>Session 是一种服务器端的状态管理机制，它通过在服务器上创建一个唯一的会话 ID 来识别和跟踪用户的状态信息，服务器将这个 ID 存储在一个临时文件或者数据库中，与用户在客户端的交互操作相关联。每次用户发起请求时，服务器会根据会话 ID 来判断用户的状态并进行相应的处理，用户并不直接接触到会话 ID。</p>
<p>相比之下，Cookie 是一种客户端的状态管理机制，它将用户的状态信息保存在客户端浏览器中的一个文本文件中。当用户访问 Web 应用时，Web 服务器可以通过在 HTTP 响应头中添加 Set-Cookie 字段来向客户端发送 Cookie，客户端浏览器将 Cookie 存储在本地，并在后续请求中通过在 HTTP 请求头中添加 Cookie 字段来发送 Cookie，从而告诉服务器自己的状态信息。因此，Cookie 直接暴露在客户端，用户可以查看和修改它们，而且每个 Cookie 都有其特定的有效期。</p>
<p>下面是 Session 和 Cookie 的一些区别：</p>
<ul>
<li>存储位置：Session 存储在服务器端，Cookie 存储在客户端。</li>
<li>安全性：由于 Session 数据存储在服务器端，相对更加安全，而 Cookie 存储在客户端，存在被篡改的风险。</li>
<li>存储容量：Session 存储容量相对更大，可以存储一些较为敏感的数据，而 Cookie 由于存储在客户端，所以存储容量相对较小。</li>
<li>跨域支持：Cookie 支持跨域操作，而 Session 不支持跨域操作。</li>
<li>传输流量：由于每次请求都会带上 Cookie 数据，因此 Cookie 可能会增加传输流量，而 Session 不会增加传输流量。</li>
</ul>
<p>需要注意的是，Session 和 Cookie 通常是配合使用的。服务器可以通过将 Session ID 保存在 Cookie 中，并将其发送给客户端，来使客户端在后续的请求中发送 Session ID，从而保持状态。这种方式被称为 Cookie Session，它克服了 Session 和 Cookie 各自的缺点，是一种常用的 Web 应用状态管理方式。</p>
</blockquote>
<h3 id="在浏览器和-web-服务器之间传送数据的方式有几种">在浏览器和 web 服务器之间传送数据的方式有几种</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>在浏览器和 Web 服务器之间传送数据的方式主要有以下几种：</p>
<ol>
<li>HTTP GET 请求：浏览器通过 HTTP GET 请求向服务器请求数据，服务器将数据作为 HTTP 响应的一部分返回给浏览器。该方式适用于请求数据量较小的场景，且请求的数据可以在 URL 中传递。</li>
<li>HTTP POST 请求：与 HTTP GET 请求不同，HTTP POST 请求将请求数据放在 HTTP 请求体中发送给服务器。该方式适用于请求数据量较大，且请求数据无法通过 URL 传递的场景。</li>
<li>HTTP PUT 请求：用于向服务器上传文件或更新资源，类似于 HTTP POST 请求，但通常用于更新服务器上的数据而不是创建新数据。</li>
<li>HTTP DELETE 请求：用于从服务器上删除资源，例如删除用户数据、文件等。</li>
<li>WebSockets：WebSockets 是一种基于 TCP 协议的双向通信协议，允许浏览器和服务器之间进行实时通信。与 HTTP 请求不同，WebSockets 连接建立后保持打开状态，可以随时从服务器接收数据。</li>
<li>Server-Sent Events (SSE)：SSE 是一种浏览器与服务器之间单向通信协议，允许服务器向客户端发送事件流。当服务器上的数据发生变化时，它可以向客户端发送新的事件，这些事件可以是文本、JSON 数据等。</li>
<li>WebRTC：WebRTC 是一种浏览器技术，允许实时音频、视频和数据通信。它通过 Peer-to-Peer 技术实现，不需要通过服务器转发数据，因此具有较低的延迟和更高的安全性。</li>
</ol>
</blockquote>
<h3 id="如何理解-html-结构的语义化">如何理解 html 结构的语义化</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>HTML 语义化是指在编写 HTML 代码时，使用恰当的标签、元素和属性，以便更好地描述文档的结构和内容。</p>
<p>具体来说，HTML 语义化可以通过以下方式实现：</p>
<ol>
<li>使用恰当的 HTML 标签：在 HTML 中，不同的标签用于表示不同的元素。例如，<code>&lt;h1&gt;</code> 标签表示页面中的主标题，<code>&lt;p&gt;</code> 标签表示段落。通过选择合适的标签，可以更好地描述文档的结构和内容。</li>
<li>为内容添加恰当的属性：HTML 元素可以使用属性来描述它们的内容和特征。例如，<code>&lt;img&gt;</code> 元素可以使用 <code>alt</code> 属性来提供替代文本，以便在图像无法显示时向用户提供信息。</li>
<li>编写良好的文本内容：在编写 HTML 代码时，需要注意文本内容的格式和结构。例如，应该避免使用无意义的标题和段落，而应该编写清晰、有意义的文本内容。</li>
</ol>
<p>通过遵循这些原则，可以更好地描述文档的结构和内容，提高文档的可访问性和可读性，并有助于搜索引擎更好地理解页面的内容，从而提高网站的排名和流量。</p>
<p>总的来说，HTML 语义化是一种良好的编程实践，有助于提高网站的可访问性、可读性和可维护性，同时还有助于提高搜索引擎优化 (SEO) 的效果。</p>
</blockquote>
<h3 id="CSS-规则的优先级算法是如何计算的">CSS 规则的优先级算法是如何计算的</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>CSS 规则的优先级算法是用来确定在多个 CSS 规则中，哪些规则会应用到特定的 HTML 元素上。该算法根据规则的选择器的特定性、权重和来源进行计算。</p>
<p>CSS 规则的优先级按以下顺序递减：</p>
<ol>
<li>根据选择器的<strong>特定性</strong>进行比较，特定性值越高的选择器优先级越高。通常情况下，特定性值的计算方法是：
<ul>
<li>对于每个 ID 选择器，特定性值加 100。</li>
<li>对于每个类选择器、属性选择器或伪类选择器，特定性值加 10。</li>
<li>对于每个元素选择器或伪元素选择器，特定性值加 1。</li>
<li>通配选择器的特定性值为 0。</li>
</ul>
</li>
<li>如果两个选择器的特定性相同，则根据它们的权重进行比较，<strong>权重越高</strong>的选择器优先级越高。CSS 规则的权重通常由选择器中 ID、类、属性选择器、伪类选择器、元素选择器和伪元素选择器的数量决定，权重高的规则会覆盖权重低的规则。</li>
<li>如果两个选择器的特定性和权重都相同，则根据它们的来源进行比较，以<strong>最后出现的</strong>规则为准。因此，如果多个 CSS 文件中有相同的规则，并且它们的特定性和权重相同，那么最后加载的 CSS 文件中的规则会覆盖之前加载的文件中的规则。</li>
</ol>
<p>需要注意的是，<code>!important</code> 关键字可以覆盖所有其他规则，包括特定性、权重和来源。因此，应该避免过度使用 <code>!important</code>，以免影响样式的可维护性和扩展性。</p>
<p>总的来说，CSS 规则的优先级算法是一个复杂的计算过程，但是理解该算法对于编写优秀的 CSS 样式表和优化样式表性能非常重要。</p>
</blockquote>
<h3 id="为何在处理-XHTML-表单中数据验证如此重要？有几种验证方式，比较之">为何在处理 XHTML 表单中数据验证如此重要？有几种验证方式，比较之</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>在处理 XHTML 表单中数据验证非常重要，因为数据验证可以确保用户输入的数据符合所需的格式和类型，以及确保输入的数据安全可靠。不进行数据验证会导致无法预料的结果，可能会破坏网站的功能或者造成安全隐患。</p>
<p>以下是几种验证方式的比较：</p>
<ol>
<li>客户端验证：客户端验证是指在用户提交表单之前，通过 JavaScript 等前端技术对用户输入进行验证。这种方式可以快速地给出反馈，避免了不必要的网络请求，但是不能保证安全，容易被恶意攻击者绕过验证。</li>
<li>服务端验证：服务端验证是指在服务器端对用户提交的数据进行验证。这种方式可以确保数据的安全性，但是需要向服务器发起请求，需要等待服务器响应，影响用户体验。</li>
<li>HTML5 表单验证：HTML5 提供了一些新的表单元素和属性，例如 required、pattern、min、max 等，可以在客户端进行表单验证。这种方式可以在不需要 JavaScript 的情况下进行验证，但是不支持所有浏览器，需要进行兼容性处理。</li>
<li>正则表达式验证：使用正则表达式可以对用户输入进行复杂的验证，例如验证邮箱、手机号、身份证号等。这种方式可以在客户端和服务端都进行验证，但是需要编写复杂的正则表达式，容易出错。</li>
</ol>
<p>综上所述，可以使用多种验证方式来确保数据的正确性和安全性，其中客户端验证和服务端验证结合使用可以达到最好的效果。客户端验证可以提高用户体验和性能，服务端验证可以确保数据的安全性和可靠性。同时，HTML5 表单验证和正则表达式验证可以作为辅助手段，提高表单验证的准确性和效率。</p>
</blockquote>
<h3 id="试述-bigpipe-技术的基本原理">试述 bigpipe 技术的基本原理</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>BigPipe 技术是一种用于加速网页响应时间的前端优化技术。它的基本原理是将一个完整的页面分割成若干个小块，每个小块独立生成，独立传输和独立渲染，从而实现多个小块的并行处理，提高页面加载速度和响应速度。</p>
<p>具体来说，BigPipe 技术包含以下几个步骤：</p>
<ol>
<li>服务器端渲染：在服务器端将页面分割成多个小块，并根据不同的块生成对应的 HTML 和数据。</li>
<li>分块传输：将生成的每个小块分别传输到客户端。传输方式可以使用 AJAX 或者 iframe 等技术，从而实现并行传输。</li>
<li>客户端渲染：在客户端接收到每个小块后，立即渲染，从而减少用户等待时间，提高响应速度。</li>
<li>合并渲染：在所有小块都传输完毕后，将它们合并成一个完整的页面。在这个过程中，可以使用 JavaScript 技术来实现页面的最终渲染，例如将各个小块的 HTML 和 CSS 合并成一个整体，从而提高页面的响应速度。</li>
</ol>
<p>总之，BigPipe 技术是一种有效的前端优化技术，它利用分块传输和并行处理的方式来提高网页的加载速度和响应速度，提高用户体验。</p>
</blockquote>
<h3 id="CSS-sprite-是什么？-谈谈这个技术的优缺点">CSS sprite 是什么？ 谈谈这个技术的优缺点</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>CSS Sprite 是一种前端优化技术，它通过将多张小图片合并成一张大图片，然后利用 CSS 中的 <code>background-position</code> 属性来显示需要的小图片，从而减少 HTTP 请求次数，提高页面的加载速度和响应速度。</p>
<p>下面是 CSS Sprite 技术的一些优缺点：</p>
<p>优点：</p>
<ul>
<li>减少 HTTP 请求：将多个小图片合成一张大图片，可以减少 HTTP 请求次数，提高页面的加载速度和响应速度。</li>
<li>减小图片大小：将多个小图片合成一张大图片后，可以减少图片的大小，从而减少页面的带宽消耗，提高用户体验。</li>
<li>提高用户体验：减少 HTTP 请求次数和页面加载时间，可以提高用户的访问体验和用户满意度。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要额外的工作：将多个小图片合成一张大图片需要额外的工作，包括制作大图、编写 CSS 等，增加了前端开发的工作量。</li>
<li>不适用于所有场景：如果页面上的小图片较少，使用 CSS Sprite 技术并不能带来太大的性能提升。</li>
<li>维护成本较高：如果需要更新页面上的某个小图片，需要重新制作大图和修改 CSS，维护成本较高。</li>
</ul>
<p>总之，CSS Sprite 技术是一种有效的前端优化技术，通过减少 HTTP 请求次数和图片大小来提高页面的加载速度和响应速度，但是需要额外的工作和维护成本。在具体使用时，需要根据实际情况进行考虑和权衡。</p>
</blockquote>
<h3 id="什么是网站重构？为何要重构？列举网站性能优化的手段">什么是网站重构？为何要重构？列举网站性能优化的手段</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>网站重构是指对现有的网站代码进行重新设计、重新构建的过程，目的是提升网站性能、提高用户体验、提高网站的可维护性和可扩展性等方面。</p>
<p>网站重构的主要原因包括：</p>
<ul>
<li>网站需要适应新的需求或新的技术。</li>
<li>网站需要更好的性能和用户体验。</li>
<li>网站需要更好的可维护性和可扩展性。</li>
<li>网站需要更好的可访问性。</li>
</ul>
<p>网站性能优化的手段包括：</p>
<ul>
<li>减少 HTTP 请求次数，通过合并和压缩 CSS、JavaScript 和图片等静态资源，以及通过使用 HTTP 缓存等机制来优化页面加载性能。</li>
<li>优化 JavaScript 的执行，通过减少 DOM 操作和减少重排重绘等方式来优化页面渲染性能。</li>
<li>优化图片的加载，通过使用适当的图片格式和图片压缩等方式来优化页面的加载性能。</li>
<li>优化 CSS 的加载，通过避免使用 <code>@import</code> 和使用合适的选择器等方式来优化 CSS 的加载性能。</li>
<li>使用 CDN（内容分发网络）来加速静态资源的加载，从而提高页面的加载速度。</li>
<li>使用响应式设计和优化移动端体验，以提高网站的可用性和用户体验。</li>
<li>使用服务器端缓存和 HTTP 缓存等机制来减少服务器响应时间和提高页面的加载速度。</li>
</ul>
<p>以上是一些常用的网站性能优化手段，通过综合使用这些手段，可以有效地提升网站的性能和用户体验。</p>
</blockquote>
<h3 id="为什么不建议-table-布局">为什么不建议 table 布局</h3>
<p>加载慢、书写复杂、不利于开发思维。</p>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>在网页布局中，table 布局曾经是一种非常流行的布局方式，主要是因为它能够提供相对简单的方法来实现复杂的布局。但是，随着 HTML 和 CSS 标准的发展，现在已经不建议使用 table 布局了，主要有以下几个原因：</p>
<ol>
<li>语义化：表格应该只用于展示表格数据，而不应该被用作页面布局。使用 table 布局来实现页面布局会导致代码结构不够清晰，难以维护和扩展，并且不符合 HTML 的语义化要求。</li>
<li>可访问性：使用 table 布局可能会导致屏幕阅读器读取网页时出现问题，这会影响到网站的可访问性。</li>
<li>性能问题：使用 table 布局可能会导致页面加载速度变慢，因为浏览器需要先解析整个表格，然后才能渲染页面。而使用 CSS 布局可以减少页面加载时间，提高用户体验。</li>
<li>响应式设计：在现代的响应式设计中，网页需要根据不同设备的屏幕大小和分辨率进行自适应布局。使用 table 布局会使这一过程变得困难和复杂，而使用 CSS 布局则能够更好地支持响应式设计。</li>
</ol>
<p>综上所述，虽然 table 布局在过去曾经是一种流行的布局方式，但现在已经不建议使用了，开发者应该尽可能地使用 CSS 布局来实现网页布局。</p>
</blockquote>
<h3 id="为什么使用-css">为什么使用 css</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>CSS（层叠样式表）是一种用于样式设计的语言，它用于控制网页的布局和外观，可以通过样式设置改变网页中的文本、图像和其他元素的颜色、字体、大小、对齐方式和间距等。使用 CSS 有以下几个优点：</p>
<ol>
<li>分离内容和样式：使用 CSS 可以将文档内容和样式分离，使得网页的结构更清晰，代码更易于维护和修改。</li>
<li>提高网页加载速度：CSS 样式文件可以缓存，减少了网页加载时需要下载的文件数量和大小，从而提高了网页的加载速度。</li>
<li>提高可访问性：使用 CSS 可以将网页的结构和样式分开，使得页面内容更易于被搜索引擎索引和屏幕阅读器等工具读取，提高了网站的可访问性。</li>
<li>可以使得页面的样式更加灵活：使用 CSS 可以轻松地更改整个网站的外观，只需编辑 CSS 文件中的样式，不需要更改每个页面的 HTML 代码。</li>
</ol>
<p>总之，使用 CSS 可以使得网站的设计和开发更加高效、灵活、易于维护和可访问。</p>
</blockquote>
<h3 id="插件有什么坏处">插件有什么坏处</h3>
<p>支持很多复杂的特性（视频音频图像）插件可能安装失败、被禁用、被屏蔽，或者成为被攻击的对象。</p>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>插件通常是在浏览器中运行的第三方软件，它们可以为用户提供额外的功能和体验，例如广告拦截、视频播放、网页翻译、社交分享等。然而，使用插件也有一些潜在的风险和坏处，包括：</p>
<ol>
<li>安全问题：插件可能存在漏洞或者恶意代码，安装后可能会对用户的计算机和隐私造成威胁。特别是一些较老的插件可能会受到攻击，这会对用户的安全和隐私造成危险。</li>
<li>兼容性问题：一些插件可能与浏览器、操作系统或其他软件不兼容，导致浏览器崩溃、卡顿或者出现其他错误。这也会影响用户的体验和使用效果。</li>
<li>性能问题：插件可能会占用系统资源，例如内存、CPU 和网络带宽，导致浏览器运行缓慢或出现卡顿现象。特别是一些功能较为复杂或者需要大量计算的插件可能会导致浏览器变得不稳定或者崩溃。</li>
<li>用户体验问题：一些插件可能会干扰用户的正常使用，例如在网页中强制插入广告、弹出弹窗或者更改页面样式等，这会影响用户的体验和满意度。</li>
</ol>
<p>综上所述，尽管插件可以为用户提供额外的功能和体验，但也存在安全、兼容性、性能和用户体验等多方面的问题和风险。因此，用户在安装和使用插件时应当慎重考虑，尽可能选择安全、可靠和优秀的插件，并及时更新和卸载不需要的插件。</p>
</blockquote>
<h3 id="从-SEO-的角度来解释-http-状态-301、302、404">从 SEO 的角度来解释 http 状态 301、302、404</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>从 SEO 的角度来看，HTTP 状态码是指当浏览器向服务器发出请求后，服务器响应的状态码，它们在 SEO 中的作用很重要。以下是三个常见的状态码及其 SEO 影响的解释：</p>
<ol>
<li>301 重定向：当页面被永久移动到了另一个 URL 时，应该使用 301 状态码。这会通知搜索引擎把旧的 URL 所有的权重（包括 PageRank）转移到新的 URL 上。这样，搜索引擎会把旧的 URL 从索引中删除，并且把新的 URL 作为替代品。在实际应用中，经常使用 301 重定向对被删掉的网页进行重定向，或对网站的页面 URL 进行优化，使得搜索引擎更好地抓取和索引网站。</li>
<li>302 临时重定向：当页面被临时移动到了另一个 URL 时，应该使用 302 状态码。它与 301 的区别在于，搜索引擎不会把权重转移到新的 URL 上，而是继续将权重分配给旧的 URL。因此，当你需要临时重定向某个页面时，不应该使用 301 状态码。</li>
<li>404 错误：当服务器无法找到请求的页面时，会返回 404 状态码。这通常是因为页面已经被删除或者请求的 URL 不正确。如果有太多的页面返回 404 状态码，可能会对 SEO 产生负面影响，因为搜索引擎会认为网站存在很多“死链接”，并且可能认为网站质量不高。为了避免这种情况，需要及时修复或删除无用的页面，并设置合适的 404 页面，以便告诉搜索引擎页面已经不存在。</li>
</ol>
</blockquote>
<h3 id="js-第三方库有什么增强功能">js 第三方库有什么增强功能</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>第三方库是指由第三方开发者编写并提供给公众使用的 JavaScript 代码库。这些库通常提供了一系列功能，以便 Web 开发人员快速搭建 Web 应用程序。</p>
<p>以下是一些常见的 JavaScript 第三方库增强功能：</p>
<ol>
<li>增强了浏览器 API：大多数第三方库都提供了一组浏览器 API 的封装，以使开发人员更容易地访问这些 API。</li>
<li>简化代码编写：第三方库可以提供一些简化编程的功能，比如简化 DOM 操作、数据存储、请求处理等。</li>
<li>提供跨浏览器兼容性：第三方库通常会处理浏览器兼容性问题，因此开发人员可以专注于业务逻辑，而无需担心在不同浏览器上运行的差异。</li>
<li>提供丰富的特性：许多第三方库提供了各种特性，如图形处理、动画效果、交互式组件等。</li>
<li>帮助优化性能：第三方库可以提供一些性能优化技术，如延迟加载、缓存、减少网络请求等，以改善 Web 应用程序的性能。</li>
<li>提供更好的代码可维护性：第三方库通常都有优秀的代码结构和编程范式，这可以提高代码的可维护性，使代码更易于调试和扩展。</li>
</ol>
<p>值得注意的是，使用第三方库也存在一些潜在的风险。如果使用不当，第三方库可能会影响网站的性能和安全性。因此，在使用第三方库时，需要认真评估库的质量和安全性，并遵循最佳实践来使用库。</p>
</blockquote>
<h3 id="js-注册-eventhandler-有哪些方式">js 注册 eventhandler 有哪些方式</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>在 JavaScript 中注册事件处理程序有多种方式，包括：</p>
<ol>
<li>HTML 属性：可以将事件处理程序作为 HTML 元素的属性来指定，例如 <code>&lt;button onclick=&quot;myFunction()&quot;&gt;Click me&lt;/button&gt;</code>，其中 <code>onclick</code> 是一个 HTML 属性，<code>myFunction()</code> 是点击按钮时将要执行的 JavaScript 函数。</li>
<li>DOM 属性：可以通过将事件处理程序函数分配给 HTML 元素的事件属性来注册事件处理程序，例如 <code>element.onclick = myFunction</code>，其中 <code>element</code> 是一个 DOM 元素，<code>onclick</code> 是一个 DOM 属性，<code>myFunction</code> 是事件处理程序函数。</li>
<li>DOM <code>addEventListener()</code> 方法：可以使用 <code>addEventListener()</code> 方法来注册事件处理程序。例如，<code>element.addEventListener('click', myFunction)</code>，其中 <code>element</code> 是一个 DOM 元素，<code>click</code> 是要注册的事件类型，<code>myFunction</code> 是事件处理程序函数。</li>
<li>DOM <code>attachEvent()</code> 方法（仅适用于旧版的 Internet Explorer 浏览器）：可以使用 <code>attachEvent()</code> 方法来注册事件处理程序。例如，<code>element.attachEvent('onclick', myFunction)</code>，其中 <code>element</code> 是一个 DOM 元素，<code>onclick</code> 是要注册的事件类型，<code>myFunction</code> 是事件处理程序函数。</li>
</ol>
<p>需要注意的是，不同的方式可能会影响事件处理程序的作用域、事件传播等行为。使用 <code>addEventListener()</code> 方法可以为同一事件注册多个处理程序，而使用 HTML 属性和 DOM 属性则不能。此外，不推荐使用 HTML 属性的方式注册事件处理程序，因为这种方式将 HTML 代码和 JavaScript 代码耦合在一起，不易于维护和扩展。</p>
</blockquote>
<h3 id="html5-新功能并列举">html5 新功能并列举</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>HTML5 带来了许多新的功能和 API，以下是一些常见的 HTML5 新功能：</p>
<ol>
<li>语义化标签：HTML5 引入了一些新的语义化标签，如 <code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;footer&gt;</code> 等，使得页面结构更加清晰明了。</li>
<li>视频和音频：HTML5 引入了 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 标签，使得在网页中嵌入视频和音频变得更加容易和方便。</li>
<li>画布和 SVG：HTML5 引入了 <code>&lt;canvas&gt;</code> 标签，使得通过 JavaScript 可以直接绘制图形和动画。同时，HTML5 还引入了 SVG 标签，使得绘制矢量图形变得更加容易。</li>
<li>本地存储：HTML5 引入了 Web 存储 API，包括 localStorage 和 sessionStorage，允许网页在客户端本地存储数据，提高网页性能。</li>
<li>Web Workers：HTML5 引入了 Web Workers API，使得在后台运行 JavaScript 代码变得更加容易，避免了阻塞 UI 线程的情况。</li>
<li>Web Sockets：HTML5 引入了 Web Sockets API，使得浏览器和服务器之间可以建立持久的、双向的通信连接，实时性更高。</li>
<li>地理位置定位：HTML5 引入了 Geolocation API，使得浏览器可以通过 GPS、Wi-Fi 或移动网络等方式获取用户的地理位置信息。</li>
<li>表单控件：HTML5 引入了许多新的表单控件，如日期选择器、颜色选择器、搜索框等，提高了用户体验。</li>
<li>拖放 API：HTML5 引入了拖放 API，使得网页元素可以轻松地被拖拽和重新排序。</li>
<li>Web Components：HTML5 引入了 Web Components 技术，包括 Custom Elements、Shadow DOM 和 HTML Templates，允许开发者自定义组件，提高代码的可复用性和可维护性。</li>
</ol>
</blockquote>
<h3 id="简述优化思路和-php-优化技巧">简述优化思路和 php 优化技巧</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>优化是指通过对系统或应用程序的调整来提高其性能、可靠性和效率。在 PHP 中，优化的目标是让应用程序更快、更可靠、更节约资源。</p>
<p>以下是一些 PHP 优化的常用技巧：</p>
<ol>
<li>使用缓存：可以使用各种缓存技术，如内存缓存、文件缓存、数据库缓存等，可以减少数据库访问，提高应用程序的性能。</li>
<li>使用 PHP 加速器：PHP 加速器是一个 PHP 扩展，它可以提高 PHP 脚本的性能。常见的 PHP 加速器有 APC、OpCache、eAccelerator 等。</li>
<li>使用多进程/线程：PHP 支持多进程和多线程，可以利用这些功能来并发处理多个请求，提高应用程序的性能。</li>
<li>减少数据库查询次数：减少数据库查询是提高应用程序性能的一个重要方法。可以通过缓存查询结果、使用索引来优化数据库查询。</li>
<li>代码优化：可以通过使用更有效的算法、避免不必要的计算、减少内存占用等方式来优化 PHP 代码。</li>
<li>避免使用全局变量：全局变量是 PHP 中性能较差的部分之一，可以使用其他方式来代替全局变量。</li>
<li>避免在循环中进行数据库查询：循环中进行数据库查询是很低效的，可以将查询结果缓存起来，在循环中使用缓存的结果。</li>
</ol>
<p>总的来说，优化的思路就是在保证功能的基础上，尽可能地减少资源的占用和提高系统的性能。</p>
</blockquote>
<h3 id="WEB3-0-的特性">WEB3.0 的特性</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>Web 3.0 是互联网发展的下一步，通常被称为“智能网”或“语义网”。相比于 Web 2.0，Web 3.0 有着更高的智能化、更高的安全性和更好的隐私保护。下面是 Web 3.0 的一些特性：</p>
<ol>
<li>去中心化：Web 3.0 将通过区块链技术实现去中心化，将互联网从中心化的架构转向分布式的架构，使用户可以直接掌控自己的数据和身份。</li>
<li>人工智能：Web 3.0 将使用人工智能来使计算机更好地理解和处理自然语言和语义信息。这将使搜索更加准确，也将为语音识别和机器翻译等技术的发展提供更好的支持。</li>
<li>语义网：Web 3.0 将使用语义技术，使机器能够理解并处理信息，进而提供更好的搜索结果和个性化推荐服务。</li>
<li>可信性：Web 3.0 将使互联网更加安全和透明，因为它将使用去中心化和区块链技术来保证数据的可信性和安全性。</li>
<li>物联网：Web 3.0 将为物联网的发展提供更好的支持，使物联网设备之间可以更加智能地交互和通信。</li>
</ol>
<p>总之，Web 3.0 将为互联网带来更加智能、更加去中心化、更加安全、更加透明的未来。</p>
</blockquote>
<h3 id="HTTP-常用请求头、状态码">HTTP 常用请求头、状态码</h3>
<ol>
<li>是 HTTP 的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。</li>
<li>与缓存相关的规则信息，均包含在 header 中</li>
</ol>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>以下是常用的 HTTP 请求头：</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>告诉服务器发送的数据类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>告诉服务器发送的字符编码类型</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>告诉服务器发送的数据压缩类型</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>告诉服务器发送的语言类型</td>
</tr>
<tr>
<td>Authorization</td>
<td>包含了认证令牌，用于服务器验证客户端身份</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>缓存控制，控制请求或响应缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>控制连接行为</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求或响应消息体的长度</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求或响应消息体的媒体类型</td>
</tr>
<tr>
<td>Cookie</td>
<td>发送服务器保存的 cookie</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器地址和端口号</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记，用于冲突检测</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>只有当修改日期晚于指定日期时，才返回实体</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记，用于缓存验证</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未被修改，发送实体；否则，发送部分</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只有当修改日期等于或早于指定日期时，才返回实体</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大转发次数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>包含了认证令牌，用于代理服务器验证客户端身份</td>
</tr>
<tr>
<td>Range</td>
<td>请求实体的字节范围</td>
</tr>
<tr>
<td>Referer</td>
<td>包含了请求的源地址</td>
</tr>
<tr>
<td>User-Agent</td>
<td>包含了发送请求的客户端应用程序的名称和版本号</td>
</tr>
</tbody>
</table>
<p>注意：以上请求头并非全部，HTTP 协议还定义了很多其他的请求头，但以上是其中比较常用的请求头。</p>
</blockquote>
<blockquote>
<p>以下是 HTTP 最常用的 20 个状态码及其含义，以 markdown 表格的形式返回，并对其中最常用的 10 个加粗显示，显示每种状态码的出现频率：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>出现频率</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>200</strong></td>
<td>OK - 请求成功</td>
<td>62.8%</td>
</tr>
<tr>
<td><strong>304</strong></td>
<td>Not Modified - 资源未被修改，可以直接使用缓存</td>
<td>9.4%</td>
</tr>
<tr>
<td><strong>301</strong></td>
<td>Moved Permanently - 请求的资源已被永久移动到新位置</td>
<td>7.8%</td>
</tr>
<tr>
<td><strong>404</strong></td>
<td>Not Found - 请求的资源不存在</td>
<td>6.7%</td>
</tr>
<tr>
<td><strong>400</strong></td>
<td>Bad Request - 请求报文存在语法错误或参数错误</td>
<td>5.5%</td>
</tr>
<tr>
<td><strong>302</strong></td>
<td>Found - 请求的资源已被临时移动到新位置</td>
<td>4.4%</td>
</tr>
<tr>
<td><strong>403</strong></td>
<td>Forbidden - 请求被拒绝访问</td>
<td>3.1%</td>
</tr>
<tr>
<td><strong>500</strong></td>
<td>Internal Server Error - 服务器内部错误</td>
<td>2.2%</td>
</tr>
<tr>
<td><strong>503</strong></td>
<td>Service Unavailable - 服务器暂时无法处理请求</td>
<td>1.4%</td>
</tr>
<tr>
<td><strong>401</strong></td>
<td>Unauthorized - 请求需要用户身份认证</td>
<td>1.2%</td>
</tr>
<tr>
<td>204</td>
<td>No Content - 请求成功，但响应报文中不含实体的主体部分</td>
<td>1.3%</td>
</tr>
<tr>
<td>201</td>
<td>Created - 请求已被实现，资源创建成功</td>
<td>0.3%</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed - 请求的 HTTP 方法不允许</td>
<td>0.6%</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable - 请求的资源无法满足客户端要求的格式</td>
<td>0.2%</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout - 请求超时</td>
<td>0.1%</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented - 服务器不支持请求的功能或请求的 HTTP 方法</td>
<td>0.1%</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway - 网关或代理服务器收到了无效的响应</td>
<td>0.1%</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout - 网关或代理服务器超时</td>
<td>0.1%</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported - 服务器不支持请求中所用的 HTTP 协议版本</td>
<td>0.1%</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="表单隐藏域的作用">表单隐藏域的作用</h3>
<ol>
<li>隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器。</li>
<li>有些时候我们要给用户一信息，让他在提交表单时提交上来以确定用户身份，如 sessionkey，等等。当然这些东西也能用 cookie 实现，但使用隐藏域就简单的多了。而且不会有浏览器不支持，用户禁用 cookie 的烦恼。</li>
<li>有些时候一个 form 里有多个提交按钮，怎样使程序能够分清楚到底用户是按那一个按钮提交上来的呢？我们就可以写一个隐藏域，然后在每一个按钮处加上 onclick=”document.form.command.value=”xx”“然后我们接到数据后先检查 command 的值就会知道用户是按的那个按钮提交上来的。</li>
<li>有时候一个网页中有多个 form，我们知道多个 form 是不能同时提交的，但有时这些 form 确实相互作用，我们就可以在 form 中添加隐藏域来使它们联系起来。</li>
<li>javascript 不支持全局变量，但有时我们必须用全局变量，我们就可以把值先存在隐藏域里，它的值就不会丢失了。</li>
<li>还有个例子，比如按一个按钮弹出四个小窗口，当点击其中的一个小窗口时其他三个自动关闭。可是 IE 不支持小窗口相互调用，所以只有在父窗口写个隐藏域，当小窗口看到那个隐藏域的值是 close 时就自己关掉。</li>
</ol>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>表单隐藏域（hidden field）是一种表单控件，它的作用是在表单中添加一些隐藏的数据，这些数据在提交表单时会被一起提交到服务器端，但是用户并不能看到这些数据。</p>
<p>常见的使用场景有：</p>
<ol>
<li>传递数据：通过隐藏域，可以在表单提交时同时提交一些额外的数据，如当前用户 ID、当前页面的来源等信息。</li>
<li>保留状态：有些页面需要保存一些状态信息，比如分页信息、搜索条件等，可以通过隐藏域来保留这些信息，以便在用户返回时恢复状态。</li>
<li>传递标识：有些表单需要在提交时传递一些标识信息，比如表单类型、操作类型等信息，可以通过隐藏域来传递这些信息。</li>
</ol>
<p>需要注意的是，由于隐藏域中的数据是明文传输的，因此不能将敏感数据放在隐藏域中。此外，用户可以通过浏览器的开发者工具等方式查看和修改隐藏域的值，因此隐藏域也不能用于安全验证等场景。</p>
</blockquote>
<h3 id="闭包是什么，适用环境？有什么缺点？">闭包是什么，适用环境？有什么缺点？</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>闭包是指在一个内部函数中，访问了外部函数的变量，从而使得这个外部函数的变量在内部函数执行完后仍然保持在内存中。换句话说，闭包是一个函数及其相关的引用环境组合而成的实体。</p>
<p>闭包的适用环境包括：</p>
<ul>
<li>实现私有成员变量或方法；</li>
<li>延长外部函数变量的生命周期；</li>
<li>封装回调函数。</li>
</ul>
<p>闭包的优点包括：</p>
<ul>
<li>使得内部函数可以访问外部函数的变量或参数，提高代码的灵活性和可重用性；</li>
<li>可以延长外部函数变量的生命周期，从而可以在不同的场景中重复使用这个变量。</li>
</ul>
<p>闭包的缺点包括：</p>
<ul>
<li>变量常驻内存，占用内存资源，如果闭包存在时间过长，可能会导致内存泄漏；</li>
<li>闭包容易造成变量引用不清楚，从而导致意料之外的结果；</li>
<li>闭包需要额外的内存来维护外部函数的变量和环境，性能可能会受到一定影响。</li>
</ul>
</blockquote>
<h3 id="CSS3-的特性">CSS3 的特性</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>CSS3 是 CSS 技术的升级版，引入了一些新的特性和模块，主要包括以下方面：</p>
<ol>
<li>选择器：新增了众多的选择器，如属性选择器、子元素选择器、相邻兄弟选择器等。</li>
<li>盒模型：引入了 box-sizing 属性，可以控制盒模型的尺寸计算方式。</li>
<li>布局：新增了 flexbox 布局模块和 grid 布局模块，可以更方便地实现响应式布局。</li>
<li>文本样式：新增了多列文本模块、文字阴影、文字渐变、文字换行控制等属性。</li>
<li>背景和边框：新增了多重背景、圆角边框、盒阴影等属性。</li>
<li>过渡和动画：新增了 transition 和 animation 属性，可以实现平滑过渡和动画效果。</li>
<li>2D/3D 转换：新增了 transform 属性，可以实现元素的旋转、缩放、位移等变换。</li>
<li>媒体查询：可以根据屏幕宽度、分辨率等属性，对不同设备进行样式控制。</li>
</ol>
<p>CSS3 的引入，让网页的设计更加丰富多彩，同时也让开发者可以更加高效地实现网页布局、动画效果等。</p>
</blockquote>
<h3 id="跨域问题是什么？有什么解决方案？">跨域问题是什么？有什么解决方案？</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>跨域问题指的是当一个网页（或者 Web 应用）从一个域名下的文档或脚本试图去请求另一个域名下的资源时，浏览器会阻止这种行为，称为跨域。跨域问题的存在主要是由于浏览器的同源策略导致的。</p>
<p>同源策略是浏览器的一种安全策略，它的基本思想是：一个脚本只能访问和它来源相同的文档。同源策略要求文档的协议、主机名和端口号必须相同，否则就会被视为跨域。</p>
<p>解决跨域问题的方法主要有以下几种：</p>
<ol>
<li>JSONP：利用 script 标签不受同源策略的限制的特点，可以通过在页面上添加一个 script 标签，将需要请求的数据拼接在 url 上，然后将返回的数据作为一个函数调用的参数，传递给前端页面。</li>
<li>CORS：CORS 是跨域资源共享（Cross-Origin Resource Sharing）的缩写。它通过设置响应头中的 Access-Control-Allow-Origin 字段来授权其他域名下的网页访问自己的资源。CORS 需要后端配合实现。</li>
<li>代理：通过在同域名下搭建一个代理服务器，将前端请求的数据转发到目标服务器，然后将服务器的响应返回给前端。这样就避免了跨域的问题。</li>
<li>postMessage：H5 新增的 window.postMessage 方法可以在不同窗口之间传递数据，即使窗口的源不同也没有问题。利用这个方法，前端页面可以和目标网站建立通信，实现数据的传递和共享。</li>
</ol>
<p>总的来说，解决跨域问题的方法有很多种，不同的场景和需求需要选择不同的解决方案。</p>
</blockquote>
<h3 id="vanilla-js-是什么？有什么作用？">vanilla js 是什么？有什么作用？</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>Vanilla JS 是指“纯净”的 JavaScript，也就是不使用任何第三方库或框架的 JavaScript。它是 JavaScript 的一种表现形式，可以直接调用原生的 JavaScript API 来实现所需的功能。</p>
<p>Vanilla JS 的主要作用是为了避免在开发过程中使用过多的第三方库和框架，以减少代码的依赖性、提高代码的可维护性和可扩展性。使用 Vanilla JS 可以使代码更加轻量级，更容易在不同的项目中复用。</p>
<p>另外，Vanilla JS 的学习和使用也有助于加深对 JavaScript 本身的理解和掌握。它让开发者能够更加深入地理解 JavaScript 的语法和底层机制，提高对 Web 开发的认识和技能水平。</p>
<p>总之，Vanilla JS 不仅可以帮助开发者编写更轻量、更灵活的代码，还可以提高开发者的技能水平和职业竞争力。</p>
</blockquote>
<h3 id="如何进行密码加密？">如何进行密码加密？</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>在应用程序中存储密码时，通常需要对其进行加密以确保其安全性。以下是一些常用的密码加密方法：</p>
<ol>
<li>哈希函数：将密码输入到哈希函数中，该函数会生成一段固定长度的哈希值。常用的哈希函数包括 SHA-1、SHA-256、SHA-512 等。由于哈希函数是单向的，无法从哈希值反推出原密码，因此是一种比较安全的加密方式。</li>
<li>盐值哈希函数：为了增加密码安全性，可以使用盐值哈希函数。盐值是一个随机的字符串，将其与密码组合后再输入哈希函数中生成哈希值。这种方式可以防止使用彩虹表（一种预先计算哈希值并存储的密码破解工具）进行密码破解。</li>
<li>对称加密：对称加密是一种使用相同密钥加密和解密的加密方式。常用的对称加密算法包括 AES、DES、3DES 等。由于加密和解密使用相同的密钥，因此需要确保密钥的安全性。</li>
<li>非对称加密：非对称加密使用公钥和私钥进行加密和解密。公钥可以公开，任何人都可以使用公钥进行加密，但只有持有私钥的人才能进行解密。常用的非对称加密算法包括 RSA、DSA 等。</li>
</ol>
<p>总之，选择合适的密码加密方式取决于具体的应用场景和安全要求。在实际应用中，应该综合考虑各种加密方式的优缺点，选择适合自己的加密方式。</p>
</blockquote>
<h3 id="js-的严格模式，与普通模式有什么不同？">js 的严格模式，与普通模式有什么不同？</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>JavaScript 的严格模式是在 ECMAScript 5 引入的一种新的代码执行模式，它是一种更加严格的 JavaScript 解析和执行方式，相比于普通模式，严格模式主要有以下不同之处：</p>
<ol>
<li>变量必须先声明后使用：在严格模式中，变量必须先声明后使用，否则会抛出引用错误。</li>
<li>禁止使用未声明的变量：在严格模式中，使用未声明的变量会抛出引用错误。</li>
<li>禁止删除变量：在严格模式中，使用 <code>delete</code> 操作符删除变量会抛出语法错误。</li>
<li>函数必须声明在顶层：在严格模式中，函数必须声明在顶层作用域，不能声明在块级作用域中。</li>
<li>禁止使用 <code>eval</code> 函数：在严格模式中，使用 <code>eval</code> 函数会抛出语法错误。</li>
<li>禁止使用 <code>arguments.callee</code>：在严格模式中，使用 <code>arguments.callee</code> 会抛出语法错误。</li>
<li>禁止重复的属性名或参数名：在严格模式中，对象字面量中的属性名不能重复，函数的参数名也不能重复。</li>
</ol>
<p>通过使用严格模式，可以让 JavaScript 引擎更加严格地执行代码，从而避免一些常见的编程错误，提高代码的可读性和可维护性。</p>
</blockquote>
<h3 id="nodejs-的优缺点？适用场景？什么是回调地狱？如何避免？">nodejs 的优缺点？适用场景？什么是回调地狱？如何避免？</h3>
<ol>
<li>优点：
<ol>
<li>高并发（最重要的优点）</li>
<li>适合 I/O 密集型应用</li>
</ol>
</li>
<li>缺点：
<ol>
<li>不适合 CPU 密集型应用；CPU 密集型应用给 Node 带来的挑战主要是：由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起；</li>
</ol>
</li>
</ol>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，可以在服务器端运行 JavaScript 代码。Node.js 具有以下优缺点：</p>
<p>优点：</p>
<ul>
<li>非阻塞 I/O，使得在处理高并发请求时性能表现出色；</li>
<li>单线程模型，减少了线程上下文切换和锁的开销，提高了处理效率；</li>
<li>与前端 JS 语法相同，开发者可以很快地学会使用 Node.js 进行开发；</li>
<li>社区活跃，拥有丰富的第三方库和工具，开发效率高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>Node.js 不适合 CPU 密集型任务，因为其单线程模型只能利用一个 CPU 核心；</li>
<li>需要开发者手动处理回调函数和异步流程，可能会导致回调地狱问题；</li>
<li>Node.js 生态系统更新频繁，版本变化快，需要开发者及时更新代码。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>适用于高并发、I/O 密集型的网络应用，例如聊天室、实时推送、在线游戏等；</li>
<li>适用于中小型的 Web 应用，例如博客、电商网站、论坛等；</li>
<li>不适合 CPU 密集型的任务，例如视频编码、图片处理等。</li>
</ul>
<p>回调地狱是指多个异步操作嵌套的情况，由于 Node.js 的异步机制，可能会出现嵌套很深、代码难以理解和维护的情况。可以使用以下方法避免回调地狱问题：</p>
<ul>
<li>使用 Promise 和 async/await，避免回调函数的嵌套；</li>
<li>模块化编程，将复杂的代码分成独立的模块，降低代码耦合度，易于维护；</li>
<li>使用流程控制库，例如 Async.js，可以简化异步流程的处理。</li>
</ul>
</blockquote>
<h3 id="前端的趋势？为什么要对-web-进行优化？http1-1-和-http-2-的优化规则和主要方式分别有什么？有什么不同？">前端的趋势？为什么要对 web 进行优化？http1.1 和 http/2 的优化规则和主要方式分别有什么？有什么不同？</h3>
<p>以下内容来自 chatGPT：</p>
<blockquote>
<h4 id="前端的趋势">前端的趋势</h4>
<ol>
<li>WebAssembly 的广泛应用</li>
<li>人工智能和机器学习的发展</li>
<li>移动设备上的 Web 应用程序的发展</li>
<li>单页应用程序的流行</li>
<li>静态站点生成器的流行</li>
<li>Web 组件的标准化和流行</li>
<li>CSS-in-JS 的流行</li>
<li>PWA 技术的发展</li>
<li>WebRTC 技术的发展</li>
</ol>
<h4 id="为什么要对-Web-进行优化">为什么要对 Web 进行优化</h4>
<p>Web 的优化可以提高用户体验，增强网站的可用性和可访问性，减少加载时间，提高页面性能，增加搜索引擎的排名和网站流量等。</p>
<h4 id="HTTP1-1-和-HTTP-2-的优化规则和主要方式分别有什么？有什么不同？">HTTP1.1 和 HTTP/2 的优化规则和主要方式分别有什么？有什么不同？</h4>
<p>HTTP1.1 优化规则和主要方式：</p>
<ol>
<li>使用 CDN，减少服务器响应时间</li>
<li>合并和压缩 CSS 和 JavaScript 文件</li>
<li>缓存静态资源</li>
<li>使用 Gzip 压缩响应内容</li>
<li>减少 HTTP 请求次数</li>
<li>使用浏览器缓存</li>
</ol>
<p>HTTP/2 优化规则和主要方式：</p>
<ol>
<li>多路复用：通过单个连接并行传输多个请求和响应，减少延迟</li>
<li>二进制分帧：将请求和响应分成更小的二进制帧，提高传输效率</li>
<li>首部压缩：减少请求和响应的首部大小，减少传输量</li>
<li>服务器推送：服务器主动推送资源给客户端，减少客户端请求次数</li>
<li>使用 HTTPS 协议，减少网络攻击和窃听</li>
</ol>
<p>HTTP/2 相比于 HTTP1.1，可以减少网络延迟和传输量，提高 Web 页面性能和速度。</p>
<p>HTTP 1.1 和 HTTP/2 的优化规则和主要方式如下：</p>
<p>HTTP 1.1：</p>
<ul>
<li>持久连接：通过在一个连接中处理多个请求/响应对，避免了反复建立连接和关闭连接的开销。</li>
<li>管线化：客户端可以在一个连接上同时发送多个请求，避免了等待响应的时间。</li>
<li>压缩：使用 gzip 压缩响应数据，减小传输数据量。</li>
<li>缓存：客户端和服务器都可以使用缓存机制，减少重复请求和响应的次数。</li>
<li>基于域名的并行连接：浏览器可以同时与多个服务器建立连接，提高资源获取速度。</li>
<li>使用 CDN：使用 CDN 可以将静态资源分布在全球多个节点，提高访问速度。</li>
</ul>
<p>HTTP/2：</p>
<ul>
<li>多路复用：在一个 TCP 连接上可以同时处理多个请求/响应对，避免了 HTTP 1.1 中的序列化问题。</li>
<li>二进制协议：HTTP/2 中的数据格式采用二进制编码，替代了 HTTP 1.1 中的文本协议，提高了传输效率。</li>
<li>头部压缩：采用 HPACK 算法对 HTTP 头部进行压缩，减小传输数据量。</li>
<li>服务器推送：服务器可以主动向客户端推送资源，减少客户端请求次数。</li>
</ul>
<p>对于优化规则和主要方式的不同，HTTP/2 引入了新的协议，同时优化了多路复用、二进制协议、头部压缩和服务器推送等方面，相较于 HTTP 1.1 在性能上有明显提升。而 HTTP 1.1 则采用持久连接、管线化、压缩、缓存等方式进行优化。同时，HTTP/2 使用了基于 TLS 的加密，提高了安全性，但相应地增加了一定的性能开销。</p>
</blockquote>
<h2 id="程序题">程序题</h2>
<p>比较结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;1&quot;</span> == <span class="hljs-number">1</span>; <span class="hljs-comment">// 类型转化后比较，true</span><br><span class="hljs-string">&quot;1&quot;</span> === <span class="hljs-number">1</span>; <span class="hljs-comment">// 不转化类型直接比较，false</span><br></code></pre></td></tr></table></figure>
<p>运算的类型转化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">x = <span class="hljs-number">11</span>;<br>y = <span class="hljs-string">&quot;number&quot;</span>;<br>m = x + y; <span class="hljs-comment">// m = &quot;11number&quot;</span><br></code></pre></td></tr></table></figure>
<p><code>var</code> 声明的变量在初始化前可以调用，值为 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">2021</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 调用的是第 4 行声明的变量，值为 undefined</span><br>	<span class="hljs-keyword">var</span> value = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Time&quot;</span> &#125;;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// &#123; name: &#x27;Time&#x27;&#125;</span><br>&#125;<br><br><span class="hljs-title function_">fn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 2021</span><br></code></pre></td></tr></table></figure>
<p><code>let</code> 声明的变量在初始化前不可以调用，否则会报错 <code>ReferencError</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> foo = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>
<h2 id="名词解释">名词解释</h2>
<table>
<thead>
<tr>
<th>英文名称</th>
<th>全称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>DOM3</td>
<td>Document Object Model，文档对象类型</td>
<td>提供更多事件类型</td>
</tr>
<tr>
<td>W3C</td>
<td>World Wide Web Consortium，万维网联盟</td>
<td>提供 Web 标准</td>
</tr>
<tr>
<td>ES2015</td>
<td>ECMAScript 2015</td>
<td>2015 年 6 月，根据 ECMA-262 实现的通用脚本语言</td>
</tr>
<tr>
<td>URI</td>
<td>Uniform Resource Indentifer，统一资源标识符</td>
<td>用于标识某资源的字符串。URI 是 URL 和 URN 的超集。</td>
</tr>
<tr>
<td>BFC</td>
<td>Block Formatting Context</td>
<td>用于布局，不受环境影响。</td>
</tr>
<tr>
<td>SOP</td>
<td>Same Origin Policy，同源策略</td>
<td></td>
</tr>
<tr>
<td>Closure</td>
<td>闭包</td>
<td>使开发者就可以从内部函数访问外部作用域</td>
</tr>
<tr>
<td>CSS Sprites</td>
<td>图像精灵</td>
<td>单个图像中包含图像集合</td>
</tr>
<tr>
<td>Sessions</td>
<td>会话</td>
<td></td>
</tr>
<tr>
<td>TLS</td>
<td>Transport Layer Security，传输层安全协议</td>
<td>用于在两个通信应用程序之间提供保密性和数据完整性</td>
</tr>
<tr>
<td>FQDN</td>
<td>全限定域名</td>
<td></td>
</tr>
<tr>
<td>WHATWG</td>
<td>Web Hypertext Application Technology Working Group</td>
<td></td>
</tr>
<tr>
<td>HTML</td>
<td>超文本标记语言</td>
<td>用于创建 Web 页面的标准语言。</td>
</tr>
<tr>
<td>XML</td>
<td>可扩展标记语言</td>
<td>一种用于表示数据的标记语言，具有结构化和自我描述性，可以用于 Web 服务和传输数据。</td>
</tr>
<tr>
<td>REST</td>
<td>表示状态转移</td>
<td>一种基于 HTTP 协议设计的架构风格，通过对 Web 资源进行操作来进行交互，以实现 Web 应用程序的通信。</td>
</tr>
<tr>
<td>Ajax</td>
<td>异步 JavaScript 和 XML</td>
<td>一种创建交互式 Web 应用程序的技术，可以在不重新加载整个页面的情况下向服务器发送请求，并在页面上动态地更新内容。</td>
</tr>
<tr>
<td>RIA</td>
<td>富互联网应用程序</td>
<td>是一种具有较高的用户交互性和响应性能力的 Web 应用程序。</td>
</tr>
<tr>
<td>svg</td>
<td>可缩放矢量图形</td>
<td>一种用于描述二维图形的 XML 标记语言，可以创建各种图形，如图表、地图、图标等。</td>
</tr>
<tr>
<td>XSS</td>
<td>跨站脚本攻击</td>
<td>一种利用网站漏洞在用户的 Web 浏览器中执行恶意脚本的攻击方式。</td>
</tr>
<tr>
<td>wsdl</td>
<td>Web 服务描述语言</td>
<td>一种用于描述 Web 服务的 XML 标记语言，可以描述 Web 服务的访问地址、参数和返回值等信息。</td>
</tr>
<tr>
<td>mashup</td>
<td>混搭应用程序</td>
<td>是一种整合多个 Web 应用程序的方法，通过将不同的 Web 应用程序集成到一个单一的应用程序中，提供更好的用户体验。</td>
</tr>
<tr>
<td>CDS</td>
<td>内容交付网络</td>
<td>是一种通过分布式网络交付内容的方式，可以提高 Web 应用程序的性能和可靠性。</td>
</tr>
<tr>
<td>SPA</td>
<td>single page web application单页 Web 应用</td>
<td>就是只有一张 Web 页面的应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。</td>
</tr>
<tr>
<td>CDN</td>
<td>内容分发网络</td>
<td></td>
</tr>
</tbody>
</table>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat-award.jpg" alt="EagleBear2002 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="EagleBear2002 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/25097/" rel="prev" title="03-词法分析 3-自动机理论与词法分析器生成器">
      <i class="fa fa-chevron-left"></i> 03-词法分析 3-自动机理论与词法分析器生成器
    </a></div>
      <div class="post-nav-item">
    <a href="/22742/" rel="next" title="计算机与操作系统-实验开源">
      计算机与操作系统-实验开源 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E7%AD%94%E9%A2%98%E4%BE%8B%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">问答题例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D-http-%E4%BA%8B%E5%8A%A1%E7%9A%84-TCP-%E7%9B%B8%E5%85%B3%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.1.</span> <span class="nav-text">影响 http 事务的 TCP 相关延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9-meta-%E6%A0%87%E7%AD%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.2.</span> <span class="nav-text">对 &lt;meta&gt; 标签的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%92%8C%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.3.</span> <span class="nav-text">优雅降级和渐进增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#use-strict-%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.4.</span> <span class="nav-text">use strict 的含义和原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">HTTP 缓存的分类和使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A7%8D%E7%B1%BB%E3%80%81%E4%BC%98%E5%8A%BF%E5%92%8C%E9%80%89%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">前端框架的种类、优势和选型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ajax-%E7%9A%84%E8%83%8C%E6%99%AF%E3%80%81%E5%8E%9F%E7%90%86%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E6%AF%94%E8%BE%83%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%88%E4%B8%8D%E8%80%83%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">Ajax 的背景、原理、优缺点，比较不同的数据格式（不考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let%E3%80%81const-%E5%92%8C-var-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.</span> <span class="nav-text">let、const 和 var 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="nav-number">1.9.</span> <span class="nav-text">描述变量提升和暂时性死区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%EF%BC%9F%E5%9C%A8-http1-0-%E5%92%8C-1-1-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">1.10.</span> <span class="nav-text">什么是持久连接？在 http1.0+和 1.1 中是如何描述的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-session-%E5%92%8C-cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.</span> <span class="nav-text">说明 session 和 cookie 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C-web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">1.12.</span> <span class="nav-text">在浏览器和 web 服务器之间传送数据的方式有几种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-html-%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="nav-number">1.13.</span> <span class="nav-text">如何理解 html 结构的语义化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84"><span class="nav-number">1.14.</span> <span class="nav-text">CSS 规则的优先级算法是如何计算的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E5%9C%A8%E5%A4%84%E7%90%86-XHTML-%E8%A1%A8%E5%8D%95%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%E5%A6%82%E6%AD%A4%E9%87%8D%E8%A6%81%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E9%AA%8C%E8%AF%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%AF%94%E8%BE%83%E4%B9%8B"><span class="nav-number">1.15.</span> <span class="nav-text">为何在处理 XHTML 表单中数据验证如此重要？有几种验证方式，比较之</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%95%E8%BF%B0-bigpipe-%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.16.</span> <span class="nav-text">试述 bigpipe 技术的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-sprite-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E8%B0%88%E8%B0%88%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.17.</span> <span class="nav-text">CSS sprite 是什么？ 谈谈这个技术的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%AB%99%E9%87%8D%E6%9E%84%EF%BC%9F%E4%B8%BA%E4%BD%95%E8%A6%81%E9%87%8D%E6%9E%84%EF%BC%9F%E5%88%97%E4%B8%BE%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5"><span class="nav-number">1.18.</span> <span class="nav-text">什么是网站重构？为何要重构？列举网站性能优化的手段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE-table-%E5%B8%83%E5%B1%80"><span class="nav-number">1.19.</span> <span class="nav-text">为什么不建议 table 布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-css"><span class="nav-number">1.20.</span> <span class="nav-text">为什么使用 css</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84"><span class="nav-number">1.21.</span> <span class="nav-text">插件有什么坏处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E-SEO-%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E8%A7%A3%E9%87%8A-http-%E7%8A%B6%E6%80%81-301%E3%80%81302%E3%80%81404"><span class="nav-number">1.22.</span> <span class="nav-text">从 SEO 的角度来解释 http 状态 301、302、404</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD"><span class="nav-number">1.23.</span> <span class="nav-text">js 第三方库有什么增强功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E6%B3%A8%E5%86%8C-eventhandler-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="nav-number">1.24.</span> <span class="nav-text">js 注册 eventhandler 有哪些方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#html5-%E6%96%B0%E5%8A%9F%E8%83%BD%E5%B9%B6%E5%88%97%E4%B8%BE"><span class="nav-number">1.25.</span> <span class="nav-text">html5 新功能并列举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E5%92%8C-php-%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="nav-number">1.26.</span> <span class="nav-text">简述优化思路和 php 优化技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WEB3-0-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.27.</span> <span class="nav-text">WEB3.0 的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E5%B8%B8%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">1.28.</span> <span class="nav-text">HTTP 常用请求头、状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E9%9A%90%E8%97%8F%E5%9F%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.29.</span> <span class="nav-text">表单隐藏域的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.30.</span> <span class="nav-text">闭包是什么，适用环境？有什么缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS3-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.31.</span> <span class="nav-text">CSS3 的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">1.32.</span> <span class="nav-text">跨域问题是什么？有什么解决方案？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vanilla-js-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.33.</span> <span class="nav-text">vanilla js 是什么？有什么作用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="nav-number">1.34.</span> <span class="nav-text">如何进行密码加密？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%8E%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.35.</span> <span class="nav-text">js 的严格模式，与普通模式有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nodejs-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">1.36.</span> <span class="nav-text">nodejs 的优缺点？适用场景？什么是回调地狱？如何避免？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9A%84%E8%B6%8B%E5%8A%BF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AF%B9-web-%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9Fhttp1-1-%E5%92%8C-http-2-%E7%9A%84%E4%BC%98%E5%8C%96%E8%A7%84%E5%88%99%E5%92%8C%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.37.</span> <span class="nav-text">前端的趋势？为什么要对 web 进行优化？http1.1 和 http&#x2F;2 的优化规则和主要方式分别有什么？有什么不同？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9A%84%E8%B6%8B%E5%8A%BF"><span class="nav-number">1.37.1.</span> <span class="nav-text">前端的趋势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AF%B9-Web-%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="nav-number">1.37.2.</span> <span class="nav-text">为什么要对 Web 进行优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP1-1-%E5%92%8C-HTTP-2-%E7%9A%84%E4%BC%98%E5%8C%96%E8%A7%84%E5%88%99%E5%92%8C%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">1.37.3.</span> <span class="nav-text">HTTP1.1 和 HTTP&#x2F;2 的优化规则和主要方式分别有什么？有什么不同？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">程序题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="nav-number">3.</span> <span class="nav-text">名词解释</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EagleBear2002"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">EagleBear2002</p>
  <div class="site-description" itemprop="description">暮雪朝霜，毋改英雄意气</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">481</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EagleBear2002" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EagleBear2002" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:eaglebear2002@foxmail.com" title="E-Mail → mailto:eaglebear2002@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://czxingchen.github.io/" title="https:&#x2F;&#x2F;czxingchen.github.io&#x2F;" rel="noopener" target="_blank">PL 顶会研究者-XiaoZhi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/the-sword-of-king/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;the-sword-of-king&#x2F;" rel="noopener" target="_blank">模式识别专家-崖山剑</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://en.ydjsir.com.cn/" title="https:&#x2F;&#x2F;en.ydjsir.com.cn&#x2F;" rel="noopener" target="_blank">愿逐月华流照君-YDJSIR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/m0_51691879?spm=1000.2115.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51691879?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank">软院科协掌门人-wbl_z</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://itxia.club/" title="https:&#x2F;&#x2F;itxia.club&#x2F;" rel="noopener" target="_blank">侠之大者为国为民-IT 侠</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://chestnutsilver.github.io/TJIS-My-Helloworld/" title="https:&#x2F;&#x2F;chestnutsilver.github.io&#x2F;TJIS-My-Helloworld&#x2F;" rel="noopener" target="_blank">因果推断爱好者-ChestnutSilver</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://atritium.github.io/" title="https:&#x2F;&#x2F;atritium.github.io&#x2F;" rel="noopener" target="_blank">任天堂技术扛把子-manqi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.sakiyary.cn/" title="https:&#x2F;&#x2F;blog.sakiyary.cn&#x2F;" rel="noopener" target="_blank">教育部教学创新项目负责人-哈气鸭梨</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://huoxj.github.io/" title="https:&#x2F;&#x2F;huoxj.github.io&#x2F;" rel="noopener" target="_blank">离百年博客还有 98 年捞程序 Runz</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.erinwithbmq.xin/" title="https:&#x2F;&#x2F;www.erinwithbmq.xin&#x2F;" rel="noopener" target="_blank">摸鱼小能手 ErinwithBMQ の 尋夢之旅</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tilnel.github.io/" title="https:&#x2F;&#x2F;tilnel.github.io&#x2F;" rel="noopener" target="_blank">南大耐摔王 Tilnel 的杂谈小屋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.azifan.club/" title="https:&#x2F;&#x2F;blog.azifan.club&#x2F;" rel="noopener" target="_blank">水龙之魂</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mzy0624.github.io/" title="https:&#x2F;&#x2F;mzy0624.github.io&#x2F;" rel="noopener" target="_blank">Haibara AI</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EagleBear2002</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">40:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
