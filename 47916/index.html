<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eaglebear2002.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"always","padding":18,"offset":12,"onmobile":true,"scroll_to_top_on_sidebar_toggle":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文主要内容来自 SpriCoder的博客，更换了更清晰的图片并对原文的疏漏做了补充和修正。 任务管理 μC&#x2F;OS-II 是一个可移植的、可固化的、可扩展的、抢占式的、实时确定性的多任务内核，适用于微处理器、微控制器和 DSP。 任务主函数 开源代码用来学习是可以的，但是如果要商用，则需要获取到开源代码所有者的商业许可。">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式系统概论-07-实时内核">
<meta property="og:url" content="https://eaglebear2002.github.io/47916/index.html">
<meta property="og:site_name" content="EagleBear2002 的博客">
<meta property="og:description" content="本文主要内容来自 SpriCoder的博客，更换了更清晰的图片并对原文的疏漏做了补充和修正。 任务管理 μC&#x2F;OS-II 是一个可移植的、可固化的、可扩展的、抢占式的、实时确定性的多任务内核，适用于微处理器、微控制器和 DSP。 任务主函数 开源代码用来学习是可以的，但是如果要商用，则需要获取到开源代码所有者的商业许可。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028212051745.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028212056577.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028212101344.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/4.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/5.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/6.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/7.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/8.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/9.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/10.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028212927943.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028212921246.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/14.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/15.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/16.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/17.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/18.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/19.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/20.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/21.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/22.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/23.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/24.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028214741331.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/26.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/27.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/28.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028215046014.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/30.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/31.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/32.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/33.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028215649242.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028215658987.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028215703433.png">
<meta property="og:image" content="https://eaglebear2002.github.io/47916/image-20221028215706985.png">
<meta property="article:published_time" content="2022-10-27T08:20:00.000Z">
<meta property="article:modified_time" content="2026-02-09T05:08:29.549Z">
<meta property="article:author" content="EagleBear2002">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eaglebear2002.github.io/47916/image-20221028212051745.png">

<link rel="canonical" href="https://eaglebear2002.github.io/47916/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>嵌入式系统概论-07-实时内核 | EagleBear2002 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<script>
  hljs.initLineNumbersOnLoad();
</script>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EagleBear2002 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里必须根绝一切犹豫，这里任何怯懦都无济于事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">61</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">483</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/eaglebear2002" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eaglebear2002.github.io/47916/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="EagleBear2002">
      <meta itemprop="description" content="暮雪朝霜，毋改英雄意气">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EagleBear2002 的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          嵌入式系统概论-07-实时内核
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-27 16:20:00" itemprop="dateCreated datePublished" datetime="2022-10-27T16:20:00+08:00">2022-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-09 13:08:29" itemprop="dateModified" datetime="2026-02-09T13:08:29+08:00">2026-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">南京大学软件学院本科课程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/2022Fall-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">2022Fall-嵌入式系统概论</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要内容来自 <a target="_blank" rel="noopener" href="https://spricoder.github.io/">SpriCoder的博客</a>，更换了更清晰的图片并对原文的疏漏做了补充和修正。</p>
<h2 id="任务管理">任务管理</h2>
<p>μC/OS-II 是一个可移植的、可固化的、可扩展的、抢占式的、实时确定性的多任务内核，适用于微处理器、微控制器和 DSP。</p>
<h3 id="任务主函数">任务主函数</h3>
<p>开源代码用来学习是可以的，但是如果要商用，则需要获取到开源代码所有者的商业许可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YourTask</span> <span class="hljs-params">(<span class="hljs-type">void</span> *pdata)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (;;) &#123;<br>		<span class="hljs-comment">/* USER CODE</span><br><span class="hljs-comment">		Call one of uC/OS-II&#x27;s services:</span><br><span class="hljs-comment">		OSFlagPend();</span><br><span class="hljs-comment">		OSMboxPend();</span><br><span class="hljs-comment">		OSMutexPend();</span><br><span class="hljs-comment">		OSQPend();</span><br><span class="hljs-comment">		OSSemPend();</span><br><span class="hljs-comment">		OSTaskSuspend(OS_PRIO_SELF);</span><br><span class="hljs-comment">		OSTimeDly();</span><br><span class="hljs-comment">		OSTimeDlyHMSM();</span><br><span class="hljs-comment">		/* USER CODE */</span><br>	&#125;<br>&#125;<br>	<span class="hljs-comment">// 或者是</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">YourTask</span> <span class="hljs-params">(<span class="hljs-type">void</span> *pdata)</span> </span>&#123;<br>	<span class="hljs-comment">/* USER CODE */</span><br>	<span class="hljs-built_in">OSTaskDel</span>(OS_PRIO_SELF);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="任务优先级">任务优先级</h3>
<ol>
<li>μC/OS-II 最多可以管理 64 个任务</li>
<li>尽管 μC/OS-II 保留了四个最高优先级任务和四个最低优先级任务供自己使用。但是，此时，μC/OS-II 实际上仅使用两个优先级：<code>OSTaskCreate</code> 和 <code>OS_LOWEST_PRIO-1</code>（请参阅 <code>OS_CFG.H</code>）。这使您最多可以执行 56 个应用程序任务。</li>
<li>优先级的值越小，任务的优先级越高。</li>
<li>在当前版本的 μC/ OS-II 中，任务优先级编号也用作任务标识符。</li>
<li>任务优先级一致怎么办： 1. 时间片流转：先使用一定的时间片完成，然后将结果给下一个使用 2. 先到先服务</li>
</ol>
<h3 id="空闲任务和统计任务">空闲任务和统计任务</h3>
<p>内核总是创建一个空闲任务 <code>OSTaskIdle()</code></p>
<ol>
<li>总是设置为最低优先级，<code>OS_LOWEST_PRIOR</code></li>
<li>当所有其他任务都未在执行时，空闲任务开始执行</li>
<li>应用程序不能删除该任务；</li>
<li>空闲任务的工作就是把 32 位计数器 <code>OSIdleCtr</code> 加 1，该计数器被统计任务所使用；</li>
</ol>
<p>统计任务 <code>OSTaskStat()</code>，提供运行时间统计。每秒钟运行一次，计算当前的 CPU 利用率。其优先级是 <code>OS_LOWEST_PRIOR-1</code>，可选。</p>
<h3 id="任务控制块-TCB">任务控制块 TCB</h3>
<p>任务控制块 <code>OS_TCB</code> 是描述一个任务的核心数据结构，存放了任务的各种管理信息，包括任务堆栈指针，任务的状态、优先级，任务链表指针等；</p>
<p>一旦任务建立了，任务控制块 OS_TCB 将被赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">os_tcb</span>&#123;<br>	<span class="hljs-comment">//栈指针；</span><br>	<span class="hljs-comment">//INT16U OSTCBId; /*任务的 ID*/</span><br>	<span class="hljs-comment">//链表指针；</span><br>	<span class="hljs-comment">//OS_EVENT *OSTCBEventPtr; /*事件指针*/</span><br>	<span class="hljs-comment">//void *OSTCBMsg; /*消息指针*/</span><br>	<span class="hljs-comment">//INT8U OSTCBStat; /*任务的状态*/</span><br>	<span class="hljs-comment">//INT8U OSTCBPrio; /*任务的优先级*/</span><br>	<span class="hljs-comment">//其他……</span><br>&#125; OS_TCB;<br></code></pre></td></tr></table></figure>
<h3 id="栈指针">栈指针</h3>
<ol>
<li><code>OSTCBStkPtr</code>：指向当前任务栈顶的指针，每个任务可以有自己的栈，栈的容量可以是任意的；</li>
<li><code>OSTCBStkBottom</code>：指向任务栈底的指针；</li>
<li><code>OSTCBStkSize</code>：栈的容量，用可容纳的指针数目而不是字节数（Byte）来表示。</li>
</ol>
<h3 id="链表指针">链表指针</h3>
<p>所有的任务控制块分属于两条不同的链表，单向的空闲链表（头指针为 <code>OSTCBFreeList</code>）和双向的使用链表（头指针为 <code>OSTCBList</code>）；</p>
<p><code>OSTCBNext</code>、<code>OSTCBPrev</code>：用于将任务控制块插入到空闲链表或使用链表中。每个任务的任务控制块在任务创建的时候被链接到使用链表中，在任务删除的时候从链表中被删除。双向连接的链表使得任一成员都能快速插入或删除。</p>
<h3 id="空闲-TCB-链表">空闲 TCB 链表</h3>
<p>所有的任务控制块都被放置在任务控制块列表数组 <code>OSTCBTbl[]</code> 中，系统初始化时，所有 TCB 被链接成空闲的单向链表，头指针为 <code>OSTCBFreeList</code>。当创建一个任务后，就把 <code>OSTCBFreeList</code> 所指向的 TCB 赋给了该任务，并将它加入到使用链表中，然后把 <code>OSTCBFreeList</code> 指向空闲链表中的下一个节点。</p>
<p>为什么空闲是单项链表，使用是双项链表？因为双向链表有利于将时间复杂度降低为常数。</p>
<ol>
<li>遍历链表的时间复杂度是 $O(n)$</li>
<li>期望遍历复杂度是 $O(1)$，常数，开辟一个数据存放所有任务和 TCB 地址</li>
<li>用空间换时间</li>
</ol>
<p><img src="/47916/image-20221028212051745.png" alt></p>
<h3 id="指针数组（指向相应-TCB）">指针数组（指向相应 TCB）</h3>
<p><img src="/47916/image-20221028212056577.png" alt></p>
<h3 id="状态的转换">状态的转换</h3>
<p><img src="/47916/image-20221028212101344.png" alt></p>
<h3 id="任务就绪表">任务就绪表</h3>
<ol>
<li>每个任务的就绪态标志放入在就绪表中，就绪表中有两个变量 <code>OSRdyGrp</code> 和 <code>OSRdyTbl[]</code>。</li>
<li>在 <code>OSRdyGrp</code> 中，任务按优先级分组，8 个任务为一组。<code>OSRdyGrp</code> 中的每一位表示 8 组任务中每一组中是否有进入就绪态的任务。任务进入就绪态时，就绪表 <code>OSRdyTbl[]</code>中的相应元素的相应位也置位。</li>
</ol>
<p><img src="/47916/4.png" alt></p>
<p>（0, 0）是优先级最高的任务，（7, 7）是优先级最低的</p>
<h4 id="根据优先级确定就绪表">根据优先级确定就绪表</h4>
<p>假设优先级为 12（优先级为 0）的任务进入就绪状态，12=1100b，则 <code>OSRdyTbl[1]</code> 的第 4 位置 1，且 <code>OSRdyGrp</code> 的第 1 位置 1，相应的数学表达式为：</p>
<ol>
<li><code>OSRdyGrp |= 0x02</code></li>
<li><code>OSRdyTbl[1] |= 0x10</code></li>
</ol>
<p>而优先级为 21 的任务就绪 21=10 101b，则 OSRdyTbl[2]的第 5 位置 1，且 <code>OSRdyGrp</code> 的第 2 位置 1,相应的数学表达式</p>
<ol>
<li><code>OSRdyGrp |= 0x04</code></li>
<li><code>OSRdyTbl[2] |= 0x20</code></li>
</ol>
<p>从上面的计算可知： 若 <code>OSRdyGrp</code> 及 <code>OSRdyTbl[]</code> 的第 n 位置 1，则应该把 <code>OSRdyGrp</code> 及 <code>OSRdyTbl[]</code> 的值与 $2^n$ 相或。uC/OS 中，把 $2^n$ 的 n=0-7 的 8 个值先计算好存在数组 <code>OSMapTbl[7]</code>中,也就是：</p>
<ol>
<li><code>OSMapTbl[0] = $2^0$ = 0x01(0000 0001)</code></li>
<li><code>OSMapTbl[1] = $2^1$ = 0x02(0000 0010)</code></li>
<li><code>OSMapTbl[7] = $2^7$ = 0x80(1000 0000)</code></li>
</ol>
<p>如果 <code>prio</code> 是任务的优先级，即任务的标识号，则将任务放入就绪表，使任务进入就绪态的方法是：</p>
<ol>
<li><code>OSRdyGrp |= OSMapTbl[prio&gt;&gt;3]</code></li>
<li><code>OSRdyTbl[prio&gt;&gt;3] |= OSMapTbl[prio&amp;0x07]</code></li>
</ol>
<p>假设优先级为 12:1100b</p>
<ol>
<li><code>OSRdyGrp |= OSMapTbl[12&gt;&gt;3](0x02)</code></li>
<li><code>OSRdyTbl[1] |= 0x10</code></li>
</ol>
<h4 id="使任务脱离就绪态">使任务脱离就绪态</h4>
<p>将任务就绪表 <code>OSRdyTbl[prio&gt;&gt;3]</code> 相应元素的相应位清零，而且当 <code>OSRdyTbl[prio&gt;&gt;3]</code> 中的所有位都为零时，即该任务所在组的所有任务中没有一个进入就绪态时，<code>OSRdyGrp</code> 的相应位才为零：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if((OSRdyTbl[prio &gt;&gt; 3] &amp;= ~OSMapTbl[prio &amp; 0x07]) == 0)<br>	OSRdyGrp &amp;= ~OSMapTbl[prio &gt;&gt; 3];<br></code></pre></td></tr></table></figure>
<h3 id="任务的调度">任务的调度</h3>
<ol>
<li>μC/OS-II 是可抢占实时多任务内核，它总是运行就绪任务中优先级最高的那一个。</li>
<li>μC/OS-II 中不支持时间片轮转法，每个任务的优先级要求不一样且是唯一的，所以任务调度的工作就是：查找准备就绪的最高优先级的任务并进行上下文切换。</li>
<li>μC/OS-II 任务调度所花的时间为常数，与应用程序中建立的任务数无关。</li>
<li>确定哪个任务的优先级最高，应该选择哪个任务去运行，这部分的工作是由调度器（Scheduler）来完成的。 1. 任务级的调度是由函数 <code>OSSched()</code> 完成的； 2. 中断级的调度是由另一个函数 <code>OSIntExt()</code> 完成的。</li>
</ol>
<h3 id="根据就绪表确定最高优先级（为什么右移三位）">根据就绪表确定最高优先级（为什么右移三位）</h3>
<p>两个关键：</p>
<ol>
<li>将优先级数分解为高三位和低三位分别确定；</li>
<li>高优先级有着小的优先级号</li>
</ol>
<p>根据就绪表确定最高优先级</p>
<ol>
<li>通过 OSRdyGrp 值确定高 3 位，假设 <code>OSRdyGrp = 0x08=0x00001000</code>，第 3 位为 1，优先级的高 3 位为 011;</li>
<li>通过 <code>OSRdyTbl[3]</code> 的值来确定低 3 位，假设 <code>OSRdyTbl[3] = 0x3a</code>，第 1 位为 1，优先级的低 3 位为 001，3*8+2-1=25</li>
</ol>
<p><img src="/47916/5.png" alt></p>
<h3 id="任务调度器">任务调度器</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSSched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	INT8U y;<br>	<span class="hljs-built_in">OS_ENTER_CRITICAL</span>();<br>	<span class="hljs-comment">// 检查是否中断调用和允许任务调用</span><br>	<span class="hljs-keyword">if</span> ((OSLockNesting | OSIntNesting) == <span class="hljs-number">0</span>) &#123;<br>		y = OSUnMapTbl[OSRdyGrp];<br>		<span class="hljs-comment">// 找到优先级最高的任务</span><br>		OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="hljs-number">3</span>) + OSUnMapTbl[OSRdyTbl[y]]);<br>		<span class="hljs-comment">// 该任务是否正在运行</span><br>		<span class="hljs-keyword">if</span> (OSPrioHighRdy != OSPrioCur) &#123;<br>			OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];<br>			OSCtxSwCtr++;<br>			<span class="hljs-built_in">OS_TASK_SW</span>();<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">OS_EXIT_CRITICAL</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="源代码中使用了查表法">源代码中使用了查表法</h3>
<p>查表法具有确定的时间，增加了系统的可预测性，uC/OS 中所有的系统调用时间都是确定的</p>
<ol>
<li><code>Y = OSUnMapTbl[OSRdyGrp]</code></li>
<li><code>X = OSUnMapTbl[OSRdyTbl[Y]]</code></li>
<li><code>Prio = (Y&lt;&lt;3) + X;</code></li>
</ol>
<h3 id="优先级判定表-OSUnMapTbl-256">优先级判定表 OSUnMapTbl[256]</h3>
<p><img src="/47916/6.png" alt></p>
<ul>
<li>$2^8 = 256$：一共有 256 种情况，查表解释即可</li>
<li>空间换时间，用来快速查找当前优先级最高的部分</li>
</ul>
<h3 id="从-64-256">从 64-&gt;256</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OS_SchedNew</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> OS_LOWEST_PRIO &lt;= 63  <span class="hljs-comment">//μC/OS-II v2.7 之前方式</span></span><br>	INT8U y;<br>	y = OSUnMapTbl[OSRdyGrp];<br>	OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="hljs-number">3</span>) + OSUnMapTbl[OSRdyTbl[y]]);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	INT8U y;<br>	INT16U* ptbl;<br>	<span class="hljs-comment">// OSRdyGrp 为 16 位</span><br>	<span class="hljs-keyword">if</span> ((OSRdyGrp &amp; <span class="hljs-number">0xFF</span>) != <span class="hljs-number">0</span>) &#123;<br>		y = OSUnMapTbl[OSRdyGrp &amp; <span class="hljs-number">0xFF</span>];<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		y = OSUnMapTbl[(OSRdyGrp &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>] + <span class="hljs-number">8</span>;	 <span class="hljs-comment">//矩形组号 y&gt;=8</span><br>	&#125;<br>	ptbl = &amp;OSRdyTbl[y];  <span class="hljs-comment">//取出 x 方向的 16bit 数据</span><br>	<span class="hljs-keyword">if</span> ((*ptbl &amp; <span class="hljs-number">0xFF</span>) != <span class="hljs-number">0</span>) &#123;<br>		OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="hljs-number">4</span>) + OSUnMapTbl[(*ptbl &amp; <span class="hljs-number">0xFF</span>)]);	 <span class="hljs-comment">//*16</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		OSPrioHighRdy = (INT8U)((y &lt;&lt; <span class="hljs-number">4</span>) + OSUnMapTbl[(*ptbl &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>] + <span class="hljs-number">8</span>);<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>未超过 64 位，则用上面的，如果超过了 64 位则使用下半部分</li>
<li>仔细分析一下：判定低八位是否为 0，如果低八位不为 0，则直接对低八位操作即可，如果低八位为 0，则在高八位，所以需要加 8</li>
</ol>
<h3 id="任务切换">任务切换</h3>
<ol>
<li>将被挂起任务的寄存器内容入栈；</li>
<li>将较高优先级任务的寄存器内容出栈，恢复到硬件寄存器中。</li>
</ol>
<h4 id="任务级的任务切换-OS-TASK-SW">任务级的任务切换 <code>OS_TASK_SW()</code></h4>
<ol>
<li>保护当前任务的现场</li>
<li>恢复新任务的现场</li>
<li>执行中断返回指令</li>
<li>开始执行新的任务</li>
</ol>
<table>
<thead>
<tr>
<th>调用 <code>OS_TASK_SW()</code> 前的数据结构</th>
<th>保存当前 CPU 寄存器的值</th>
<th>重新装入要运行的任务</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/47916/7.png" alt></td>
<td><img src="/47916/8.png" alt></td>
<td><img src="/47916/9.png" alt></td>
</tr>
</tbody>
</table>
<h4 id="任务切换-OS-TASK-SW-的代码">任务切换 <code>OS_TASK_SW()</code> 的代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSCtxSw</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-comment">//将 R1,R2,R3 及 R4 推入当前堆栈；</span><br>	OSTCBCur-&gt;OSTCBStkPtr = SP;<br>	OSTCBCur = OSTCBHighRdy;<br>	SP = OSTCBHighRdy-&gt;OSTCBSTKPtr;<br>	<span class="hljs-comment">//将 R4,R3,R2 及 R1 从新堆栈中弹出；</span><br>	<span class="hljs-comment">//执行中断返回指令；</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="给调度器上锁">给调度器上锁</h4>
<ol>
<li><code>OSSchedlock()</code>：给调度器上锁函数，用于禁止任务调度，保持对 CPU 的控制权（即使有优先级更高的任务进入了就绪态）；</li>
<li><code>OSSchedUnlock()</code>：给调度器开锁函数，当任务完成后调用此函数，调度重新得到允许；</li>
<li>当低优先级的任务要发消息给多任务的邮箱、消息队列、信号量时，它不希望高优先级的任务在邮箱、队列和信号量还没有得到消息之前就取得了 CPU 的控制权，此时，可以使用调度器上锁函数。</li>
</ol>
<h3 id="任务管理的系统服务">任务管理的系统服务</h3>
<ol>
<li>创建任务</li>
<li>删除任务</li>
<li>修改任务的优先级</li>
<li>挂起和恢复任务</li>
<li>获得一个任务的有关信息</li>
</ol>
<h4 id="创建任务">创建任务</h4>
<ol>
<li>创建任务的函数 1. <code>OSTaskCreate()</code> 2. <code>OSTaskCreateExt()</code></li>
<li><code>OSTaskCreateExt()</code> 是 <code>OSTaskCreate()</code> 的扩展版本，提供了一些附加的功能；</li>
<li>任务可以在多任务调度开始 （即调用 <code>OSStart()</code>) 之前创建，也可以在其它任务的执行过程中被创建。但在 <code>OSStart()</code> 被调用之前，用户必须创建至少一个任务；</li>
<li>不能在中断服务程序（ISR）中创建新任务。</li>
</ol>
<h4 id="OSTaskCreate"><code>OSTaskCreate()</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">INT8U <span class="hljs-title">OSTaskCreate</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">	<span class="hljs-type">void</span> (*task)(<span class="hljs-type">void</span> *pd), <span class="hljs-comment">//任务代码指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">	<span class="hljs-type">void</span> *pdata, <span class="hljs-comment">//任务参数指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">	OS_STK *ptos, <span class="hljs-comment">//任务栈的栈顶指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT8U prio <span class="hljs-comment">//任务的优先级</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>返回值 - <code>OS_NO_ERR</code>：函数调用成功； - <code>OS_PRIO_EXIT</code>：任务优先级已经存在； - <code>OS_PRIO_INVALID</code>：任务优先级无效。</li>
</ul>
<h4 id="OSTaskCreate-的实现过程"><code>OSTaskCreate()</code> 的实现过程</h4>
<ol>
<li>任务优先级检查 1. 该优先级是否在 0 到 <code>OS_LOWSEST_PRIO</code> 之间？ 2. 该优先级是否空闲？</li>
<li>调用 <code>OSTaskStkInit()</code>，创建任务的栈帧</li>
<li>调用 <code>OSTCBInit()</code>，从空闲的 <code>OS_TCB</code> 池（即 <code>OSTCBFreeList</code> 链表）中获得一个 TCB 并初始化其内容，然后把它加入到 <code>OSTCBList</code> 链表的开头，并把它设定为就绪状态</li>
<li>任务个数 <code>OSTaskCtr</code> 加 1</li>
<li>调用用户自定义的函数 <code>OSTaskCreateHook()</code></li>
<li>判断是否需要调度（调用者是正在执行的任务）</li>
</ol>
<h4 id="OSTaskCreateExt"><code>OSTaskCreateExt()</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">INT8U <span class="hljs-title">OSTaskCreateExt</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">	<span class="hljs-comment">//前四个参数与 OSTaskCreate 相同，</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT16U id, <span class="hljs-comment">//任务的 ID</span></span></span><br><span class="hljs-params"><span class="hljs-function">	OS_STK *pbos, <span class="hljs-comment">//指向任务栈底的指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT32U stk_size, <span class="hljs-comment">//栈能容纳的成员数目</span></span></span><br><span class="hljs-params"><span class="hljs-function">	<span class="hljs-type">void</span> *pext,<span class="hljs-comment">//指向用户附加数据域的指针</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT16U opt <span class="hljs-comment">//一些选项信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>返回值：与 <code>OSTaskCreate()</code> 相同。</li>
</ul>
<h4 id="任务的栈空间">任务的栈空间</h4>
<ol>
<li>每个任务都有自己的栈空间（Stack），栈必须声明为 <code>OS_STK</code> 类型，并且由连续的内存空间组成；</li>
<li>栈空间的分配方法 1. 静态分配：在编译的时候分配，例如：<code>static OS_STK MyTaskStack[stack_size];</code>、<code>OS_STK MyTaskStack[stack_size];</code> 2. 动态分配：在任务运行的时候使用 <code>malloc()</code> 函数来动态申请内存空间；</li>
</ol>
<h4 id="动态分配">动态分配</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">OS_STK *pstk;<br>pstk = (OS_STK *)<span class="hljs-built_in">malloc</span>(stack_size);<br><span class="hljs-comment">/* 确认 malloc()得到足够的内存空间 */</span><br><span class="hljs-keyword">if</span> (pstk != (OS_STK *)<span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-comment">// Create the task;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="内存碎片问题">内存碎片问题</h4>
<p>在动态分配中，可能存在内存碎片问题。特别是当用户反复地建立和删除任务时，内存堆中可能会出现大量的碎片，导致没有足够大的一块连续内存区域可用作任务栈，这时 <code>malloc()</code> 便无法成功地为任务分配栈空间。</p>
<p><img src="/47916/10.png" alt></p>
<h4 id="栈的增长方向">栈的增长方向</h4>
<p>栈的增长方向的设置</p>
<ol>
<li>从低地址到高地址：在 <code>OS_CPU.H</code> 中，将常量 <code>OS_STK_GROWTH </code>设定为 0；</li>
<li>从高地址到低地址：在 <code>OS_CPU.H</code> 中，将常量 <code>OS_STK_GROWTH </code>设定为 1；</li>
<li><code>OS_STK TaskStack[TASK_STACK_SIZE]</code>;</li>
<li><code>OSTaskCreate(task, pdata,&amp;TaskStack[TASK_STACK_SIZE-1],prio)</code>;</li>
</ol>
<h3 id="删除任务">删除任务</h3>
<p><code>OSTaskDel()</code>：删除一个任务，其 TCB 会从所有可能的系统数据结构中移除。任务将返回并处于休眠状态（任务的代码还在）。</p>
<ol>
<li>如果任务正处于就绪状态，把它从就绪表中移出，这样以后就不会再被调度执行了；</li>
<li>如果任务正处于邮箱、消息队列或信号量的等待队列中，也把它移出；</li>
<li>将任务的 <code>OS_TCB</code> 从 <code>OSTCBList</code> 链表当中移动到 <code>OSTCBFreeList</code>。</li>
</ol>
<p>任务也可以自我删除（并非真的删除，只是内核不再知道该任务）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyTask</span> <span class="hljs-params">(<span class="hljs-type">void</span> *pdata)</span></span><br><span class="hljs-function"></span>&#123;<br>	...... <span class="hljs-comment">/* 用户代码 */</span><br>	<span class="hljs-built_in">OSTaskDel</span>(OS_PRIO_SELF);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>OSTaskChangePrio()</code>：在程序运行期间，用户可以通过调用本函数来改变某个任务的优先级。<code>INT8U OSTaskChangePrio(INT8U oldprio, INT8U newprio)</code></li>
<li><code>OSTaskQuery()</code>：获得一个任务的有关信息：获得的是对应任务的 OS_TCB 中内容的拷贝。</li>
</ul>
<h3 id="挂起和恢复任务">挂起和恢复任务</h3>
<p><code>OSTaskSuspend()</code>：挂起一个任务</p>
<ol>
<li>如果任务处于就绪态，把它从就绪表中移出；</li>
<li>在任务的 TCB 中设置 <code>OS_STAT_SUSPEND</code> 标志，表明该任务正在被挂起。</li>
</ol>
<p><code>OSTaskResume()</code>：恢复一个任务</p>
<ol>
<li>恢复被 OSTaskSuspend()起的任务；</li>
<li>清除 TCB 中 <code>OSTCBStat</code> 字段的 <code>OS_STAT_SUSPEND</code> 位</li>
</ol>
<h2 id="中断和时间管理">中断和时间管理</h2>
<h3 id="中断处理">中断处理</h3>
<p>中断：由于某种事件的发生而导致程序流程的改变。产生中断的事件称为中断源。</p>
<p>CPU 响应中断的条件：</p>
<ol>
<li>至少有一个中断源向 CPU 发出中断信号；</li>
<li>系统允许中断，且对此中断信号未予屏蔽。</li>
</ol>
<h3 id="中断服务程序-ISR">中断服务程序 ISR</h3>
<p>中断一旦被识别，CPU 会保存部分（或全部）运行上下文（context，即寄存器的值），然后跳转到专门的子程序去处理此次事件，称为中断服务子程序（ISR）。</p>
<p>μC/OS-Ⅱ 中，中断服务子程序要用汇编语言来编写，然而，如果用户使用的 C 语言编译器支持在线汇编语言的话，用户可以直接将中断服务子程序代码放在 C 语言的程序文件中。</p>
<h3 id="用户-ISR-的框架">用户 ISR 的框架</h3>
<ol>
<li>保存全部 CPU 寄存器的值;</li>
<li>调用 <code>OSIntEnter()</code>，或直接把全局变量 <code>OSIntNesting</code>（中断嵌套层次）加 1；</li>
<li>执行用户代码做中断服务;</li>
<li>调用 <code>OSIntExit()</code>；</li>
<li>恢复所有 CPU 寄存器；</li>
<li>执行中断返回指令。</li>
</ol>
<p><img src="/47916/image-20221028212927943.png" alt></p>
<h4 id="OSIntEnter"><code>OSIntEnter()</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 在调用本函数之前必须先将中断关闭 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSIntEnter</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>	<span class="hljs-keyword">if</span> (OSRunning == TRUE) &#123;<br>			<span class="hljs-keyword">if</span> (OSIntNesting &lt; <span class="hljs-number">255</span>) &#123;<br>				 OSIntNesting++;<br>			&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="OSIntExit"><code>OSIntExit()</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSIntExit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">OS_ENTER_CRITICAL</span>();						<span class="hljs-comment">//关中断</span><br>	<span class="hljs-keyword">if</span> ((--OSIntNesting | OSLockNesting) == <span class="hljs-number">0</span>)	<span class="hljs-comment">//判断嵌套是否为零</span><br>	&#123;											<span class="hljs-comment">//把高优先级任务装入</span><br>		OSIntExitY = OSUnMapTbl[OSRdyGrp];<br>		OSPrioHighRdy = (INT8U)((OSIntExitY &lt;&lt; <span class="hljs-number">3</span>) +<br>								OSUnMapTbl[OSRdyTbl[OSIntExitY]]);<br>		<span class="hljs-keyword">if</span> (OSPrioHighRdy != OSPrioCur) &#123;<br>			OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];<br>			OSCtxSwCtr++;<br>			<span class="hljs-built_in">OSIntCtxSw</span>();<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">OS_EXIT_CRITICAL</span>();	 <span class="hljs-comment">//开中断返回</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="OSIntCtxSw"><code>OSIntCtxSw()</code></h4>
<p>在任务切换时，为什么使用 <code>OSIntCtxSw()</code> 而不是调度函数中的 <code>OS_TASK_SW()</code>？</p>
<p>原因如下：</p>
<ol>
<li>一半的任务切换工作，即 CPU 寄存器入栈，已经在前面做完了；</li>
<li>需要保证所有被挂起任务的栈结构是一样的。</li>
</ol>
<h4 id="调用中断切换函数-OSIntCtxSw-后的堆栈情况">调用中断切换函数 <code>OSIntCtxSw()</code> 后的堆栈情况</h4>
<p><img src="/47916/image-20221028212921246.png" alt></p>
<h3 id="时钟节拍">时钟节拍</h3>
<ol>
<li>时钟节拍是一种特殊的中断；</li>
<li>μC/OS 需要用户提供周期性信号源，用于实现时间延时和确认超时。节拍率应在 10 到 100Hz 之间，时钟节拍率越高，系统的额外负荷就越重；</li>
<li>时钟节拍的实际频率取决于用户应用程序的精度。时钟节拍源可以是专门的硬件定时器，或是来自 50/60Hz 交流电源的信号。</li>
</ol>
<h4 id="时钟节拍-ISR">时钟节拍 ISR</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSTickISR</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-comment">//(1)存处理器寄存器的值；</span><br>	<span class="hljs-comment">//(2)用 OSIntEnter()将 OSIntNesting 加 1;</span><br>	<span class="hljs-comment">//(3)用 OSTimeTick(); /*检查每个任务的时间延时*/</span><br>	<span class="hljs-comment">//(4)用 OSIntExit();</span><br>	<span class="hljs-comment">//(5)复处理器寄存器的值;</span><br>	<span class="hljs-comment">//(6)行中断返回指令;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="时钟节拍函数-OSTimetick">时钟节拍函数 <code>OSTimetick()</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSTimeTick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	OS_TCB* ptcb;<br>	<span class="hljs-built_in">OSTimeTickHook</span>();						   <span class="hljs-comment">// (1)</span><br>	ptcb = OSTCBList;						   <span class="hljs-comment">// (2)</span><br>	<span class="hljs-keyword">while</span> (ptcb-&gt;OSTCBPrio != OS_IDLE_PRIO) &#123;  <span class="hljs-comment">// (3)</span><br>		<span class="hljs-built_in">OS_ENTER_CRITICAL</span>();<br>		<span class="hljs-keyword">if</span> (ptcb-&gt;OSTCBDly != <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">if</span> (--ptcb-&gt;OSTCBDly == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">if</span> (!(ptcb-&gt;OSTCBStat &amp; OS_STAT_SUSPEND)) &#123;	 <span class="hljs-comment">// (4)</span><br>					OSRdyGrp |= ptcb-&gt;OSTCBBitY;			 <span class="hljs-comment">// (5)</span><br>					OSRdyTbl[ptcb-&gt;OSTCBY] |= ptcb-&gt;OSTCBBitX;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					ptcb-&gt;OSTCBDly = <span class="hljs-number">1</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		ptcb = ptcb-&gt;OSTCBNext;<br>		<span class="hljs-built_in">OS_EXIT_CRITICAL</span>();<br>	&#125;<br>	<span class="hljs-built_in">OS_ENTER_CRITICAL</span>();  <span class="hljs-comment">// (6)</span><br>	OSTime++;			  <span class="hljs-comment">// (7)</span><br>	<span class="hljs-built_in">OS_EXIT_CRITICAL</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="时间管理">时间管理</h3>
<ol>
<li>与时间管理相关的系统服务： 1. <code>OSTimeDLY()</code> 2. <code>OSTimeDLYHMSM()</code> 3. <code>OSTimeDlyResume()</code> 4. <code>OSTimeGet()</code> 5. <code>OSTimeSet()</code></li>
</ol>
<h4 id="OSTimeDLY"><code>OSTimeDLY()</code></h4>
<p><code>OSTimeDLY()</code>：任务延时函数，申请该服务的任务可以延时一段时间；</p>
<p>调用 <code>OSTimeDLY</code> 后，任务进入等待状态；</p>
<p>使用方法：</p>
<ol>
<li><code>void OSTimeDly(INT16U ticks)</code>;</li>
<li>ticks 表示需要延时的时间长度，用时钟节拍的个数
来表示。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSTimeDly</span> <span class="hljs-params">(INT16U ticks)</span></span>&#123;<br>	<span class="hljs-keyword">if</span> (ticks &gt; <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">OS_ENTER_CRITICAL</span>();<br>		<span class="hljs-keyword">if</span> ((OSRdyTbl[OSTCBCur-&gt;OSTCBY] &amp;=<br>		~OSTCBCur-&gt;OSTCBBitX) == <span class="hljs-number">0</span>)&#123;<br>			OSRdyGrp &amp;= ~OSTCBCur-&gt;OSTCBBitY;<br>		&#125;<br>		OSTCBCur-&gt;OSTCBDly = ticks;<br>		<span class="hljs-built_in">OS_EXIT_CRITICAL</span>();<br>		<span class="hljs-built_in">OSSched</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="问题">问题</h4>
<table>
<thead>
<tr>
<th><img src="/47916/14.png" alt></th>
<th><img src="/47916/15.png" alt></th>
<th><img src="/47916/16.png" alt></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>这个问题是指，对于一个 <code>OSTimeDly()</code> 操作而言，其实我们是不能严格延迟一个时间周期的，因为可能出现高优先级的事务，最好是 <code>OSTimeDLY(2)</code>，同样对于 <code>OSRTimeDly(1)</code> 而言，其实严格意义上的 dly 时间是不确定的（抖动）。</p>
<h4 id="解决方案">解决方案</h4>
<ol>
<li>增加微处理器的时钟频率</li>
<li>增加时钟节拍的频率</li>
<li>重新安排任务的优先级</li>
<li>避免使用浮点运算（如果非使用不可,尽量用单精度数）</li>
<li>使用能较好地优化程序代码的编译器</li>
<li>时间要求苛刻的代码用汇编语言写</li>
<li>如果可能,用同一家族的更快的微处理器做系统升级。如从 8086 向 80186 升级, 从 68000 向 68020 升级等</li>
<li>不管怎么样，抖动总是存在的</li>
</ol>
<h4 id="OSTimeDlyHMSM"><code>OSTimeDlyHMSM()</code></h4>
<ol>
<li><code>OSTimeDlyHMSM()</code>：<code>OSTimeDly()</code> 的另一个版本，即按时分秒延时函数；</li>
<li>使用方法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">INT8U <span class="hljs-title">OSTimeDlyHMSM</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">	INT8U hours, <span class="hljs-comment">// 小时</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT8U minutes, <span class="hljs-comment">// 分钟</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT8U seconds, <span class="hljs-comment">// 秒</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT16U milli <span class="hljs-comment">// 毫秒</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>
<h4 id="OSTimeDlyResume"><code>OSTimeDlyResume()</code></h4>
<p><code>OSTimeDlyResume()</code>：让处在延时期的任务提前结束延时，进入就绪状态；</p>
<p>使用方法：</p>
<ol>
<li><code>INT8U OSTimeDlyResume(INT8U prio)</code>;</li>
<li><code>prio</code> 表示需要提前结束延时的任务的优先级/任务 ID。</li>
</ol>
<h4 id="系统时间">系统时间</h4>
<ol>
<li>每隔一个时钟节拍，发生一个时钟中断，将一个 32 位的计数器 <code>OSTime</code> 加 1；</li>
<li>该计数器在用户调用 <code>OSStart()</code> 初始化多任务和 4,294,967,295 个节拍执行完一遍的时候从 0 开始计数。若时钟节拍的频率等于 100Hz，该计数器每隔 497 天就重新开始计数；</li>
<li><code>OSTimeGet()</code>：获得该计数器的当前值；<code>INT32U OSTimeGet(void)</code>；</li>
<li><code>OSTimeSet()</code>：设置该计数器的值；<code>void OSTimeSet(INT32U ticks)</code>；</li>
</ol>
<h4 id="何时启动系统定时器">何时启动系统定时器</h4>
<ol>
<li>如果在 <code>OSStart</code> 之前启动定时器，则系统可能无法正确执行完 <code>OSStartHighRdy</code></li>
<li><code>OSStart</code> 函数直接调用 <code>OSStartHighRdy</code> 去执行最高优先级的任务，<code>OSStart</code> 不返回</li>
<li>系统定时器应该在系统的最高优先级任务中启动</li>
<li>使用 <code>OSRunning</code> 变量来控制操作系统的运行</li>
</ol>
<h4 id="时钟节拍的启动">时钟节拍的启动</h4>
<p>用户必须在多任务系统启动以后再开启时钟节拍器，也就是调用 <code>OSStart()</code> 之后。</p>
<p>在调用 <code>OSStart()</code> 之后做的第一件事是初始化定时器中断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">OSInit</span>(); <span class="hljs-comment">/* 初始化 uC/OS-II*/</span><br>	<span class="hljs-comment">/* 应用程序初始化代码... */</span><br>	<span class="hljs-comment">/* 调用 OSTaskCreate()建至少一个任务*/</span><br>	<span class="hljs-comment">//允许时钟节拍中断; /* 错误！可能 crash!*/</span><br>	<span class="hljs-built_in">OSStart</span>(); <span class="hljs-comment">/* 开始多任务调度 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="系统的初始化与启动">系统的初始化与启动</h4>
<p>在调用 μC/OS-II 的任何其它服务之前，用户必须首先调用系统初始化函数 <code>OSInit()</code> 来初始化 μC/OS 的所有变量和数据结构；</p>
<p><code>OSInit()</code> 建立空闲任务 <code>OSTaskIdle()</code>，该任务总是处于就绪状态，其优先级一般被设成最低，即 <code>OS_LOWEST_PRIO</code>；如果需要，<code>OSInit()</code> 还建立统计任务 <code>OSTaskStat()</code>，并让其进入就绪状态；</p>
<p><code>OSInit()</code> 还初始化了 4 个空数据结构缓冲区：空闲 TCB 链表 <code>OSTCBFreeList</code>、空闲事件链表 <code>OSEventFreeList</code>、空闲队列链表 <code>OSQFreeList</code> 和空闲存储链表 <code>OSMemFreeList</code>。</p>
<p><img src="/47916/17.png" alt></p>
<h3 id="μC-OS-II-的启动">μC/OS-II 的启动</h3>
<p>多任务的启动是用户通过调用 <code>OSStart()</code> 实现的。然而，启动 μC/OS-Ⅱ 之前，用户至少要建立一个应用任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">OSInit</span>(); <span class="hljs-comment">/* 初始化 uC/OS-II */</span><br>	<span class="hljs-comment">// ...</span><br>	通过调用 <span class="hljs-built_in">OSTaskCreate</span>() <span class="hljs-built_in">OSTaskCreateExt</span>()<br>	创建至少一个任务;<br>	<span class="hljs-comment">// ...</span><br>	<span class="hljs-built_in">OSStart</span>(); <span class="hljs-comment">/*开始多任务调度! 永不返回*/</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="OSStart"><code>OSStart()</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSStart</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	INT8U Y;<br>	INT8U X;<br>	<span class="hljs-keyword">if</span> (OSRunning == FALSE) &#123;<br>		y = OSUnMapTbl[OSRdyGrp];<br>		x = OSUnMapTbl[OSRdyTbl[y]];<br>		OSPrioHighRdy = (INT8U)((Y &lt;&lt; <span class="hljs-number">3</span>) + X);<br>		OSPrioCur = OSPrioHighRdy;<br>		OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];<br>		OSTCBCur = OSTCBHighRdy;<br>		<span class="hljs-built_in">OSStartHighRdy</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="统计任务初始化函数-OSStatInit-void">统计任务初始化函数 <code>OSStatInit(void)</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSStatInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-built_in">OSTimeDly</span>(<span class="hljs-number">2</span>);<br>	<span class="hljs-built_in">OS_ENTER_CRITICAL</span>();<br>	OSIdleCtr = <span class="hljs-number">0L</span>;<br>	<span class="hljs-built_in">OS_EXIT_CRITICAL</span>();<br>	<span class="hljs-built_in">OSTimeDly</span>(OS_TICKS_PER_SEC);<br>	<span class="hljs-built_in">OS_ENTER_CRITICAL</span>();<br>	OSIdleCtrMax = OSIdleCtr;<br>	OSStatRdy = TRUE;<br>	<span class="hljs-built_in">OS_EXIT_CRITICAL</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/47916/18.png" alt></p>
<p><img src="/47916/19.png" alt></p>
<h2 id="任务之间的通信与同步">任务之间的通信与同步</h2>
<p>任务间通信的管理：事件控制块 ECB</p>
<p>同步与互斥：</p>
<ol>
<li>临界区（Critical Sections）</li>
<li>信号量（Semaphores）</li>
</ol>
<p>任务间通信：</p>
<ol>
<li>邮箱（Message Mailboxes）</li>
<li>消息队列（Message Queues）</li>
</ol>
<h3 id="事件控制块-ECB">事件控制块 ECB</h3>
<p>所有的通信信号都被看成是事件（event）, μC/OS-II 通过事件控制块（ECB）来管理每一个具体事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ECB 数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-type">void</span> *OSEventPtr; <span class="hljs-comment">/*指向消息或消息队列列的指针*/</span><br>	INT8U OSEventTbl[OS_EVENT_TBL_SIZE];<span class="hljs-comment">//等待任务列列表</span><br>	INT16U OSEventCnt; <span class="hljs-comment">/*计数器（当事件是信号量时）*/</span><br>	INT8U OSEventType; <span class="hljs-comment">/*事件类型：信号量、邮箱等*/</span><br>	INT8U OSEventGrp; <span class="hljs-comment">/*等待任务组*/</span><br>&#125; OS_EVENT;<br></code></pre></td></tr></table></figure>
<p><img src="/47916/20.png" alt></p>
<h3 id="任务和-ISR-之间的通信方式">任务和 ISR 之间的通信方式</h3>
<ol>
<li>一个任务或 ISR 可以通过事件控制块 ECB（信号量、邮箱或消息队列）向另外的任务发信号；</li>
<li>一个任务还可以等待另一个任务或中断服务子程序给它发送信号。对于处于等待状态的任务，还可以给他指定一个最长等待时间。</li>
<li>多个任务可以同时等待同一个事件的发生。当该事件发生后，在所有等待该事件的任务中，优先级最高的任务得到了该事件并进入就绪状态，准备执行。</li>
</ol>
<h3 id="等待任务列列表">等待任务列列表</h3>
<p>每个正在等待某个事件的任务被加入到该事件的 ECB 的等待任务列表中，该列表包含两个变量 <code>OSEventGrp</code> 和 <code>OSEventTbl[]</code>。</p>
<p>在 <code>OSEventGrp</code> 中，任务按优先级分组，8 个任务为一组，共 8 组，分别对应 <code>OSEventGrp</code> 当中的 8 位。当某组中有任务处于等待该事件的状态时，对应的位就被置位。同时，<code>OSEventTbl[]</code> 中的相应位也被置位。</p>
<p><img src="/47916/21.png" alt></p>
<h3 id="使任务进入入-脱离等待状态">使任务进入入/脱离等待状态</h3>
<p>将一个任务插入到事件的等待任务列表中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pevent-&gt;OSEventGrp |= OSMapTbl[prio &gt;&gt; <span class="hljs-number">3</span>];<br>pevent-&gt;OSEventTbl[prio &gt;&gt; <span class="hljs-number">3</span>] |= OSMapTbl[prio &amp; <span class="hljs-number">0x07</span>];<br></code></pre></td></tr></table></figure>
<p>从等待任务列表中删除一个任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ((pevent-&gt;OSEventTbl[prio &gt;&gt; <span class="hljs-number">3</span>] &amp;= ~OSMapTbl[prio &amp; <span class="hljs-number">0x07</span>]) == <span class="hljs-number">0</span>) &#123;<br>	 pevent-&gt;OSEventGrp &amp;= ~OSMapTbl[prio &gt;&gt; <span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="在等待事件的任务列列表中查找优先级最高的">在等待事件的任务列列表中查找优先级最高的</h3>
<p>在等待任务列表中查找最高优先级的任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">y = OSUnMapTbl[pevent-&gt;OSEventGrp];<br>x = OSUnMapTbl[pevent-&gt;OSEventTbl[y]];<br>prio = (y &lt;&lt; <span class="hljs-number">3</span>) + x;<br></code></pre></td></tr></table></figure>
<h3 id="空闲-ECB-的管理">空闲 ECB 的管理</h3>
<p>ECB 的总数由用户所需要的信号量、邮箱和消息队列的总数决定，由 <code>OS_CFG.H</code> 中的<code> #define OS_MAX_EVENTS</code> 定义。</p>
<p>在调用 <code>OSInit()</code> 初始化系统时，所有的 ECB 被链接成一个单向链表——空闲事件控制块链表；</p>
<p>每当建立一个信号量、邮箱或消息队列时，就从该链表中取出一个空闲事件控制块，并对它进行初始化。</p>
<p><img src="/47916/22.png" alt></p>
<h3 id="ECB-的基本操作">ECB 的基本操作</h3>
<p><code>OSEventWaitListInit()</code></p>
<ol>
<li>初始化一个事件控制块。当创建一个信号量、邮箱或消息队列时，相应的创建函数会调用本函数对 ECB 的内容进行初始化，将 <code>OSEventGrp</code> 和 <code>OSEventTbl[]</code> 数组清零；</li>
<li><code>OSEventWaitListInit(OS_EVENT *pevent)</code></li>
<li><code>pevent</code>：指向需要初始化的事件控制块的指针。</li>
</ol>
<p><code>OSEventTaskRdy()</code></p>
<ol>
<li>使一个任务进入就绪态。当一个事件发生时，需要将其等待任务列表中的最高优先级任务置为就绪态；</li>
<li><code>OSEventTaskRdy(OS_EVENT *pevent, void *msg, INT8U msk)</code></li>
<li><code>msg</code>：指向消息的指针；<code>msk</code>：用于设置 TCB 的状态。</li>
</ol>
<p><code>OSEventTaskWait()</code></p>
<ol>
<li>使一个任务进入等待状态。当某个任务要等待一个事件的发生时，需要调用本函数将该任务从就绪任务表中删除，并放到相应事件的等待任务表中；</li>
<li><code>OSEventTaskWait(OS_EVENT *pevent)</code></li>
</ol>
<h3 id="同步与互斥">同步与互斥</h3>
<p>为了实现资源共享，一个操作系统必须提供临界区操作的功能；</p>
<p>μC/OS 采用关闭/打开中断的方式来处理临界区代码，从而避免竞争条件，实现任务间的互斥；</p>
<p>μC/OS 定义两个宏（macros）来开关中断，即：<code>OS_ENTER_CRITICAL()</code> 和 <code>OS_EXIT_CRITICAL()</code>；</p>
<p>这两个宏的定义取决于所用的微处理器，每种微处理器都有自己的 <code>OS_CPU.H</code> 文件。</p>
<p><img src="/47916/23.png" alt></p>
<h3 id="μC-OS-II-中开关中断的方法">μC/OS-II 中开关中断的方法</h3>
<p>当处理临界段代码时，需要关中断，处理完毕后，再开中断；</p>
<p>关中断时间是实时内核最重要的指标之一；</p>
<p>在实际应用中，关中断的时间很大程度中取决于微处理器的结构和编译器生成的代码质量；</p>
<h3 id="μC-OS-II-中采用了-3-种开关中断的方法">μC/OS-II 中采用了 3 种开关中断的方法</h3>
<ol>
<li><code>OS_CRITICAL_METHOD==1</code>：用处理器指令关中断，执行 <code>OS_ENTER_CRITICAL()</code>，开中断执行 <code>OS_EXIT_CRITICAL()</code>；</li>
<li><code>OS_CRITICAL_METHOD==2</code>：实现 <code>OS_ENTER_CRITICAL()</code> 时，先在堆栈中保存中断的开/关状态，然后再关中断；实现 <code>OS_EXIT_CRITICAL()</code> 时，从堆栈中弹出原来中断的开/关状态；</li>
<li><code>OS_CRITICAL_METHOD==3</code>：把当前处理器的状态字保存在局部变量中（如 <code>OS_CPU_SR</code>），关中断时保存，开中断时恢复</li>
</ol>
<h3 id="信号量">信号量</h3>
<ol>
<li>信号量在多任务系统中的功能： 1. 实现对共享资源的互斥访问（包括单个共享资源或多个相同的资源）； 2. 实现任务之间的行为同步；</li>
<li>必须在 <code>OS_CFG.H</code> 中将 <code>OS_SEM_EN</code> 开关常量置为 1，这样 μC/OS 才能支持信号量。</li>
<li>μC/OS 中信号量由两部分组成：信号量的计数值（16 位无符号整数）和等待该信号量的任务所组成的等待任务表；</li>
<li>信号量系统服务： 1. <code>OSSemCreate()</code> 2. <code>OSSemPend(), OSSemPost()</code> 3. <code>OSSemAccept(), OSSemQuery()</code></li>
</ol>
<h3 id="任务、ISR-和信号量的关系">任务、ISR 和信号量的关系</h3>
<p><img src="/47916/24.png" alt></p>
<h4 id="创建一个信号量">创建一个信号量</h4>
<p><code>OSSemCreate()</code></p>
<ol>
<li>创建一个信号量，并对信号量的初始计数值赋值，该初始值为 0 到 65,535 之间的一个数；</li>
<li><code>OS_EVENT OSSemCreate(INT16U cnt)</code></li>
<li><code>cnt</code>：信号量的初始值。</li>
</ol>
<p>执行步骤：</p>
<ol>
<li>从空闲事件控制块链表中得到一个 ECB；</li>
<li>初始化 ECB，包括设置信号量的初始值、把等待任务列表清零、设置 ECB 的事件类型等；</li>
<li>返回一个指向该事件控制块的指针。</li>
</ol>
<p><code>OSSemPend()</code></p>
<ol>
<li>等待一个信号量，即操作系统中的 P 操作，将信号量的值减 1；</li>
<li><code>OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)</code></li>
</ol>
<p>执行步骤：</p>
<ol>
<li>如果信号量的计数值大于 0，将它减 1 并返回；</li>
<li>如果信号量的值等于 0，则调用本函数的任务将被阻塞起来，等待另一个任务把它唤醒</li>
<li>调用 <code>OSSched()</code> 函数，调度下一个最高优先级的任务运行。</li>
</ol>
<p><code>OSSemPost()</code></p>
<ol>
<li>发送一个信号量，即操作系统中的 V 操作，将信号量的值加 1；</li>
<li><code>OSSemPost (OS_EVENT *pevent)</code></li>
</ol>
<p>执行步骤：</p>
<ol>
<li>检查是否有任务在等待该信号量，如果没有，将信号量的计数值加 1 并返回；</li>
<li>如果有，将优先级最高的任务从等待任务列表中删除，并使它进入就绪状态；</li>
<li>调用<code> OSSched()</code>，判断是否需要进行任务切换。</li>
</ol>
<h3 id="无等待地请求一个信号量">无等待地请求一个信号量</h3>
<p><code>OSSemAccept()</code></p>
<ol>
<li>当一个任务请求一个信号量时，如果该信号量暂时无效，则让该任务简单地返回，而不是进入等待状态；</li>
<li><code>INT16U OSSemAccept(OS_EVENT *pevent);</code></li>
</ol>
<p>执行步骤：</p>
<ol>
<li>如果该信号量的计数值大于 0，则将它减 1，然后将信号量的原有值返回；</li>
<li>如果该信号量的值等于 0，直接返回该值（0）。</li>
</ol>
<h3 id="查询一个信号量的当前状态">查询一个信号量的当前状态</h3>
<p><code>OSSemQuery()</code></p>
<ol>
<li>查询一个信号量的当前状态；</li>
<li><code>INT8U OSSemQuery(OS_EVENT *pevent,OS_SEM_DATA *pdata)</code></li>
<li>将指向信号量对应事件控制块的指针 <code>pevent</code> 所指向的 ECB 的内容拷贝到指向用于记录信号量信息的数据结构 <code>OS_SEM_DATA</code> 数据结构的指针 <code>pdata</code> 所指向的缓冲区当中。</li>
</ol>
<h3 id="任务间通信">任务间通信</h3>
<p>低级通信：</p>
<ol>
<li>只能传递状态和整数值等控制信息，传送的信息量小；</li>
<li>例如：信号量</li>
</ol>
<p>高级通信：</p>
<ol>
<li>能够传送任意数量的数据；</li>
<li>例如：共享内存、邮箱、消息队列</li>
</ol>
<h3 id="共享内存">共享内存</h3>
<p>在 μC/OS-II 中如何实现共享内存？</p>
<ol>
<li>内存地址空间只有一个，为所有的任务所共享！</li>
<li>为了避免竞争状态，需要使用信号量来实现互斥访问。</li>
</ol>
<h3 id="消息邮箱">消息邮箱</h3>
<p>邮箱（MailBox）：一个任务或 ISR 可以通过邮箱向另一个任务发送一个指针型的变量，该指针指向一个包含了特定“消息”（message）的数据结构；</p>
<p>必须在 <code>OS_CFG.H</code> 中将 <code>OS_MBOX_EN</code> 开关常量置为 1，这样 μC/OS 才能支持邮箱。</p>
<p>一个邮箱可能处于两种状态：</p>
<ol>
<li>满的状态：邮箱包含一个非空指针型变量；</li>
<li>空的状态：邮箱的内容为空指针 <code>NULL</code>：</li>
</ol>
<p>邮箱的系统服务：</p>
<ol>
<li><code>OSMboxCreate()</code></li>
<li><code>OSMboxPost()</code></li>
<li><code>OSMboxPend()</code></li>
<li><code>OSMboxAccept()</code></li>
<li><code>OSMboxQuery()</code></li>
</ol>
<h3 id="任务、ISR-和消息邮箱的关系">任务、ISR 和消息邮箱的关系</h3>
<p><img src="/47916/image-20221028214741331.png" alt></p>
<h3 id="邮箱的系统服务">邮箱的系统服务</h3>
<p><code>OSMboxCreate()</code>：创建一个邮箱</p>
<ol>
<li>在创建邮箱时，须分配一个 ECB，并使用其中的字段 <code>OSEventPtr</code> 指针来存放消息的地址；</li>
<li><code>OS_EVENT *OSMboxCreate(void *msg)</code></li>
<li>msg：指针的初始值，一般情形下为 <code>NULL</code>。</li>
</ol>
<p><code>OSMboxPend()</code>：等待一个邮箱中的消息</p>
<ol>
<li>若邮箱为满，将其内容（某消息的地址）返回；若邮箱为空，当前任务将被阻塞，直到邮箱中有了消息或等待超时</li>
<li><code>OSMboxPend (OS_EVENT *pevent,INT16U timeout, INT8U *err)</code></li>
</ol>
<p><code>OSMboxPost()</code>：发送一个消息到邮箱中</p>
<ol>
<li>如果有任务在等待该消息，将其中的最高优先级任务从等待列表中删除，变为就绪状态；</li>
<li><code>OSMboxPost(OS_EVENT *pevent, void *msg)</code></li>
</ol>
<p><code>OSMboxAccept()</code>：无等待地请求邮箱内容</p>
<ol>
<li>若邮箱为满，返回它的当前内容；若邮箱为空，返回空指针；</li>
<li><code>OSMboxAccept (OS_EVENT *pevent)</code></li>
</ol>
<p><code>OSMboxQuery()</code>：查询一个邮箱的状态</p>
<ol>
<li><code>OSMboxQuery (OS_EVENT *pevent,OS_MBOX_DATA *pdata)</code></li>
</ol>
<h3 id="消息队列">消息队列</h3>
<ol>
<li>消息队列（Message Queue)：消息队列可以使一个任务或 ISR 向另一个任务发送多个以指针方式定义的变量；</li>
<li>为了使 μC/OS 能够支持消息队列，必须在 <code>OS_CFG.H</code> 中将 <code>OS_Q_EN</code> 开关常量置为 1，并且通过常量 <code>OS_MAX_QS</code> 来决定系统支持的最多消息队列数。</li>
<li>一个消息队列可以容纳多个不同的消息，因此可把它看作是由多个邮箱组成的数组，只是它们共用一个等待任务列表：</li>
<li>消息队列的系统服务 1. <code>OSQCreate()</code> 2. <code>OSQPend()、OSQAccept()</code> 3. <code>OSQPost()、OSQPostFront()</code> 4. <code>OSQFlush()</code> 5. <code>OSQQuery()</code></li>
</ol>
<h3 id="消息队列列的体系结构">消息队列列的体系结构</h3>
<p><img src="/47916/26.png" alt></p>
<h3 id="队列列控制块">队列列控制块</h3>
<p>队列控制块数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">os_q</span> &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">os_q</span> *OSQPtr; <span class="hljs-comment">//空闲队列控制块指针</span><br>	<span class="hljs-type">void</span> **OSQStart; <span class="hljs-comment">//指向消息队列的起始地址</span><br>	<span class="hljs-type">void</span> **OSQEnd; <span class="hljs-comment">//指向消息队列的结束地址</span><br>	<span class="hljs-type">void</span> **OSQIn; <span class="hljs-comment">//指向消息队列中下一个插入消息的位置</span><br>	<span class="hljs-type">void</span> **OSQOut; <span class="hljs-comment">//指向消息队列中下一个取出消息的位置</span><br>	INT16U OSQSize; <span class="hljs-comment">//消息队列中总的单元数</span><br>	INT16U OSQEntries; <span class="hljs-comment">//消息队列中当前的消息数量</span><br>&#125; OS_EVENT;<br></code></pre></td></tr></table></figure>
<p><img src="/47916/27.png" alt></p>
<h3 id="空闲队列控制块的管理">空闲队列控制块的管理</h3>
<ol>
<li>每一个消息队列都要用到一个队列控制块。在 μC/OS 中，队列控制块的总数由 OS_CFG.H 中的常量 OS_MAX_QS 定义。</li>
<li>在系统初始化时，所有的队列控制块被链接成一个单向链表——空闲队列控制块链表 OSQFreeList。</li>
</ol>
<p><img src="/47916/28.png" alt></p>
<h3 id="消息缓冲区">消息缓冲区</h3>
<p><img src="/47916/image-20221028215046014.png" alt></p>
<h3 id="创建一个消息队列列">创建一个消息队列列</h3>
<p><code>OSQCreate()</code></p>
<ol>
<li><code>OS_EVENT *OSQCreate (void **start, INT16U size)</code></li>
<li><code>start</code>：指针数组，用来存放各个消息的地址</li>
<li><code>size</code>：数组的大小（即消息队列的元素个数）</li>
</ol>
<p>执行步骤</p>
<ol>
<li>从空闲事件控制块链表中取得一个 ECB；</li>
<li>从空闲队列控制块列表中取出一个队列控制块，并对其进行初始化；</li>
<li>初始化 ECB 的内容（事件类型、等待任务列表），并将 <code>OSEventPtr</code> 指针指向队列控制块。</li>
</ol>
<h3 id="队列列控制块与事件控制块">队列列控制块与事件控制块</h3>
<p><img src="/47916/30.png" alt></p>
<h3 id="请求消息队列列中的消息">请求消息队列列中的消息</h3>
<p><code>OSQPend()</code>：等待一个消息队列中的消息</p>
<ol>
<li><code>void *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)</code></li>
<li>如果消息队列中有至少一条消息，返回消息的地址；</li>
<li>如果没有消息，相应任务进入等待状态。</li>
</ol>
<p><code>OSQAccept()</code>：无等待地请求消息队列中的消息</p>
<ol>
<li><code>void *OSQAccept(OS_EVENT *pevent)；</code></li>
<li>如果消息队列中有消息，返回消息的地址；</li>
<li>如果消息队列中没有消息，返回 <code>NULL</code></li>
</ol>
<h3 id="向消息队列列发送一个消息">向消息队列列发送一个消息</h3>
<p><code>OSQPost()</code>：以 FIFO 方式向消息队列发送一个消息</p>
<ol>
<li><code>INT8U OSQPost (OS_EVENT *pevent, void *msg)</code></li>
<li>如果有任务在等待该消息队列，唤醒其中优先级最高的任务，并重新调度；</li>
<li>如果没有任务在等待该消息队列，而且此时消息队列未满，则以 FIFO 方式插入这个消息。</li>
</ol>
<p><code>OSQPostFront()</code>：以 LIFO 方式向消息队列发送一个消息：<code>INT8U OSQPostFront(OS_EVENT *pevent, void *msg)</code></p>
<h3 id="清空操作与查询操作">清空操作与查询操作</h3>
<p><code>OSQFlush()</code>：清空一个消息队列</p>
<ol>
<li><code>INT8U OSQFlush (OS_EVENT *pevent)</code>;</li>
<li>删除一个消息队列中的所有消息；</li>
</ol>
<p><code>OSQQuery()</code>：查询一个消息队列的状态</p>
<ul>
<li><code>INT8U OSQQuery (OS_EVENT *pevent,OS_Q_DATA *pdata)</code>；</li>
</ul>
<h2 id="存储管理">存储管理</h2>
<h3 id="概述">概述</h3>
<p>μC/OS 中是实模式存储管理</p>
<ol>
<li>不划分内核空间和用户空间，整个系统只有一个地址空间，即物理内存空间，应用程序和内核程序都能直接对所有的内存单元进行访问；</li>
<li>系统中的“任务”，实际上都是线程---只有运行上下文和栈是独享的，其他资源都是共享的。</li>
</ol>
<p>内存布局：代码段（text）、数据段（data）、bss 段、堆空间、栈空间；</p>
<h3 id="malloc-free？">malloc/free？</h3>
<p>在 ANSI C 中可以用 <code>malloc()</code> 和 <code>free()</code> 两个函数动态地分配内存和释放内存。在嵌入式实时操作系统中，容易产生碎片。</p>
<p>由于内存管理算法的原因，<code>malloc()</code> 和 <code>free()</code> 函数执行时间是不确定的。μC/OS-II 对 <code>malloc()</code> 和 <code>free()</code> 函数进行了改进，使得它们可以分配和释放固定大小的内存块。这样一来，<code>malloc()</code> 和 <code>free()</code> 函数的执行时间也是固定的了</p>
<p><img src="/47916/31.png" alt></p>
<h3 id="μC-OS-中的存储管理理">μC/OS 中的存储管理理</h3>
<ol>
<li>μC/OS 采用的是固定分区的存储管理方法 1. μC/OS 把连续的大块内存按分区来管理，每个分区包含有整数个大小相同的块； 2. 在一个系统中可以有多个内存分区，这样，用户的应用程序就可以从不同的内存分区中得到不同大小的内存块。但是，特定的内存块在释放时必须重新放回它以前所属于的内存分区； 3. 采用这样的内存管理算法，上面的内存碎片问题就得到了解决。</li>
</ol>
<p><img src="/47916/32.png" alt></p>
<h3 id="内存控制块">内存控制块</h3>
<p>为了便于管理，在 μC/OS 中使用内存控制块 MCB（Memory Control Block）来跟踪每一个内存分区，系统中的每个内存分区都有它自己的 MCB。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-type">void</span> *OSMemAddr; <span class="hljs-comment">/*分区起始地址*/</span><br>	<span class="hljs-type">void</span> *OSMemFreeList;<span class="hljs-comment">//下一个空闲内存块</span><br>	INT32U OSMemBlkSize; <span class="hljs-comment">/*内存块的大小*/</span><br>	INT32U OSMemNBlks; <span class="hljs-comment">/*内存块数量*/</span><br>	INT32U OSMemNFree; <span class="hljs-comment">/*空闲内存块数量*/</span><br>&#125; OS_MEM;<br></code></pre></td></tr></table></figure>
<h3 id="内存管理初始化">内存管理初始化</h3>
<p>如果要在 μC/OS-II 中使用内存管理，需要在 <code>OS_CFG.H</code> 文件中将开关量 <code>OS_MEM_EN</code> 设置为 1。这样 μC/OS-II 在系统初始化 <code>OSInit()</code> 时就会调用 <code>OSMemInit()</code>，对内存管理器进行初始化，建立空闲的内存控制块链表。</p>
<p><img src="/47916/33.png" alt></p>
<h3 id="创建一个内存分区">创建一个内存分区</h3>
<p><code>OSMemCreate()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">OS_MEM *<span class="hljs-title">OSMemCreate</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">	<span class="hljs-type">void</span> *addr, <span class="hljs-comment">// 内存分区的起始地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT32U nblks, <span class="hljs-comment">// 分区内的内存块数</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT32U blksize,<span class="hljs-comment">// 每个内存块的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">	INT8U *err)</span></span>; <span class="hljs-comment">// 指向错误码的指针</span><br></code></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">OS_MEM *CommTxBuf;<br>INT8U CommTxPart[<span class="hljs-number">100</span>][<span class="hljs-number">32</span>];<br>CommTxBuf = <span class="hljs-built_in">OSMemCreate</span>(CommTxPart, <span class="hljs-number">100</span>, <span class="hljs-number">32</span>, &amp;err);<br></code></pre></td></tr></table></figure>
<p><code>OSMemCreate()</code></p>
<ol>
<li>从系统的空闲内存控制块中取得一个 MCB；</li>
<li>将这个内存分区中的所有内存块链接成一个单向链表；</li>
<li>在对应的 MCB 中填写相应的信息。</li>
</ol>
<p><img src="/47916/image-20221028215649242.png" alt></p>
<h3 id="分配一个内存块">分配一个内存块</h3>
<ol>
<li><code>void *OSMemGet(OS_MEM *pmem, INT8U *err);</code></li>
<li>功能：从已经建立的内存分区中申请一个内存块。该函数的唯一参数是指向特定内存分区的指针。如果没有空闲的内存块可用，返回 <code>NULL</code> 指针。</li>
<li>应用程序必须知道内存块的大小，并且在使用时不能超过该容量。</li>
</ol>
<h3 id="释放一个内存块">释放一个内存块</h3>
<ol>
<li><code>INT8U OSMemPut(OS_MEM *pmem, void *pblk)</code></li>
<li>功能：将一个内存块释放并放回到相应的内存分区中。</li>
<li>注意：用户应用程序必须确认将内存块放回到了正确的内存分区中，因为 <code>OSMemPut()</code> 并不知道一个内存块是属于哪个内存分区的。</li>
</ol>
<h3 id="等待一个内存块">等待一个内存块</h3>
<ol>
<li>如果没有空闲的内存块，<code>OSMemGet()</code> 立即返回 <code>NULL</code>。能否在没有空闲内存块的时候让任务进入等待状态？</li>
<li>μC/OS-II 本身在内存管理上并不支持这项功能，如果需要的话，可以通过为特定内存分区增加信号量的方法，来实现此功能。</li>
<li>基本思路：当应用程序需要申请内存块时，首先要得到一个相应的信号量，然后才能调用 <code>OSMemGet()</code> 函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">OS_EVENT* SemaphorePtr;<br>OS_MEM* PartitionPtr;<br>INT8U Partition[<span class="hljs-number">100</span>][<span class="hljs-number">32</span>];<br>OS_STK TaskStk[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	INT8U err;<br>	<span class="hljs-built_in">OSInit</span>();<br>	<span class="hljs-comment">// ...</span><br>	SemaphorePtr = <span class="hljs-built_in">OSSemCreate</span>(<span class="hljs-number">100</span>);<br>	PartitionPtr = <span class="hljs-built_in">OSMemCreate</span>(Partition, <span class="hljs-number">100</span>, <span class="hljs-number">32</span>, &amp;err);<br>	<span class="hljs-built_in">OSTaskCreate</span>(Task, (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>, &amp;TaskStk[<span class="hljs-number">999</span>], &amp;err);<br>	<span class="hljs-built_in">OSStart</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Task</span><span class="hljs-params">(<span class="hljs-type">void</span>* pdata)</span> </span>&#123;<br>	INT8U err;<br>	INT8U* pblock;<br>	<span class="hljs-keyword">for</span> (;;) &#123;<br>		<span class="hljs-built_in">OSSemPend</span>(SemaphorePtr, <span class="hljs-number">0</span>, &amp;err);<br>		pblock = <span class="hljs-built_in">OSMemGet</span>(PartitionPtr, &amp;err);<br>		<span class="hljs-comment">/* 使用内存块 */</span><br>		<span class="hljs-comment">// ...</span><br>		<span class="hljs-built_in">OSMemPut</span>(PartitionPtr, pblock);<br>		<span class="hljs-built_in">OSSemPost</span>(SemaphorePtr);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="freertos-内存管理理">freertos 内存管理理</h3>
<p>三种 <code>pvPortMalloc()</code> 和 <code>vPortFree()</code> 的实现范例</p>
<p><img src="/47916/image-20221028215658987.png" alt></p>
<h3 id="Heap-1-c"><code>Heap_1.c</code></h3>
<ol>
<li>其实现了一个非常基本的 <code>pvPortMalloc()</code> 版本，而没有实现 <code>vPortFree()</code>。如果应用程序不需要删除任务，队列或者信号量，则其具有使用 <code>heap_1</code> 的潜质。其具有确定性。</li>
<li>这种分配方案将 <code>FreeRTOS</code> 的内存堆空间堪称一个简单的数组。当调用 <code>pvPortMalloc()</code> 时，则将数组又简单的细分成为更小的内存块。数组大小在 <code>FreeRTOSConfig.h</code> 中由 <code>configTOTAL_HEAP_SIZE</code> 定义。</li>
</ol>
<p><img src="/47916/image-20221028215703433.png" alt></p>
<h3 id="Heap-2-c"><code>Heap_2.c</code></h3>
<ol>
<li>其采用了一个最佳匹配算法来分配内存，并支持内存释放。由于声明了一个静态数组，所以会让整个应用程序看起来耗费了很多内存，即使是在数组没有进行任何实际分配之前。</li>
<li>最佳匹配算法保证 <code>pvPortMalloc()</code> 会使用最接近请求大小的空间块。例如： 1. 对空间包含了三个空闲内存块，分别为 5 字节，25 字节和 100 字节。 2. <code>pvPortMalloc()</code> 被调用用以请求分配 20 字节大小的内存空间。</li>
<li><code>Heap_2.c</code> 不会把相邻的空闲块合并成一个更大的内存块，所以会产生内存碎片如果分配和释放的总是相同大小的内存块，则内存碎片不会称为一个问题。所以 <code>Heap_2.c</code> 适合于那些重复创建与删除具有相同空间任务的应用程序。</li>
</ol>
<p><img src="/47916/image-20221028215706985.png" alt></p>
<h3 id="Heap-3-c"><code>Heap_3.c</code></h3>
<p>简单的调用了标准库 <code>malloc()</code> 和 <code>free()</code>，但是通过暂时挂起调度器使得函数调用具备了线程安全特性。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat-award.jpg" alt="EagleBear2002 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="EagleBear2002 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/12112/" rel="prev" title="云计算-06-分布式计算">
      <i class="fa fa-chevron-left"></i> 云计算-06-分布式计算
    </a></div>
      <div class="post-nav-item">
    <a href="/24134/" rel="next" title="嵌入式系统概论-06-嵌入式软件系统">
      嵌入式系统概论-06-嵌入式软件系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">任务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">任务主函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.2.</span> <span class="nav-text">任务优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.3.</span> <span class="nav-text">空闲任务和统计任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97-TCB"><span class="nav-number">1.4.</span> <span class="nav-text">任务控制块 TCB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E6%8C%87%E9%92%88"><span class="nav-number">1.5.</span> <span class="nav-text">栈指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E6%8C%87%E9%92%88"><span class="nav-number">1.6.</span> <span class="nav-text">链表指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2-TCB-%E9%93%BE%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">空闲 TCB 链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%EF%BC%88%E6%8C%87%E5%90%91%E7%9B%B8%E5%BA%94-TCB%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">指针数组（指向相应 TCB）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.9.</span> <span class="nav-text">状态的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%B0%B1%E7%BB%AA%E8%A1%A8"><span class="nav-number">1.10.</span> <span class="nav-text">任务就绪表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E4%BC%98%E5%85%88%E7%BA%A7%E7%A1%AE%E5%AE%9A%E5%B0%B1%E7%BB%AA%E8%A1%A8"><span class="nav-number">1.10.1.</span> <span class="nav-text">根据优先级确定就绪表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E4%BB%BB%E5%8A%A1%E8%84%B1%E7%A6%BB%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="nav-number">1.10.2.</span> <span class="nav-text">使任务脱离就绪态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">1.11.</span> <span class="nav-text">任务的调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%B0%B1%E7%BB%AA%E8%A1%A8%E7%A1%AE%E5%AE%9A%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%B3%E7%A7%BB%E4%B8%89%E4%BD%8D%EF%BC%89"><span class="nav-number">1.12.</span> <span class="nav-text">根据就绪表确定最高优先级（为什么右移三位）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">1.13.</span> <span class="nav-text">任务调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E6%9F%A5%E8%A1%A8%E6%B3%95"><span class="nav-number">1.14.</span> <span class="nav-text">源代码中使用了查表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%A4%E5%AE%9A%E8%A1%A8-OSUnMapTbl-256"><span class="nav-number">1.15.</span> <span class="nav-text">优先级判定表 OSUnMapTbl[256]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E-64-256"><span class="nav-number">1.16.</span> <span class="nav-text">从 64-&gt;256</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="nav-number">1.17.</span> <span class="nav-text">任务切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%BA%A7%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2-OS-TASK-SW"><span class="nav-number">1.17.1.</span> <span class="nav-text">任务级的任务切换 OS_TASK_SW()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2-OS-TASK-SW-%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.17.2.</span> <span class="nav-text">任务切换 OS_TASK_SW() 的代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B8%8A%E9%94%81"><span class="nav-number">1.17.3.</span> <span class="nav-text">给调度器上锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.18.</span> <span class="nav-text">任务管理的系统服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.18.1.</span> <span class="nav-text">创建任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSTaskCreate"><span class="nav-number">1.18.2.</span> <span class="nav-text">OSTaskCreate()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSTaskCreate-%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.18.3.</span> <span class="nav-text">OSTaskCreate() 的实现过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSTaskCreateExt"><span class="nav-number">1.18.4.</span> <span class="nav-text">OSTaskCreateExt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="nav-number">1.18.5.</span> <span class="nav-text">任务的栈空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="nav-number">1.18.6.</span> <span class="nav-text">动态分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="nav-number">1.18.7.</span> <span class="nav-text">内存碎片问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%A2%9E%E9%95%BF%E6%96%B9%E5%90%91"><span class="nav-number">1.18.8.</span> <span class="nav-text">栈的增长方向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.19.</span> <span class="nav-text">删除任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.20.</span> <span class="nav-text">挂起和恢复任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">中断和时间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">中断处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F-ISR"><span class="nav-number">2.2.</span> <span class="nav-text">中断服务程序 ISR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7-ISR-%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="nav-number">2.3.</span> <span class="nav-text">用户 ISR 的框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSIntEnter"><span class="nav-number">2.3.1.</span> <span class="nav-text">OSIntEnter()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSIntExit"><span class="nav-number">2.3.2.</span> <span class="nav-text">OSIntExit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSIntCtxSw"><span class="nav-number">2.3.3.</span> <span class="nav-text">OSIntCtxSw()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E5%87%BD%E6%95%B0-OSIntCtxSw-%E5%90%8E%E7%9A%84%E5%A0%86%E6%A0%88%E6%83%85%E5%86%B5"><span class="nav-number">2.3.4.</span> <span class="nav-text">调用中断切换函数 OSIntCtxSw() 后的堆栈情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D"><span class="nav-number">2.4.</span> <span class="nav-text">时钟节拍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D-ISR"><span class="nav-number">2.4.1.</span> <span class="nav-text">时钟节拍 ISR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D%E5%87%BD%E6%95%B0-OSTimetick"><span class="nav-number">2.4.2.</span> <span class="nav-text">时钟节拍函数 OSTimetick()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">时间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSTimeDLY"><span class="nav-number">2.5.1.</span> <span class="nav-text">OSTimeDLY()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.5.3.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSTimeDlyHMSM"><span class="nav-number">2.5.4.</span> <span class="nav-text">OSTimeDlyHMSM()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSTimeDlyResume"><span class="nav-number">2.5.5.</span> <span class="nav-text">OSTimeDlyResume()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4"><span class="nav-number">2.5.6.</span> <span class="nav-text">系统时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">2.5.7.</span> <span class="nav-text">何时启动系统定时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E8%8A%82%E6%8B%8D%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">2.5.8.</span> <span class="nav-text">时钟节拍的启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="nav-number">2.5.9.</span> <span class="nav-text">系统的初始化与启动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%CE%BCC-OS-II-%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">2.6.</span> <span class="nav-text">μC&#x2F;OS-II 的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSStart"><span class="nav-number">2.6.1.</span> <span class="nav-text">OSStart()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0-OSStatInit-void"><span class="nav-number">2.6.2.</span> <span class="nav-text">统计任务初始化函数 OSStatInit(void)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">任务之间的通信与同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97-ECB"><span class="nav-number">3.1.</span> <span class="nav-text">事件控制块 ECB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%92%8C-ISR-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">任务和 ISR 之间的通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%BB%BB%E5%8A%A1%E5%88%97%EF%A6%9C%E8%A1%A8"><span class="nav-number">3.3.</span> <span class="nav-text">等待任务列列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E4%BB%BB%E5%8A%A1%E8%BF%9B%E5%85%A5%E5%85%A5-%E8%84%B1%E7%A6%BB%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81"><span class="nav-number">3.4.</span> <span class="nav-text">使任务进入入&#x2F;脱离等待状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%97%EF%A6%9C%E8%A1%A8%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84"><span class="nav-number">3.5.</span> <span class="nav-text">在等待事件的任务列列表中查找优先级最高的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2-ECB-%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">3.6.</span> <span class="nav-text">空闲 ECB 的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECB-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.7.</span> <span class="nav-text">ECB 的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">3.8.</span> <span class="nav-text">同步与互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%CE%BCC-OS-II-%E4%B8%AD%E5%BC%80%E5%85%B3%E4%B8%AD%E6%96%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">μC&#x2F;OS-II 中开关中断的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%CE%BCC-OS-II-%E4%B8%AD%E9%87%87%E7%94%A8%E4%BA%86-3-%E7%A7%8D%E5%BC%80%E5%85%B3%E4%B8%AD%E6%96%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.10.</span> <span class="nav-text">μC&#x2F;OS-II 中采用了 3 种开关中断的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.11.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E3%80%81ISR-%E5%92%8C%E4%BF%A1%E5%8F%B7%EF%A5%BE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.12.</span> <span class="nav-text">任务、ISR 和信号量的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.12.1.</span> <span class="nav-text">创建一个信号量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%AD%89%E5%BE%85%E5%9C%B0%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.13.</span> <span class="nav-text">无等待地请求一个信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="nav-number">3.14.</span> <span class="nav-text">查询一个信号量的当前状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.15.</span> <span class="nav-text">任务间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">3.16.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%82%AE%E7%AE%B1"><span class="nav-number">3.17.</span> <span class="nav-text">消息邮箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E3%80%81ISR-%E5%92%8C%E6%B6%88%E6%81%AF%E9%82%AE%E7%AE%B1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.18.</span> <span class="nav-text">任务、ISR 和消息邮箱的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%AE%E7%AE%B1%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.19.</span> <span class="nav-text">邮箱的系统服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.20.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%A6%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.21.</span> <span class="nav-text">消息队列列的体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%EF%A6%9C%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">3.22.</span> <span class="nav-text">队列列控制块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">3.23.</span> <span class="nav-text">空闲队列控制块的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.24.</span> <span class="nav-text">消息缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%A6%9C"><span class="nav-number">3.25.</span> <span class="nav-text">创建一个消息队列列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%EF%A6%9C%E6%8E%A7%E5%88%B6%E5%9D%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">3.26.</span> <span class="nav-text">队列列控制块与事件控制块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%A6%9C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF"><span class="nav-number">3.27.</span> <span class="nav-text">请求消息队列列中的消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%A6%9C%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF"><span class="nav-number">3.28.</span> <span class="nav-text">向消息队列列发送一个消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">3.29.</span> <span class="nav-text">清空操作与查询操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-free%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">malloc&#x2F;free？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%CE%BCC-OS-%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%EF%A7%A4"><span class="nav-number">4.3.</span> <span class="nav-text">μC&#x2F;OS 中的存储管理理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">4.4.</span> <span class="nav-text">内存控制块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text">内存管理初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="nav-number">4.6.</span> <span class="nav-text">创建一个内存分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%9D%97"><span class="nav-number">4.7.</span> <span class="nav-text">分配一个内存块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%9D%97"><span class="nav-number">4.8.</span> <span class="nav-text">释放一个内存块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%9D%97"><span class="nav-number">4.9.</span> <span class="nav-text">等待一个内存块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freertos-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%A7%A4"><span class="nav-number">4.10.</span> <span class="nav-text">freertos 内存管理理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap-1-c"><span class="nav-number">4.11.</span> <span class="nav-text">Heap_1.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap-2-c"><span class="nav-number">4.12.</span> <span class="nav-text">Heap_2.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap-3-c"><span class="nav-number">4.13.</span> <span class="nav-text">Heap_3.c</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EagleBear2002"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">EagleBear2002</p>
  <div class="site-description" itemprop="description">暮雪朝霜，毋改英雄意气</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">483</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EagleBear2002" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EagleBear2002" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:eaglebear2002@foxmail.com" title="E-Mail → mailto:eaglebear2002@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://czxingchen.github.io/" title="https:&#x2F;&#x2F;czxingchen.github.io&#x2F;" rel="noopener" target="_blank">PL 顶会研究者-XiaoZhi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/the-sword-of-king/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;the-sword-of-king&#x2F;" rel="noopener" target="_blank">模式识别专家-崖山剑</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://en.ydjsir.com.cn/" title="https:&#x2F;&#x2F;en.ydjsir.com.cn&#x2F;" rel="noopener" target="_blank">愿逐月华流照君-YDJSIR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/m0_51691879?spm=1000.2115.3001.5343" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_51691879?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank">软院科协掌门人-wbl_z</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://itxia.club/" title="https:&#x2F;&#x2F;itxia.club&#x2F;" rel="noopener" target="_blank">侠之大者为国为民-IT 侠</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://chestnutsilver.github.io/TJIS-My-Helloworld/" title="https:&#x2F;&#x2F;chestnutsilver.github.io&#x2F;TJIS-My-Helloworld&#x2F;" rel="noopener" target="_blank">因果推断爱好者-ChestnutSilver</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://atritium.github.io/" title="https:&#x2F;&#x2F;atritium.github.io&#x2F;" rel="noopener" target="_blank">任天堂技术扛把子-manqi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.sakiyary.cn/" title="https:&#x2F;&#x2F;blog.sakiyary.cn&#x2F;" rel="noopener" target="_blank">教育部教学创新项目负责人-哈气鸭梨</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://huoxj.github.io/" title="https:&#x2F;&#x2F;huoxj.github.io&#x2F;" rel="noopener" target="_blank">离百年博客还有 98 年捞程序 Runz</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.erinwithbmq.xin/" title="https:&#x2F;&#x2F;www.erinwithbmq.xin&#x2F;" rel="noopener" target="_blank">摸鱼小能手 ErinwithBMQ の 尋夢之旅</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tilnel.github.io/" title="https:&#x2F;&#x2F;tilnel.github.io&#x2F;" rel="noopener" target="_blank">南大耐摔王 Tilnel 的杂谈小屋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.azifan.club/" title="https:&#x2F;&#x2F;blog.azifan.club&#x2F;" rel="noopener" target="_blank">水龙之魂</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mzy0624.github.io/" title="https:&#x2F;&#x2F;mzy0624.github.io&#x2F;" rel="noopener" target="_blank">Haibara AI</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EagleBear2002</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">40:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : ,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
